.. _observer:
.. _altdata:
.. _observer--observer:

########
Observer
########

..
    Sect<12>

The DDS-DCPS approach to data transfer using synchronization of strongly-typed caches (DataWriter and DataReader) is not appropriate for all applications.
Therefore OpenDDS provides an alternate interface called Observer which is described in this section.
Observers play a role similar to the spec-defined Listeners (attached to DataReaders and/or DataWriters).
Unlike the Listeners, Observers don't need to interact with the DataReader/Writer caches to access the data samples.
This interface is not defined by OMG specifications and may change in future releases of OpenDDS, including minor updates.

The XTypes Dynamic Language Binding (:ref:`xtypes--dynamic-language-binding`) provides a set of related features that can be used to create DataWriters and DataReaders that work with a generic data container (DynamicData) instead of a specific IDL-generated data type.

..
    Sect<12.2>

To observe the most important events happening within OpenDDS, applications can create classes that derive from the Observer base class (in :ghfile:`dds/DCPS/Observer.h`).
The design of Observer is intended to allow applications to have a single Observer object observing many Entities, however this is flexible to allow many different use cases.
The following events can be observed:

* DataWriter/Reader enabled, deleted

* DataWriter/Reader QoS changed

* DataWriter/Reader peer associated, disassociated

* DataWriter sample sent, instance disposed, instance unregistered

* DataReader sample received (enters the cache), read, taken, instance disposed, instance unregistered

.. _observer--attaching-observers-to-entities:

Attaching Observers to Entities
===============================

..
    Sect<12.2.1>

Entity is the spec-defined base interface of the following types:

* DataWriter, DataReader

  * As seen above in :ref:`observer--observer`, the Observer events originate in the DataWriter and DataReader Entities

* DomainParticipant, Publisher, Subscriber

  * Among their other roles, these Entities act as containers (either directly or indirectly) for DataWriters and DataReaders.

  * If a smaller-scoped Entity (such as a DataWriter) has no Observer for the event in question, its containing Entity (in this example, a Publisher) is checked for an Observer.

* Topic

  * Although it is an Entity, no Observer events are generated by Topics or Entities they contain (since they don't contain any Entities)

The class ``EntityImpl`` (in :ghfile:`dds/DCPS/EntityImpl.h`) is OpenDDS's base class for all Entity types.
``EntityImpl`` includes public methods for Observer registration: ``set_observer`` and ``get_observer``.
These methods are not part of the IDL interfaces, so invoking them the requires a cast to the implementation (Impl) of Entity.

.. code-block:: cpp

     DDS::DataWriter_var dw = /* ... */;
     EntityImpl* entity = dynamic_cast<EntityImpl*>(dw.in());
     Observer_rch observer = make_rch<MyObserver>();
     entity->set_observer(observer, Observer::e_SAMPLE_SENT);

Note that since the ``Observer`` class is an internal (not IDL) interface, it uses the "RCH" (Reference Counted Handle) smart pointer classes.
Observer itself inherits from ``RcObject``, and uses of ``Observer``-derived classes should use the ``RcHandle`` template and its associated functions, as in the example above.
See :ghfile:`dds/DCPS/RcHandle_T.h` for details.

.. _observer--writing-observer-derived-classes:

Writing Observer-Derived Classes
================================

..
    Sect<12.2.2>

The virtual methods in the ``Observer`` class are divided into 3 groups based on the general category of events they observe:

#. Operations on the observed ``Entity`` itself

   * ``on_enabled``, ``on_deleted``, ``on_qos_changed``

   * The only parameter to these methods is the ``Entity``, so the ``Observer`` implementation can use the public methods on the ``Entity``.

#. Events relating to associating with remote matched endpoints

   * ``on_associated``, ``on_disassociated``

   * In addition to the ``Entity``, the ``Observer`` implementation receives a ``GUID_t`` structure which is the internal representation of remote ``Entity`` identity.
     The ``GUID_t`` values from ``on_associated`` could be stored or logged to correlate them with the values from ``on_disassociated``.

#. Events relating to data samples moving through the system

   * ``on_sample_sent``, ``on_sample_received``, ``on_sample_read``, ``on_sample_taken``, ``on_disposed``, ``on_unregistered``

   * In addition to the ``Entity``, the ``Observer`` implementation receives an instance of the ``Sample`` structure.
     The definition of this structure is nested within ``Observer``.
     See below for details.

.. _observer--the-observer-sample-structure:

The Observer::Sample structure
==============================

..
    Sect<12.2.3>

The ``Observer::Sample`` structure contains the following fields:

* ``instance`` and ``instance_state``

  * Describe the instance that this sample belongs to, using the spec-defined types

* ``timestamp`` and ``sequence_number``

  * Attributes of the sample itself: ``timestamp`` uses a spec-defined type whereas ``sequence_number`` uses the OpenDDS internal type for DDSI-RTPS 64-bit sequence numbers.

* ``data`` and ``data_dispatcher``

  * Since ``Observer`` is an un-typed interface, the contents of the data sample itself are represented only as a void pointer

  * Implementations that need to process this data can use the ``data_dispatcher`` object to interpret it.
    See the class definition of ``ValueDispatcher`` in :ghfile:`dds/DCPS/ValueDispatcher.h` for more details.

