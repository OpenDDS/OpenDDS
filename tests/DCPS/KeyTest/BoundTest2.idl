/*
 *
 *
 * Distributed under the OpenDDS License.
 * See: http://www.opendds.org/license.html
 */

#include "tao/StringSeq.pidl"
#include "tao/FloatSeq.pidl"

// Struct with all simple bounded fields
module Bound {

  // Bounded sequence of bounded type
  typedef sequence<float, 20> BoundedFloatSeq;

  @topic
  struct BoundedSequenceOfBoundedMessage {
    BoundedFloatSeq float_seq;
  };

  // Unbounded sequence of bounded type
  typedef sequence<float> UnboundedFloatSeq;

  @topic
  struct UnboundedSequenceOfBoundedMessage {
    UnboundedFloatSeq float_seq;
  };

  // Bounded sequence of unbounded type
  typedef sequence<string, 20> BoundedStringSeq;

  @topic
  struct BoundedSequenceOfUnboundedMessage {
    BoundedStringSeq string_seq;
  };

  // Unbounded sequence of unbounded type
  typedef sequence<string> UnboundedStringSeq;

  @topic
  struct UnboundedSequenceOfUnboundedMessage {
    UnboundedStringSeq string_seq;
  };

  // Union of bounded types
  union BoundedUnion switch (short) {
  case 1: float float_field;
  case 2: long long_field;
  default: short short_field;
  };

  @topic
  struct BoundedUnionMessage {
    BoundedUnion union_field;
  };

  // Union of unbounded types
  union UnboundedUnion switch (short) {
  case 1: string string_field;
  case 2: long long_field;
  default: short short_field;
  };

  @topic
  struct UnboundedUnionMessage {
    UnboundedUnion union_field;
  };

  // Recursive type definition (unbounded)
  struct RecursiveMessage;

  typedef sequence<RecursiveMessage, 1> SingleMessageSeq;

  union NestedMessageUnion switch (short) {
  case 1: SingleMessageSeq message;
  case 2: long long_field;
  default: short short_field;
  };

  @topic
  struct RecursiveMessage {
    NestedMessageUnion union_field;
    float float_field;
  };

};
