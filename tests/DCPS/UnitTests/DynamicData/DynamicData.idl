#include <tao/LongSeq.pidl>
#include <tao/ULongSeq.pidl>
#include <tao/Int8Seq.pidl>
#include <tao/UInt8Seq.pidl>
#include <tao/ShortSeq.pidl>
#include <tao/UShortSeq.pidl>
#include <tao/LongLongSeq.pidl>
#include <tao/ULongLongSeq.pidl>
#include <tao/FloatSeq.pidl>
#include <tao/DoubleSeq.pidl>
#include <tao/LongDoubleSeq.pidl>
#include <tao/CharSeq.pidl>
#include <tao/WCharSeq.pidl>
#include <tao/OctetSeq.pidl>
#include <tao/BooleanSeq.pidl>
#include <tao/StringSeq.pidl>
#include <tao/WStringSeq.pidl>

enum SomeEnum {
  E_INT32, // 0
  E_UINT32, // 1
  E_INT8, // 2
  E_UINT8, // 3
  E_INT16, // 4
  E_UINT16, // 5
  E_INT64, // 6
  E_UINT64, // 7
  E_FLOAT32, // 8
  E_FLOAT64, // 9
  E_FLOAT128, // 10
  E_CHAR8, // 11
  E_CHAR16, // 12
  E_BYTE, // 13
  E_BOOL, // 14
  E_STRING8, // 15
  E_STRING16 // 16
};

typedef sequence<SomeEnum> SomeEnumSeq;
typedef sequence<long> Int32Seq;
typedef sequence<unsigned long> UInt32Seq;
typedef sequence<int8> Int8Seq;
typedef sequence<uint8> UInt8Seq;
typedef sequence<short> Int16Seq;
typedef sequence<unsigned short> UInt16Seq;
typedef sequence<long long> Int64Seq;
typedef sequence<unsigned long long> UInt64Seq;
typedef sequence<float> Float32Seq;
typedef sequence<double> Float64Seq;
typedef sequence<long double> Float128Seq;
typedef sequence<char> Char8Seq;
typedef sequence<wchar> Char16Seq;
typedef sequence<octet> ByteSeq;
typedef sequence<boolean> BoolSeq;
typedef sequence<string> StringSeq;
typedef sequence<wstring> WStringSeq;

@final
struct NestedFinalStruct {
  long l;
};

// Reading single value from struct.
@mutable
struct SingleValueStruct {
  @id(0) SomeEnum my_enum;
  @id(1) long int_32;
  @id(2) unsigned long uint_32;
  @id(3) int8 int_8;
  @id(4) uint8 uint_8;
  @id(5) short int_16;
  @id(6) unsigned short uint_16;
  @id(7) long long int_64;
  @id(8) unsigned long long uint_64;
  @id(9) float float_32;
  @id(10) double float_64;
  @id(11) long double float_128;
  @id(12) char char_8;
  @id(13) wchar char_16;
  @id(14) octet byte;
  @id(15) boolean bool;
  @id(16) NestedFinalStruct nested_struct;
  @id(17) string str;
  @id(18) wstring wstr;
};

@final
struct SingleValueStructFinal {
  @id(0) SomeEnum my_enum;
  @id(1) long int_32;
  @id(2) unsigned long uint_32;
  @id(3) int8 int_8;
  @id(4) uint8 uint_8;
  @id(5) short int_16;
  @id(6) unsigned short uint_16;
  @id(7) long long int_64;
  @id(8) unsigned long long uint_64;
  @id(9) float float_32;
  @id(10) double float_64;
  @id(11) long double float_128;
  @id(12) char char_8;
  @id(13) wchar char_16;
  @id(14) octet byte;
  @id(15) boolean bool;
  @id(16) NestedFinalStruct nested_struct;
  @id(17) string str;
  @id(18) wstring wstr;
};

// Reading single value from union.
@mutable
union SingleValueUnion switch (SomeEnum) {
case E_INT32:
  @id(1) long int_32;
case E_UINT32:
  @id(2) unsigned long uint_32;
case E_INT8:
  @id(3) int8 int_8;
case E_UINT8:
  @id(4) uint8 uint_8;
case E_INT16:
  @id(5) short int_16;
case E_UINT16:
  @id(6) unsigned short uint_16;
case E_INT64:
  @id(7) long long int_64;
case E_UINT64:
  @id(8) unsigned long long uint_64;
case E_FLOAT32:
  @id(9) float float_32;
case E_FLOAT64:
  @id(10) double float_64;
case E_FLOAT128:
  @id(11) long double float_128;
case E_CHAR8:
  @id(12) char char_8;
case E_CHAR16:
  @id(13) wchar char_16;
case E_BYTE:
  @id(14) octet byte_;
case E_BOOL:
  @id(15) boolean bool_;
case E_STRING8:
  @id(16) string str;
case E_STRING16:
  @id(17) wstring wstr;
default:
  @id(18) SomeEnum my_enum;
};

// Reading single value from union.
@final
union SingleValueUnionFinal switch (SomeEnum) {
case E_INT32:
  @id(1) long int_32;
case E_UINT32:
  @id(2) unsigned long uint_32;
case E_INT8:
  @id(3) int8 int_8;
case E_UINT8:
  @id(4) uint8 uint_8;
case E_INT16:
  @id(5) short int_16;
case E_UINT16:
  @id(6) unsigned short uint_16;
case E_INT64:
  @id(7) long long int_64;
case E_UINT64:
  @id(8) unsigned long long uint_64;
case E_FLOAT32:
  @id(9) float float_32;
case E_FLOAT64:
  @id(10) double float_64;
case E_FLOAT128:
  @id(11) long double float_128;
case E_CHAR8:
  @id(12) char char_8;
case E_CHAR16:
  @id(13) wchar char_16;
case E_BYTE:
  @id(14) octet byte_;
case E_BOOL:
  @id(15) boolean bool_;
case E_STRING8:
  @id(16) string str;
case E_STRING16:
  @id(17) wstring wstr;
default:
  @id(18) SomeEnum my_enum;
};

/*
// TODO: Reading single value from array.
@mutable
struct ArrayStruct {
  long int_32a[2];
  unsigned long uint_32a[2];
  int8 int_8a[2];
  uint8 uint_8a[2];
  short int_16a[2];
  unsigned short uint_16a[2];
  long long int_64a[2];
  unsigned long long uint_64a[2];
  float float_32a[2];
  double float_64a[2];
  long double float_128a[2];
  char char_8a[2];
  wchar char_16a[2];
  octet byte_a[2];
  boolean bool_a[2];
  string str_a[2];
  wstring wstr_a[2];
};
*/

// Reading single value from sequence and reading sequence from struct.
@mutable
struct SequenceStruct {
  @id(0) SomeEnumSeq my_enums;
  @id(1) Int32Seq int_32s;
  @id(2) UInt32Seq uint_32s;
  @id(3) Int8Seq int_8s;
  @id(4) UInt8Seq uint_8s;
  @id(5) Int16Seq int_16s;
  @id(6) UInt16Seq uint_16s;
  @id(7) Int64Seq int_64s;
  @id(8) UInt64Seq uint_64s;
  @id(9) Float32Seq float_32s;
  @id(10) Float64Seq float_64s;
  @id(11) Float128Seq float_128s;
  @id(12) Char8Seq char_8s;
  @id(13) Char16Seq char_16s;
  @id(14) ByteSeq byte_s;
  @id(15) BoolSeq bool_s;
  @id(16) StringSeq str_s;
  @id(17) WStringSeq wstr_s;
};

@final
struct SequenceStructFinal {
  @id(0) SomeEnumSeq my_enums;
  @id(1) Int32Seq int_32s;
  @id(2) UInt32Seq uint_32s;
  @id(3) Int8Seq int_8s;
  @id(4) UInt8Seq uint_8s;
  @id(5) Int16Seq int_16s;
  @id(6) UInt16Seq uint_16s;
  @id(7) Int64Seq int_64s;
  @id(8) UInt64Seq uint_64s;
  @id(9) Float32Seq float_32s;
  @id(10) Float64Seq float_64s;
  @id(11) Float128Seq float_128s;
  @id(12) Char8Seq char_8s;
  @id(13) Char16Seq char_16s;
  @id(14) ByteSeq byte_s;
  @id(15) BoolSeq bool_s;
  @id(16) StringSeq str_s;
  @id(17) WStringSeq wstr_s;
};

// Test skipping nested struct in a non-mutable type.
@appendable
struct AppendableStruct {
  char c;
  NestedFinalStruct nested_struct1;
  short s;
  NestedFinalStruct nested_struct2;
  int8 i;
  long l2;
};

/*
// TODO: Reading sequence from union.
@mutable
union SequenceUnion switch (SomeEnum) {
case E_INT32:
  Int32Seq int_32s;
case E_UINT32:
  UInt32Seq uint_32s;
case E_INT8:
  Int8Seq int_8s;
case E_UINT8:
  UInt8Seq uint_8s;
case E_INT16:
  Int16Seq int_16s;
case E_UINT16:
  UInt16Seq uint_16s;
case E_INT64:
  Int64Seq int_64s;
case E_UINT64:
  UInt64Seq uint_64s;
case E_FLOAT32:
  Float32Seq float_32s;
case E_FLOAT64:
  Float64Seq float_64s;
case E_FLOAT128:
  Float128Seq float_128s;
case E_CHAR8:
  Char8Seq char_8s;
case E_CHAR16:
  Char16Seq char_16s;
case E_BYTE:
  ByteSeq byte_s;
case E_BOOL:
  BoolSeq bool_s;
case E_STRING8:
  StringSeq str_s;
case E_STRING16:
  WStringSeq wstr_s;
};

// TODO: Reading nested sequence from another sequence.
@mutable
struct SequenceInSequenceStruct {
  sequence<Int32Seq> int_32ss;
  sequence<UInt32Seq> uint_32ss;
  sequence<Int8Seq> int_8ss;
  sequence<UInt8Seq> uint_8ss;
  sequence<Int16Seq> int_16ss;
  sequence<UInt16Seq> uint_16ss;
  sequence<Int64Seq> int_64ss;
  sequence<UInt64Seq> uint_64ss;
  sequence<Float32Seq> float_32ss;
  sequence<Float64Seq> float_64ss;
  sequence<Float128Seq> float_128ss;
  sequence<Char8Seq> char_8ss;
  sequence<Char16Seq> char_16ss;
  sequence<ByteSeq> byte_ss;
  sequence<BoolSeq> bool_ss;
  sequence<StringSeq> str_ss;
  sequence<WStringSeq> wstr_ss;
};

// Reading nested sequence from an array.
@mutable
struct SequenceInArrayStruct {
  Int32Seq int_32as[2];
  UInt32Seq uint_32as[2];
  Int8Seq int_8as[2];
  UInt8Seq uint_8as[2];
  Int16Seq int_16as[2];
  UInt16Seq uint_16as[2];
  Int64Seq int_64as[2];
  UInt64Seq uint_64as[2];
  Float32Seq float_32as[2];
  Float64Seq float_64as[2];
  Float128Seq float_128as[2];
  Char8Seq char_8as[2];
  Char16Seq char_16as[2];
  ByteSeq byte_as[2];
  BoolSeq bool_as[2];
  StringSeq str_as[2];
  WStringSeq wstr_as[2];
};
*/
