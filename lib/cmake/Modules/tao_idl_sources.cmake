

set(TAO_VERSIONING_IDL_FLAGS
  -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL
  -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL
)

if (CORBA_E_MICRO)
  list(APPEND TAO_CORBA_IDL_FLAGS -DCORBA_E_MICRO -Gce)
endif()

if (CORBA_E_COMPACT)
  list(APPEND TAO_CORBA_IDL_FLAGS -DCORBA_E_COMPACT -Gce)
endif()

if (MINIMUM_CORBA)
  list(APPEND TAO_CORBA_IDL_FLAGS -DTAO_HAS_MINIMUM_POA -Gmc)
endif()

if (TAO_NO_IIOP)
  list(APPEND TAO_CORBA_IDL_FLAGS -DTAO_LACKS_IIOP)
endif()

if (GEN_OSTREAM)
  list(APPEND TAO_CORBA_IDL_FLAGS -Gos)
endif()

if (NOT TAO_HAS_OPTIMIZE_COLLOCATED_INVOCATIONS)
  list(APPEND TAO_CORBA_IDL_FLAGS -Sp -Sd)
endif()

macro(tao_setup_visual_studio_custom_command_fanout_dependencies)
  ## This is a special rule for Visual Studio to deal with the outputs of
  ## an add_custom_command() are used by multiple targets. For example, the
  ## generated files for the $TAO_ROOT/tao directory are splitted into TAO
  ## TAO_AnyTypeCode and TAO_PortableServer targets.
  ##
  cmake_parse_arguments(_arg "" "" "TARGETS;DEPENDS;OUTPUT"  ${ARGN})

  if (CMAKE_GENERATOR MATCHES "Visual Studio")
    set(first_target)
    foreach(target ${_arg_TARGETS})
      if (first_target)
        ## ${target} is not the first target in the target list;
        ## it cannot trigger the processing of ${_arg_DEPENDS}. Instead,
        ## we need ${target} to depend on the ${first_target}. In addition,
        ## we need to mark ${_arg_OUTPUT} files to be generated by a dummy
        ## add_custom_command rule(); otherwise, cmake would consider
        ## the ${_arg_OUTPUT} files missing and cause
        ## configuration errors.
        add_dependencies(${target} ${first_target})
        if (_arg_OUTPUT)
          add_custom_command(
            OUTPUT ${_arg_OUTPUT}
            COMMAND ${CMAKE_COMMAND} -E echo ""
          )
          set(_arg_OUTPUT)
        endif()
      else()
        ## ${target} is the first target in the list and it
        ## is the only target that can trigger the processing
        ## of ${_arg_DEPENDS} files.
        target_sources(${target} PRIVATE ${_arg_DEPENDS})
        set(first_target ${target})
      endif()
    endforeach()
  endif()
endmacro(tao_setup_visual_studio_custom_command_fanout_dependencies)

function(tao_idl_command name)
  set(multiValueArgs IDL_FLAGS IDL_FILES USED_BY WORKING_DIRECTORY)
  cmake_parse_arguments(_arg "" "" "${multiValueArgs}" ${ARGN})

  set(_arg_IDL_FLAGS ${TAO_BASE_IDL_FLAGS} ${_arg_IDL_FLAGS})

  if (NOT _arg_IDL_FILES)
    message(FATAL_ERROR "using tao_idl_command(${name}) without specifying IDL_FILES")
  endif()

  if ((CMAKE_GENERATOR MATCHES "Visual Studio") AND (_arg_USED_BY MATCHES ";"))
    set(exclude_cpps_from_command_output ON)
  endif()

  if (NOT _arg_WORKING_DIRECTORY)
    set(_working_binary_dir ${CMAKE_CURRENT_BINARY_DIR})
    set(_working_source_dir ${CMAKE_CURRENT_SOURCE_DIR})
  elseif (NOT IS_ABSOLUTE "${_arg_WORKING_DIRECTORY}")
    set(_working_binary_dir ${CMAKE_CURRENT_BINARY_DIR}/${_arg_WORKING_DIRECTORY})
    set(_working_source_dir ${CMAKE_CURRENT_SOURCE_DIR}/${_arg_WORKING_DIRECTORY})
  else()
    set(_working_binary_dir ${_arg_WORKING_DIRECTORY})
    set(_working_source_dir ${CMAKE_CURRENT_SOURCE_DIR})
  endif()

  ## convert all include paths to be relative to binary tree instead of to source tree
  file(RELATIVE_PATH _rel_path_to_source_tree ${_working_binary_dir} ${_working_source_dir})
  foreach(flag ${_arg_IDL_FLAGS})
    if ("${flag}" MATCHES "^-I(\\.\\..*)")
       list(APPEND _converted_flags -I${_rel_path_to_source_tree}/${CMAKE_MATCH_1})
     else()
       list(APPEND _converted_flags ${flag})
       # if the flag is like "-Wb,stub_export_file=filename" then set the varilabe
       # "idl_cmd_arg-wb-stub_export_file" to filename
       string(REGEX MATCH "^-Wb,([^=]+)=(.+)" m "${flag}")
       if (m)
         set(idl_cmd_arg-wb-${CMAKE_MATCH_1} ${CMAKE_MATCH_2})
       endif()
    endif()
  endforeach()

  set(optionArgs -Sch -Sci -Scc -Ssh -SS -GA -GT -GX -Gxhst -Gxhsk)
  cmake_parse_arguments(_idl_cmd_arg "${optionArgs}" "-o;-oS;-oA" "" ${_arg_IDL_FLAGS})

  if ("${_idl_cmd_arg_-o}" STREQUAL "")
    set(_output_dir "${_working_binary_dir}")
  else()
    set(_output_dir "${_working_binary_dir}/${_idl_cmd_arg_-o}")
  endif()

  if ("${_idl_cmd_arg_-oS}" STREQUAL "")
    set(_skel_output_dir ${_output_dir})
  else()
    set(_skel_output_dir "${_working_binary_dir}/${_idl_cmd_arg_-oS}")
  endif()

  if ("${_idl_cmd_arg_-oA}" STREQUAL "")
    set(_anyop_output_dir ${_output_dir})
  else()
    set(_anyop_output_dir "${_working_binary_dir}/${_idl_cmd_arg_-oA}")
  endif()

  foreach(idl_file ${_arg_IDL_FILES})

    get_filename_component(idl_file_base ${idl_file} NAME_WE)
    set(_STUB_HEADER_FILES)
    set(_SKEL_HEADER_FILES)

    if (NOT _idl_cmd_arg_-Sch)
      set(_STUB_HEADER_FILES "${_output_dir}/${idl_file_base}C.h")
    endif()

    if (NOT _idl_cmd_arg_-Sci)
      list(APPEND _STUB_HEADER_FILES "${_output_dir}/${idl_file_base}C.inl")
    endif()

    if (NOT _idl_cmd_arg_-Scc)
      set(_STUB_CPP_FILES "${_output_dir}/${idl_file_base}C.cpp")
    endif()

    if (NOT _idl_cmd_arg_-Ssh)
      set(_SKEL_HEADER_FILES "${_skel_output_dir}/${idl_file_base}S.h")
    endif()

    if (NOT _idl_cmd_arg_-SS)
      set(_SKEL_CPP_FILES "${_skel_output_dir}/${idl_file_base}S.cpp")
    endif()

    if (_idl_cmd_arg_-GA)
      set(_ANYOP_HEADER_FILES "${_anyop_output_dir}/${idl_file_base}A.h")
      set(_ANYOP_CPP_FILES "${_anyop_output_dir}/${idl_file_base}A.cpp")
    elseif (_idl_cmd_arg_-GX)
      set(_ANYOP_HEADER_FILES "${_anyop_output_dir}/${idl_file_base}A.h")
    endif()

    if (_idl_cmd_arg_-GT)
      list(APPEND ${idl_file_base}_SKEL_HEADER_FILES
        "${_skel_output_dir}/${idl_file_base}S_T.h"
        "${_skel_output_dir}/${idl_file_base}S_T.cpp")
    endif()

    if (_idl_cmd_arg_-Gxhst)
      list(APPEND _STUB_HEADER_FILES ${CMAKE_CURRENT_BINARY_DIR}/${idl_cmd_arg-wb-stub_export_file})
    endif()

    if (_idl_cmd_arg_-Gxhsk)
      list(APPEND _SKEL_HEADER_FILES ${CMAKE_CURRENT_BINARY_DIR}/${idl_cmd_arg-wb-skel_export_file})
    endif()


    set(_OUTPUT_FILES ${_STUB_HEADER_FILES}
                      ${_SKEL_HEADER_FILES}
                      ${_ANYOP_HEADER_FILES})


    if (NOT exclude_cpps_from_command_output)
    ## This is the general case where we are not using Visual Studio generator
    ## or this command is only used by one target. Directly setting the
    ## generated cpp files as the OUTPUT of add_custom_command() is fine.
      list(APPEND _OUTPUT_FILES
                  ${_STUB_CPP_FILES}
                  ${_SKEL_CPP_FILES}
                  ${_ANYOP_CPP_FILES}
      )
    else()
      ## For the special case of using Visual Studio generator and outputs are used
      ## by multiple targets, we cannot list the generated cpp files as the OUTPUT
      ## add_custom_command() because it would cause the IDL generation comand
      ## triggered by all dependent targets and executed multiple times.
    endif()

    get_filename_component(idl_file_path "${idl_file}" ABSOLUTE)

    set(GPERF_LOCATION $<TARGET_FILE:ace_gperf>)
    if(CMAKE_CONFIGURATION_TYPES)
      get_target_property(is_gperf_imported ace_gperf IMPORTED)
      if (is_gperf_imported)
        set(GPERF_LOCATION $<TARGET_PROPERTY:ace_gperf,LOCATION>)
      endif(is_gperf_imported)
    endif(CMAKE_CONFIGURATION_TYPES)

    if (BUILD_SHARED_LIB AND TARGET TAO_IDL_BE)
      set(tao_idl_shared_libs TAO_IDL_BE TAO_IDL_FE)
    endif()

    add_custom_command(
      OUTPUT ${_OUTPUT_FILES}
      DEPENDS TAO_IDL_EXE ${tao_idl_shared_libs} ace_gperf
      MAIN_DEPENDENCY ${idl_file}
      COMMAND TAO_IDL_EXE -g ${GPERF_LOCATION} ${TAO_CORBA_IDL_FLAGS} -Sg -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I${TAO_INCLUDE_DIR} -I${_working_source_dir} ${_converted_flags} ${idl_file_path}
      WORKING_DIRECTORY ${_arg_WORKING_DIRECTORY}
      VERBATIM
    )

    list(APPEND ${name}_STUB_CPP_FILES ${_STUB_CPP_FILES})
    list(APPEND ${name}_STUB_HEADER_FILES ${_STUB_HEADER_FILES})
    list(APPEND ${name}_SKEL_CPP_FILES ${_SKEL_CPP_FILES})
    list(APPEND ${name}_SKEL_HEADER_FILES ${_SKEL_HEADER_FILES})
    list(APPEND ${name}_ANYOP_CPP_FILES ${_ANYOP_CPP_FILES})
    list(APPEND ${name}_ANYOP_HEADER_FILES ${_ANYOP_HEADER_FILES})
  endforeach()

  set(${name}_STUB_CPP_FILES ${${name}_STUB_CPP_FILES} PARENT_SCOPE)
  set(${name}_STUB_HEADER_FILES ${${name}_STUB_HEADER_FILES} PARENT_SCOPE)
  set(${name}_STUB_FILES ${${name}_STUB_CPP_FILES} ${${name}_STUB_HEADER_FILES})
  set(${name}_STUB_FILES ${${name}_STUB_FILES} PARENT_SCOPE)

  set(${name}_SKEL_CPP_FILES ${${name}_SKEL_CPP_FILES} PARENT_SCOPE)
  set(${name}_SKEL_HEADER_FILES ${${name}_SKEL_HEADER_FILES} PARENT_SCOPE)
  set(${name}_SKEL_FILES ${${name}_SKEL_CPP_FILES} ${${name}_SKEL_HEADER_FILES})
  set(${name}_SKEL_FILES ${${name}_SKEL_FILES} PARENT_SCOPE)

  set(${name}_ANYOP_CPP_FILES ${${name}_ANYOP_CPP_FILES} PARENT_SCOPE)
  set(${name}_ANYOP_HEADER_FILES ${${name}_ANYOP_HEADER_FILES} PARENT_SCOPE)
  set(${name}_ANYOP_FILES ${${name}_ANYOP_CPP_FILES} ${${name}_ANYOP_HEADER_FILES})
  set(${name}_ANYOP_FILES ${${name}_ANYOP_FILES} PARENT_SCOPE)

  set(${name}_HEADER_FILES ${${name}_STUB_HEADER_FILES} ${${name}_SKEL_HEADER_FILES} ${${name}_ANYOP_HEADER_FILES})
  set(${name}_HEADER_FILES ${${name}_HEADER_FILES} PARENT_SCOPE)
  set(${name}_CPP_FILES ${${name}_STUB_CPP_FILES} ${${name}_SKEL_CPP_FILES} ${${name}_ANYOP_CPP_FILES})
  set(${name}_CPP_FILES ${${name}_CPP_FILES} PARENT_SCOPE)
  set(${name}_OUTPUT_FILES ${${name}_HEADER_FILES} ${${name}_CPP_FILES})
  set(${name}_OUTPUT_FILES ${${name}_OUTPUT_FILES} PARENT_SCOPE)
endfunction(tao_idl_command name)

macro(tao_filter_valid_targets)
  foreach(__target_list ${ARGN})
    set(__source_list ${${__target_list}})
    set(${__target_list})
    foreach(t ${__source_list})
      if (TARGET ${t})
        list(APPEND ${__target_list} ${t})
      endif()
    endforeach()
  endforeach(__target_list ${ARGN})
endmacro()


function(tao_idl_sources)
  set(multiValueArgs TARGETS STUB_TARGETS SKEL_TARGETS ANYOP_TARGETS IDL_FLAGS IDL_FILES WORKING_DIRECTORY)

  cmake_parse_arguments(_arg "" "${outValueArgs}" "${multiValueArgs}" ${ARGN})

  #filter out invliad targets in each list
  tao_filter_valid_targets(_arg_TARGETS _arg_STUB_TARGETS _arg_SKEL_TARGETS _arg_ANYOP_TARGETS)

  set(all_targets ${_arg_TARGETS} ${_arg_STUB_TARGETS} ${_arg_SKEL_TARGETS} ${_arg_ANYOP_TARGETS})
  if (NOT all_targets)
    ## no valid target exists, just skip the rest
    return()
  endif()

  foreach(path ${_arg_IDL_FILES})
    if (IS_ABSOLUTE ${path})
      list(APPEND _result ${path})
    else()
      list(APPEND _result ${CMAKE_CURRENT_LIST_DIR}/${path})
    endif()
  endforeach()
  set(_arg_IDL_FILES ${_result})

  if (_arg_WORKING_DIRECTORY)
    if (IS_ABSOLUTE ${_arg_WORKING_DIRECTORY})
      message(FATAL_ERROR "WORKING_DIRECTORY for tao_idl_sources() must be relative path")
    else()
      set(rel_path ${_arg_WORKING_DIRECTORY})
    endif()
  else(_arg_WORKING_DIRECTORY)
    file(RELATIVE_PATH rel_path ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_LIST_DIR})
  endif(_arg_WORKING_DIRECTORY)

  tao_idl_command(_idls
    IDL_FLAGS ${_arg_IDL_FLAGS}
    IDL_FILES ${_arg_IDL_FILES}
    WORKING_DIRECTORY ${rel_path}
    USED_BY "${all_targets}"
  )

  foreach(target ${_arg_ANYOP_TARGETS})
    ace_target_sources("${target}" ${_idls_ANYOP_CPP_FILES})
  endforeach()

  foreach(target ${_arg_SKEL_TARGETS})
    ace_target_sources("${target}" ${_idls_SKEL_CPP_FILES})
  endforeach()

  foreach(target ${_arg_STUB_TARGETS})
    ace_target_sources("${target}" ${_idls_STUB_CPP_FILES})
  endforeach()

  foreach(target ${_arg_TARGETS})
    ace_target_sources("${target}" ${_idls_ANYOP_CPP_FILES} ${_idls_SKEL_CPP_FILES} ${_idls_STUB_CPP_FILES})
  endforeach()

  tao_setup_visual_studio_custom_command_fanout_dependencies(
    TARGETS "${all_targets}"
    DEPENDS "${_arg_IDL_FILES}"
    OUTPUT "${_idls_CPP_FILES}"
  )

  set(CMAKE_INCLUDE_CURRENT_DIR ON PARENT_SCOPE)

  set_source_files_properties(${_arg_IDL_FILES} ${_idls_SKEL_HEADER_FILES} PROPERTIES HEADER_FILE_ONLY ON)
  source_group("Generated Files" FILES ${_idls_OUTPUT_FILES})
  source_group("IDL Files" FILES ${_arg_IDL_FILES})

  foreach(target ${_arg_TARGETS} ${_arg_STUB_TARGETS} ${_arg_SKEL_TARGETS} ${_arg_ANYOP_TARGETS})
    if (TARGET ${target})
      list(APPEND packages ${PACKAGE_OF_${target}})
    endif()
  endforeach()

  if (packages)
    list(REMOVE_DUPLICATES packages)
  endif()

  foreach (package ${packages})
    ## All files listed in _arg_IDL_FILES and _idls_HEADER_FILES are absolute paths.
    ## In addition, they can be either in the source tree or in the binary tree.
    ## We need to identify where they are and install them to the install tree based
    ## on their relative path to either source tree root or binary tree root.
    foreach(file ${_arg_IDL_FILES} ${_idls_HEADER_FILES})
      ## first we check if the file startswith ${CMAKE_CURRENT_BINARY_DIR}
      string(FIND ${file} ${CMAKE_CURRENT_BINARY_DIR} prefix_index)
      if (${prefix_index} EQUAL 0)
        ## the file is in the binary tree
        file(RELATIVE_PATH rel_path  ${${package}_BINARY_DIR} ${file})

      else()
        string(FIND ${file} ${CMAKE_CURRENT_SOURCE_DIR} prefix_index)
        if (${prefix_index} EQUAL 0)
          file(RELATIVE_PATH rel_path  ${${package}_SOURCE_DIR} ${file})
        else()
          ## the file is neither in the source nor the binary tree, treat it as an external file, don't install it.
          continue()
        endif()
      endif()

      get_filename_component(dest "${${package}_INSTALL_DIR}/${rel_path}" DIRECTORY)

      install(FILES ${file}
              DESTINATION ${dest}
              COMPONENT ${package}_devel)
    endforeach(file)
  endforeach(package)

endfunction()