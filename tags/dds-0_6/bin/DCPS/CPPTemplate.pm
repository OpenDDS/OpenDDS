#
# CPPTemplate.pm - template for generating CPP implementation files for
#                  DDS TypeSupport.  The following macros are
#                  substituted when generating the output file:
#
#   <%TYPE%>           - Type requiring support in DDS.
#   <%UPPERTYPE%>      - Uppercase version of <%TYPE%>
#   <%MODULE%>         - Module containing the type.
#   <%SCOPE%>          - Enclosing scope of type.
#   <%PCHINCLUDE%>     - Including a PreCompiled Header file.
#   <%NAMESPACESTART%> - Beginning of namespace.
#   <%NAMESPACEEND%>   - End of namespace.
#
package DCPS::CPPTemplate ;

use warnings ;
use strict ;

sub contents { return <<'!EOT'
// -*- C++ -*-
//
// $Id$

// Generated by dcsp_ts.pl

<%PCHINCLUDE%>
#include "dds/DCPS/debug.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/PublicationInstance.h"

#include "<%TYPE%>TypeSupportImpl.h"

<%NAMESPACESTART%>

// Implementation skeleton constructor
<%TYPE%>TypeSupportImpl::<%TYPE%>TypeSupportImpl (void)
{
}

// Implementation skeleton destructor
<%TYPE%>TypeSupportImpl::~<%TYPE%>TypeSupportImpl (void)
{
}

DDS::ReturnCode_t
<%TYPE%>TypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    ::DDS::DomainId_t domain = 0;
    domain = participant->get_domain_id();

    ::DDS::ReturnCode_t registered = 
      ::TAO::DCPS::Registered_Data_Types->register_type(domain,
                                                        type_name,
                                                        this);

    return registered;
}

::TAO::DCPS::DataWriterRemote_ptr
<%TYPE%>TypeSupportImpl::create_datawriter (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    <%TYPE%>DataWriterImpl* writer_impl;
    ACE_NEW_RETURN(writer_impl, 
                   <%TYPE%>DataWriterImpl(), 
                   ::TAO::DCPS::DataWriterRemote::_nil());


    ::TAO::DCPS::DataWriterRemote_ptr writer_obj 
        = ::TAO::DCPS::servant_to_reference<TAO::DCPS::DataWriterRemote, 
                                            <%TYPE%>DataWriterImpl, 
                                            TAO::DCPS::DataWriterRemote_ptr> 
              (writer_impl ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (::TAO::DCPS::DataWriterRemote::_nil());

    return writer_obj;
}

::TAO::DCPS::DataReaderRemote_ptr
<%TYPE%>TypeSupportImpl::create_datareader (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    <%TYPE%>DataReaderImpl* reader_impl;
    ACE_NEW_RETURN(reader_impl, 
                    <%TYPE%>DataReaderImpl(), 
                    ::TAO::DCPS::DataReaderRemote::_nil());


    ::TAO::DCPS::DataReaderRemote_ptr reader_obj 
        = ::TAO::DCPS::servant_to_reference<TAO::DCPS::DataReaderRemote, 
                                            <%TYPE%>DataReaderImpl, 
                                            TAO::DCPS::DataReaderRemote_ptr> 
              (reader_impl ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (::TAO::DCPS::DataReaderRemote::_nil());

    return reader_obj;
}

<%NAMESPACEEND%>

<%NAMESPACESTART%>

// Implementation skeleton constructor
<%TYPE%>DataWriterImpl::<%TYPE%>DataWriterImpl (void)
: marshaled_size_ (0),
  data_allocator_ (0),
  mb_allocator_ (0),
  db_allocator_ (0),
  db_lock_pool_(0)
{
}

// Implementation skeleton destructor
<%TYPE%>DataWriterImpl::~<%TYPE%>DataWriterImpl (void)
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

DDS::InstanceHandle_t
<%TYPE%>DataWriterImpl::_cxx_register (
    const ::<%SCOPE%><%TYPE%> & instance_data
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::DDS::Time_t source_timestamp 
    = ::TAO::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_w_timestamp (instance_data, 
                               ::TAO::DCPS::HANDLE_NIL,
                               source_timestamp
                               ACE_ENV_ARG_PARAMETER);
}

DDS::InstanceHandle_t 
<%TYPE%>DataWriterImpl::register_w_timestamp (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_UNUSED_ARG (handle);
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, 
                    guard, 
                    get_lock (), 
                    ::DDS::RETCODE_ERROR);
  ::DDS::InstanceHandle_t registered_handle; 
  ::DDS::ReturnCode_t ret 
    = this->get_or_create_instance_handle(registered_handle, 
                                          instance_data, 
                                          source_timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
      ACE_ERROR ((LM_ERROR, 
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("<%TYPE%>DataWriterImpl::register_w_timestamp, ")
                  ACE_TEXT("register failed error=%d.\n"),
                  ret));
  }

  return registered_handle;
}


DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::unregister (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t handle
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::DDS::Time_t source_timestamp 
    = ::TAO::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return unregister_w_timestamp (instance_data, 
                                 handle, 
                                 source_timestamp
                                 ACE_ENV_ARG_PARAMETER);
}  

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::unregister_w_timestamp (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, 
                    guard, 
                    get_lock (), 
                    ::DDS::RETCODE_ERROR);
  ::DDS::InstanceHandle_t registered_handle 
      = this->get_instance_handle(instance_data);

  if(registered_handle == ::TAO::DCPS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or 
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR, 
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("<%TYPE%>DataWriterImpl::unregister, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::TAO::DCPS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR, 
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("<%TYPE%>DataWriterImpl::unregister, ")
                        ACE_TEXT("The given handle=%X is different from "
                        "registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }
  else
  {
    // DataWriterImpl::unregister will call back to inform the <%TYPE%>DataWriter
    // that the instance handle is removed from there and hence <%TYPE%>DataWriter
    // can remove the instance here.
    return DataWriterImpl::unregister(handle, source_timestamp);
  }
}

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::write (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t handle
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::DDS::Time_t source_timestamp 
    = ::TAO::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data, 
                            handle, 
                            source_timestamp
                            ACE_ENV_ARG_PARAMETER);
}

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::write_w_timestamp (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.
  
  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, 
                    guard, 
                    get_lock (), 
                    ::DDS::RETCODE_ERROR);
    
  ACE_Message_Block* marshalled = 0;

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL; 
    ::DDS::ReturnCode_t ret 
      = this->get_or_create_instance_handle(registered_handle, 
                                            instance_data, 
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR ((LM_ERROR, 
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("<%TYPE%>DataWriterImpl::write, ")
                  ACE_TEXT("register failed err=%d.\n"),
                  ret));
    }
   
    handle = registered_handle; 
  }
  
  marshalled = marshal (instance_data); // FOR_WRITE - using cached allocators
  return DataWriterImpl::write(marshalled, handle, source_timestamp);
}

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::dispose (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t instance_handle
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::DDS::Time_t source_timestamp 
    = ::TAO::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data, 
                              instance_handle, 
                              source_timestamp
                              ACE_ENV_ARG_PARAMETER);
}

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::dispose_w_timestamp (
    const ::<%SCOPE%><%TYPE%> & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, 
                    guard, 
                    get_lock (), 
                    ::DDS::RETCODE_ERROR);

  if(instance_handle == ::TAO::DCPS::HANDLE_NIL) 
  {
    instance_handle = this->get_instance_handle(instance_data);
    if (instance_handle == ::TAO::DCPS::HANDLE_NIL) 
    {
      ACE_ERROR_RETURN ((LM_ERROR, 
                          ACE_TEXT("(%P|%t) ")
                          ACE_TEXT("<%TYPE%>DataWriterImpl::dispose, ")
                          ACE_TEXT("The instance sample is not registered.\n")),
                          ::DDS::RETCODE_ERROR);
    }
  }
  
  return DataWriterImpl::dispose(instance_handle, source_timestamp);
}

DDS::ReturnCode_t
<%TYPE%>DataWriterImpl::get_key_value (
    ::<%SCOPE%><%TYPE%> & key_holder,
    ::DDS::InstanceHandle_t handle
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, 
                    guard, 
                    get_lock (), 
                    ::DDS::RETCODE_ERROR);
  InstanceMap::iterator it;
  for (it = instance_map_.begin (); 
        it != instance_map_.end ();
        it ++)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


void
<%TYPE%>DataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      TopicImpl                             *topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      TAO::DCPS::DomainParticipantImpl*      participant_servant,
      ::DDS::Publisher_ptr                   publisher,
      TAO::DCPS::PublisherImpl*              publisher_servant,
      TAO::DCPS::DataWriterRemote_ptr        dw_remote
      ACE_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ))
{
  DataWriterImpl::init (topic,
                        topic_servant,
                        qos,
                        a_listener,
                        participant_servant,
                        publisher,
                        publisher_servant,
                        dw_remote
                        ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  ::<%SCOPE%><%TYPE%> data;
  if (_tao_is_bounded_size (data))
  {
    marshaled_size_ = _dcps_max_marshaled_size (data);
  }
  else
  {
    marshaled_size_ =  0;// should use _dcps_find_size when marshaling
  }
}


::DDS::ReturnCode_t 
<%TYPE%>DataWriterImpl::enable_specific (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::<%SCOPE%><%TYPE%> data;
  if (_tao_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::TAO::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,"(%P|%t) <%TYPE%>DataWriterImpl::enable_specific-data"
          " Dynamic_Cached_Allocator_With_Overflow %x with %d chunks\n",
          data_allocator_, n_chunks_));
  }
  else
  {
    if (::TAO::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,"(%P|%t) <%TYPE%>DataWriterImpl::enable_specific"
          " is unbounded data - allocate from heap\n"));
  }
  
  mb_allocator_ = new ::TAO::DCPS::MessageBlockAllocator (n_chunks_);
  db_allocator_ = new ::TAO::DCPS::DataBlockAllocator (n_chunks_);
  
  if (::TAO::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,"(%P|%t) <%TYPE%>DataWriterImpl::enable_specific-mb"
          " Cached_Allocator_With_Overflow %x with %d chunks\n",
          mb_allocator_, n_chunks_));
      ACE_DEBUG((LM_DEBUG,"(%P|%t) <%TYPE%>DataWriterImpl::enable_specific-db"
          " Cached_Allocator_With_Overflow %x with %d chunks\n",
          db_allocator_, n_chunks_));
    }
    

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);
  
  return ::DDS::RETCODE_OK;
}

// Note: The <%TYPE%>DataWriter gives ownership of the marshalled data 
//       to the WriteDataContainer.
ACE_Message_Block*
 <%TYPE%>DataWriterImpl::marshal(
                const ::<%SCOPE%><%TYPE%>& instance_data,
                int  for_write)
{
  ACE_Message_Block* mb;
  if (for_write)
  {
    ACE_NEW_MALLOC_RETURN (mb,
                           static_cast<ACE_Message_Block*> (
                               mb_allocator_->malloc (
                               sizeof (ACE_Message_Block))),
                           ACE_Message_Block( 
                               marshaled_size_ ? marshaled_size_ : 
                                           _dcps_find_size(instance_data),
                               ACE_Message_Block::MB_DATA,
                               0, //cont
                               0, //data
                               data_allocator_, //allocator_strategy
                               db_lock_pool_->get_lock(), //data block locking_strategy
                               ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                               ACE_Time_Value::zero,
                               ACE_Time_Value::max_time,
                               db_allocator_,
                               mb_allocator_),
                            0);
  }
  else
  { // Don't use the cached allocator for the registered sample message
    // block.

    ACE_NEW_RETURN (mb,
                    ACE_Message_Block (sizeof (::<%SCOPE%><%TYPE%>)),
                    0);
  }
  
  ::TAO::DCPS::Serializer serializer (mb);
  serializer << instance_data;
  
  return mb;
}

::DDS::ReturnCode_t
 <%TYPE%>DataWriterImpl::get_or_create_instance_handle(
                DDS::InstanceHandle_t& handle,
                ::<%SCOPE%><%TYPE%> instance_data,
                const ::DDS::Time_t & source_timestamp) 
{
  handle = ::TAO::DCPS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  int is_new = 1;

  if (it != instance_map_.end()) 
  {
    handle = it->second;
    PublicationInstance* instance = reinterpret_cast<PublicationInstance*>(handle);
    if (instance->unregistered_ == false)
    { 
      is_new = 0;
    }
    // else: The instance is unregistered and now register again.
  }

  if (is_new) 
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* marshalled = this->marshal(instance_data, 0); //NOT_FOR_WRITE
    
    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership 
    // of the marshalled sample.
    if (ret == ::DDS::RETCODE_OK)
    {
      std::pair<InstanceMap::iterator, bool> pair 
          = instance_map_.insert(InstanceMap::value_type(instance_data, handle));
      if (pair.second == false)
        {
          ACE_ERROR_RETURN ((LM_ERROR, 
                              ACE_TEXT("(%P|%t) "
                              "<%TYPE%>DataWriterImpl::get_or_create_instance_handle, ")
                              ACE_TEXT("insert <%SCOPE%><%TYPE%> failed. \n")),
                              ::DDS::RETCODE_ERROR);
        }
    }
    else
    {
      marshalled->release ();
      return ret;
    }
  }

  return ::DDS::RETCODE_OK;
}

::DDS::InstanceHandle_t 
 <%TYPE%>DataWriterImpl::get_instance_handle(
                ::<%SCOPE%><%TYPE%> instance_data)
{
  InstanceMap::const_iterator it = instance_map_.find(instance_data);
 
  if (it == instance_map_.end()) 
  {
    return ::TAO::DCPS::HANDLE_NIL;
  }
  else 
  {
    return it->second;
  }
}


void
<%TYPE%>DataWriterImpl::unregistered(::DDS::InstanceHandle_t   instance_handle)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered 
  // will use the old handle.
  ACE_UNUSED_ARG (instance_handle);
}

<%NAMESPACEEND%>

<%NAMESPACESTART%>

// Implementation skeleton constructor
<%TYPE%>DataReaderImpl::<%TYPE%>DataReaderImpl (void)
{

}

void
<%TYPE%>DataReaderImpl::init (
        TopicImpl*                    a_topic,
        const ::DDS::DataReaderQos &  qos,
        ::DDS::DataReaderListener_ptr a_listener,
        DomainParticipantImpl*        participant,
        SubscriberImpl*               subscriber,
        ::DDS::Subscriber_ptr         subscriber_objref,
        DataReaderRemote_ptr          dr_remote_objref
        ACE_ENV_ARG_DECL
      )
        ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
  DataReaderImpl::init(a_topic,
                       qos,
                       a_listener,
                       participant,
                       subscriber,
                       subscriber_objref,
                       dr_remote_objref) ;
  ACE_CHECK;

}

::DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::enable_specific (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  data_allocator_ = new DataAllocator(get_n_chunks ()) ;
    if (::TAO::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,"<%TYPE%>DataReaderImpl::enable_specific-data"
          " Cached_Allocator_With_Overflow %x with %d chunks\n",
          data_allocator_, this->get_n_chunks () ));
          
  return ::DDS::RETCODE_OK;
}

// Implementation skeleton destructor
<%TYPE%>DataReaderImpl::~<%TYPE%>DataReaderImpl (void)
{
  InstanceMap::iterator it;
  for (it = instance_map_.begin ();
       it != instance_map_.end ();
       it ++)
    {
      ::DDS::InstanceHandle_t handle = it->second;
      SubscriptionInstance *ptr =
          reinterpret_cast<SubscriptionInstance *> (handle) ;

      while (ptr->rcvd_sample_.size_)
        {
          ReceivedDataElement *head_ptr = ptr->rcvd_sample_.head_ ;
            
          ptr->rcvd_sample_.remove(head_ptr) ;
          
         ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(head_ptr->registered_data_);
          ACE_DES_FREE (delete_ptr,
                        data_allocator_->free,
                        <%TYPE%> );
          ACE_DES_FREE (head_ptr,
                        rd_allocator_->free,
                        ReceivedDataElement);
        }

      delete ptr ;
    }

  delete data_allocator_ ;
  //X SHH release the data samples in the instance_map_.
}


DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::delete_contained_entities (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->delete_contained_entities() ;
}


// ::<%MODULE%> <%MODULE%>
DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::read (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((received_data.maximum() != info_seq.maximum()) ||
      (received_data.length() != info_seq.length()) ||
      (received_data.release() != info_seq.release()))
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if ((received_data.maximum() > 0) && !received_data.release())
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if (received_data.maximum() == 0)
    {
      ::<%SCOPE%><%TYPE%> *buf;
      ::DDS::SampleInfo *info;
      buf = new ::<%SCOPE%><%TYPE%>[max_samples];
      info = new ::DDS::SampleInfo[max_samples];

      received_data.replace(max_samples, max_samples, buf, 0);
      info_seq.replace(max_samples, max_samples, info, 0);
    }
  else if ((::CORBA::Long)received_data.maximum() < max_samples)
  {
    max_samples = (::CORBA::Long)received_data.maximum();
  }
  
  ::CORBA::Long count(0);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  for (it = instance_map_.begin ();
       it != instance_map_.end ();
       it ++)
  {
    ::CORBA::Long start_samples_in_instance(count) ;
    ::CORBA::Long samples_in_instance_count(0) ;
    ::DDS::InstanceHandle_t handle = it->second;
    SubscriptionInstance *ptr = reinterpret_cast<SubscriptionInstance *> (handle) ;

    if ((ptr->instance_state_.view_state() & view_states) &&
        (ptr->instance_state_.instance_state() & instance_states))
    {
      for (ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
           item != 0 ; item = item->next_data_sample_)
      {
        if (item->sample_state_ & sample_states)
        {
          received_data[count] =
              *((::<%SCOPE%><%TYPE%> *)item->registered_data_) ;
          ptr->instance_state_.sample_info(info_seq[count], item) ;
      
          item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;

          ptr->instance_state_.accessed() ;
          count++ ;
          samples_in_instance_count++ ;
        }
        if (count == max_samples)
        {
          break ;
        }
      }
    }

    if (samples_in_instance_count)
    {
      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      sample_info(info_seq, start_samples_in_instance,
                  samples_in_instance_count,
                  ptr->rcvd_sample_.tail_) ;
    }

    if (count == max_samples)
    {
      break ;
    }
  }
  if (count)
  {  
    received_data.length(count) ;
    info_seq.length(count) ;

    return ::DDS::RETCODE_OK;
  }
  else
  {
    return ::DDS::RETCODE_NO_DATA ;
  }
}

DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::read (
    ::<%MODULE%><%TYPE%>PtrVec & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((::CORBA::Long)info_seq.maximum() < max_samples)
    {
      max_samples = (::CORBA::Long)info_seq.maximum();
    }
  
  ::CORBA::Long count(0);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  for (it = instance_map_.begin ();
       it != instance_map_.end ();
       it ++)
  {
    ::CORBA::Long start_samples_in_instance(count) ;
    ::CORBA::Long samples_in_instance_count(0) ;
    ::DDS::InstanceHandle_t handle = it->second;
    SubscriptionInstance *ptr = reinterpret_cast<SubscriptionInstance *> (handle) ;

    if ((ptr->instance_state_.view_state() & view_states) &&
        (ptr->instance_state_.instance_state() & instance_states))
    {
      for (ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
           item != 0 ; item = item->next_data_sample_)
      {
        if (item->sample_state_ & sample_states)
        {
          received_data[count] =
              (::<%SCOPE%><%TYPE%> *)item->registered_data_ ;
          ptr->instance_state_.sample_info(info_seq[count], item) ;
      
          item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;
          item->zero_copy_flg_ = true ;

          ptr->instance_state_.accessed() ;
          count++ ;
          samples_in_instance_count++ ;
        }
        if (count == max_samples)
        {
          break ;
        }
      }
    }

    if (samples_in_instance_count)
    {
      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      sample_info(info_seq, start_samples_in_instance,
                  samples_in_instance_count,
                  ptr->rcvd_sample_.tail_) ;
    }

    if (count == max_samples)
    {
      break ;
    }
  }

  if (count)
  {  
    info_seq.length(count) ;
    return ::DDS::RETCODE_OK;
  }
  else
  {
    return ::DDS::RETCODE_NO_DATA ;
  }
}

DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::take (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((received_data.maximum() != info_seq.maximum()) ||
      (received_data.length() != info_seq.length()) ||
      (received_data.release() != info_seq.release()))
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET ;
    }

  if ((received_data.maximum() > 0) && !received_data.release())
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if (received_data.maximum() == 0)
    {
      ::<%SCOPE%><%TYPE%> *buf;
      ::DDS::SampleInfo *info;
      buf = new ::<%SCOPE%><%TYPE%>[max_samples];
      info = new ::DDS::SampleInfo[max_samples];

      received_data.replace(max_samples, max_samples, buf, 0);
    }
  else if ((::CORBA::Long)received_data.maximum() < max_samples)
    {
      max_samples = (::CORBA::Long)received_data.maximum() ;
    }
  
  ::CORBA::Long count(0) ;
   
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  for (it = instance_map_.begin ();
       it != instance_map_.end ();
       it ++)
    {
      ::CORBA::Long start_samples_in_instance(count) ;
      ::CORBA::Long samples_in_instance_count(0) ;
      ::DDS::InstanceHandle_t handle = it->second;
      SubscriptionInstance *ptr = reinterpret_cast<SubscriptionInstance *> (handle) ;

      ReceivedDataElement *tail = 0 ;
      if ((ptr->instance_state_.view_state() & view_states) &&
          (ptr->instance_state_.instance_state() & instance_states))
      {
        ReceivedDataElement *next ;
        tail = 0 ;
        ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
        while (item)
        {
          if (item->sample_state_ & sample_states)
            {
              received_data[count] =
                  *((::<%SCOPE%><%TYPE%> *)item->registered_data_) ;
              ptr->instance_state_.sample_info(info_seq[count], item) ;
      
              item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;

              ptr->instance_state_.accessed() ;

              if (item == ptr->rcvd_sample_.tail_)
                {
                  tail = ptr->rcvd_sample_.tail_ ;
                  item = item->next_data_sample_ ;
                }
              else
                {
                  next = item->next_data_sample_ ;

                  ptr->rcvd_sample_.remove(item) ;

                 ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(item->registered_data_);
                  ACE_DES_FREE (delete_ptr,
                                data_allocator_->free,
                                <%TYPE%> );
                  ACE_DES_FREE (item,
                                rd_allocator_->free,
                                ReceivedDataElement);         
                  item = next ;
                }

              samples_in_instance_count++ ;
              count++ ;
            }
          if (count == max_samples)
            {
              break ;
            }
        }
      }

    if (samples_in_instance_count)
      {
        //
        // Get the sample_ranks, generation_ranks, and
        // absolute_generation_ranks for this info_seq
        //
        if (tail)
          {
            sample_info(info_seq, start_samples_in_instance,
                        samples_in_instance_count,
                        tail) ;
            
            ptr->rcvd_sample_.remove(tail) ;

            ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(tail->registered_data_);
            ACE_DES_FREE (delete_ptr,
                          data_allocator_->free,
                          <%TYPE%> );
            ACE_DES_FREE (tail,
                          rd_allocator_->free,
                          ReceivedDataElement);         
          }
        else
          {
            sample_info(info_seq, start_samples_in_instance,
                        samples_in_instance_count,
                        ptr->rcvd_sample_.tail_) ;
          }
        }
      if (count == max_samples)
        {
          break ;
        }
    }

  if (count)
    { 
      received_data.length(count) ;
      info_seq.length(count) ;
      return ::DDS::RETCODE_OK;
    }
    else
    {
      return ::DDS::RETCODE_NO_DATA ;
    }
}

DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::take (
    ::<%MODULE%><%TYPE%>PtrVec & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((::CORBA::Long)info_seq.maximum() < max_samples)
    {
      max_samples = (::CORBA::Long)info_seq.maximum();
    }
  
  ::CORBA::Long count(0);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  for (it = instance_map_.begin ();
       it != instance_map_.end ();
       it ++)
  {
    ::CORBA::Long start_samples_in_instance(count) ;
    ::CORBA::Long samples_in_instance_count(0) ;
    ::DDS::InstanceHandle_t handle = it->second;
    SubscriptionInstance *ptr = reinterpret_cast<SubscriptionInstance *> (handle) ;

    if ((ptr->instance_state_.view_state() & view_states) &&
        (ptr->instance_state_.instance_state() & instance_states))
    {
      for (ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
           item != 0 ; item = item->next_data_sample_)
      {
        if (item->sample_state_ & sample_states)
        {
/*
 *        TBD - We need a way to give up ownership of item->registered_data_
 *        if we've used the cached allocator
 */
          received_data[count] =
              (::<%SCOPE%><%TYPE%> *)item->registered_data_ ;
          ptr->instance_state_.sample_info(info_seq[count], item) ;
      
          item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;
          item->zero_copy_flg_ = true ;

          ptr->instance_state_.accessed() ;
          count++ ;
          samples_in_instance_count++ ;
        }
        if (count == max_samples)
        {
          break ;
        }
      }
    }

    if (samples_in_instance_count)
    {
      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      sample_info(info_seq, start_samples_in_instance,
                  samples_in_instance_count,
                  ptr->rcvd_sample_.tail_) ;
    }

    if (count == max_samples)
    {
      break ;
    }
  }

  if (count)
  {  
    info_seq.length(count) ;
    return ::DDS::RETCODE_OK;
  }
  else
  {
    return ::DDS::RETCODE_NO_DATA ;
  }
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::read_next_sample (
    ::<%SCOPE%><%TYPE%> & received_data,
    ::DDS::SampleInfo & sample_info
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
#ifdef PUBLISHER_TEST
  ACE_UNUSED_ARG (received_data);
  ACE_UNUSED_ARG (sample_info);

  FILE* fp =
    ACE_OS::fopen ("<%TYPE%>.txt", ACE_LIB_TEXT("r"));
  if (fp == 0)
  {
    ACE_ERROR_RETURN ((LM_ERROR, 
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("<%TYPE%>DataReaderImpl::read_next_sample, ")
                        ACE_TEXT("Unable to open <%TYPE%>.txt for reading: %p\n"),
                        "fopen"),
                        ::DDS::RETCODE_ERROR);
  }

  if( ACE_OS::fsetpos( fp, &pos_ ) != 0 )
  {
    ACE_ERROR_RETURN ((LM_ERROR, 
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("<%TYPE%>DataReaderImpl::read_next_sample, ")
                        ACE_TEXT("Unable to open <%TYPE%>.txt for reading: %p\n"),
                        "fsetpos"),
                        ::DDS::RETCODE_ERROR);
  }

  fscanf (fp, "%d %d %d %d\n", &received_data.a_long_value, 
                            &received_data.handle_value, 
                            &received_data.sample_sequence,
                            &received_data.writer_id);
  fgetpos( fp, &pos_ );
  ACE_OS::fclose (fp);

  return ::DDS::RETCODE_OK;

#else

  ::<%MODULE%><%TYPE%>Seq received_data_seq(1) ;
  ::DDS::SampleInfoSeq info_seq(1) ;
  
  DDS::ReturnCode_t status ;
  status = this->read(received_data_seq, info_seq,
                    1,
                    ::DDS::NOT_READ_SAMPLE_STATE,
                    ::DDS::ANY_VIEW_STATE,
                    ::DDS::ANY_INSTANCE_STATE) ;

  if (status != ::DDS::RETCODE_OK)
  {
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      ACE_ERROR ((LM_ERROR,
                 ACE_TEXT("(%P|%t) ")
                 ACE_TEXT("<%TYPE%>DataReaderImpl::read_next_sample ")
                 ACE_TEXT("failed,  error=%d.\n"),
                 status));
    }
  }
  else
  {
    received_data = received_data_seq[0] ;
    sample_info = info_seq[0] ;
  }

  return status ;
#endif
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::take_next_sample (
    ::<%SCOPE%><%TYPE%> & received_data,
    ::DDS::SampleInfo & sample_info
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::<%MODULE%><%TYPE%>Seq received_data_seq(1) ;
  ::DDS::SampleInfoSeq info_seq(1) ;
  
  DDS::ReturnCode_t status ;
  status = this->take(received_data_seq, info_seq,
                    1,
                    ::DDS::NOT_READ_SAMPLE_STATE,
                    ::DDS::ANY_VIEW_STATE,
                    ::DDS::ANY_INSTANCE_STATE) ;

  if (status != ::DDS::RETCODE_OK)
  {
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      ACE_ERROR ((LM_ERROR,
               ACE_TEXT("(%P|%t) ")
               ACE_TEXT("<%TYPE%>DataReaderImpl::read_next_sample ")
               ACE_TEXT("faile,  error=%d.\n"),
               status));
    }
  }
  else
  {
    received_data = received_data_seq[0] ;
    sample_info = info_seq[0] ;
  }

  return status ;
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::read_instance (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((received_data.maximum() != info_seq.maximum()) ||
      (received_data.length() != info_seq.length()) ||
      (received_data.release() != info_seq.release()))
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET ;
    }

  if ((received_data.maximum() > 0) && !received_data.release())
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if (received_data.maximum() == 0)
    {
      ::<%SCOPE%><%TYPE%> *buf;
      ::DDS::SampleInfo *info;
      buf = new ::<%SCOPE%><%TYPE%>[max_samples];
      info = new ::DDS::SampleInfo[max_samples];

      received_data.replace(max_samples, max_samples, buf, 0);
      info_seq.replace(max_samples, max_samples, info, 0);
    }
  else if ((::CORBA::Long)received_data.maximum() < max_samples)
  {
    max_samples = (::CORBA::Long)received_data.maximum() ;
  }
  
  ::CORBA::Long count(0) ;
   
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  SubscriptionInstance * ptr = 
      reinterpret_cast<SubscriptionInstance *> (a_handle) ;

  if ((ptr->instance_state_.view_state() & view_states) &&
      (ptr->instance_state_.instance_state() & instance_states))
  {
    for (ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
         item != 0 ; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states)
      {
        received_data[count] =
            *((::<%SCOPE%><%TYPE%> *)item->registered_data_) ;
        ptr->instance_state_.sample_info(info_seq[count], item) ;
    
        item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;

        ptr->instance_state_.accessed() ;
        count++ ;
      }
      
      if (count == max_samples)
      {
        break ;
      }
    }
  }

  if (count)
  {  
    //
    // Get the sample_ranks, generation_ranks, and
    // absolute_generation_ranks for this info_seq
    //
    sample_info(info_seq, 0, count, ptr->rcvd_sample_.tail_) ;
      
    received_data.length(count) ;
    info_seq.length(count) ;

    return ::DDS::RETCODE_OK;
  }
  else
  {
    return ::DDS::RETCODE_NO_DATA ;
  }
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::take_instance (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if ((received_data.maximum() != info_seq.maximum()) ||
      (received_data.length() != info_seq.length()) ||
      (received_data.release() != info_seq.release()))
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET ;
    }

  if ((received_data.maximum() > 0) && !received_data.release())
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if (received_data.maximum() == 0)
    {
      ::<%SCOPE%><%TYPE%> *buf;
      ::DDS::SampleInfo *info;
      buf = new ::<%SCOPE%><%TYPE%>[max_samples];
      info = new ::DDS::SampleInfo[max_samples];

      received_data.replace(max_samples, max_samples, buf, 0);
      info_seq.replace(max_samples, max_samples, info, 0);
    }
  else if ((::CORBA::Long)received_data.maximum() < max_samples)
    {
      max_samples = (::CORBA::Long)received_data.maximum() ;
    }
  
  ::CORBA::Long count(0) ;
   
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  SubscriptionInstance * ptr = 
    reinterpret_cast<SubscriptionInstance *> (a_handle) ;

  ReceivedDataElement *tail = 0 ;
  if ((ptr->instance_state_.view_state() & view_states) &&
      (ptr->instance_state_.instance_state() & instance_states))
  {
    ReceivedDataElement *next ;
    ReceivedDataElement *item = ptr->rcvd_sample_.head_ ;
    while (item)
    {
      if (item->sample_state_ & sample_states)
      {
        received_data[count] =
            *((::<%SCOPE%><%TYPE%> *)item->registered_data_) ;
        ptr->instance_state_.sample_info(info_seq[count], item) ;
    
        item->sample_state_ = ::DDS::READ_SAMPLE_STATE ;

        ptr->instance_state_.accessed() ;

        if (item == ptr->rcvd_sample_.tail_)
        {
          tail = ptr->rcvd_sample_.tail_ ;
          item = item->next_data_sample_ ;
        }
        else
        {
          next = item->next_data_sample_ ;

          ptr->rcvd_sample_.remove(item) ;

          ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(item->registered_data_);
          ACE_DES_FREE (delete_ptr,
                        data_allocator_->free,
                        <%TYPE%> );
          ACE_DES_FREE (item,
                        rd_allocator_->free,
                        ReceivedDataElement);

          item = next ;
        }
        count++ ;
      }
      
      if (count == max_samples)
      {
        break ;
      }
    }
  }

  if (count)
  {  
    //
    // Get the sample_ranks, generation_ranks, and
    // absolute_generation_ranks for this info_seq
    //
    if (tail)
    {
      sample_info(info_seq, 0,
                  count,
                  tail) ;
            
      ptr->rcvd_sample_.remove(tail) ;

      ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(tail->registered_data_);
      ACE_DES_FREE (delete_ptr,
                    data_allocator_->free,
                    <%TYPE%> );
      ACE_DES_FREE (tail,
                    rd_allocator_->free,
                    ReceivedDataElement);
    }
    else
    {
      sample_info(info_seq, 0,
                  count,
                  ptr->rcvd_sample_.tail_) ;
    }
      
    received_data.length(count) ;
    info_seq.length(count) ;

    return ::DDS::RETCODE_OK;
  }
  else
  {
    return ::DDS::RETCODE_NO_DATA ;
  }
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::read_next_instance (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ::DDS::InstanceHandle_t handle(::TAO::DCPS::HANDLE_NIL) ;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  if (a_handle == ::TAO::DCPS::HANDLE_NIL)
  {
    it = instance_map_.begin () ;
  }
  else
  {
    for (it = instance_map_.begin () ; it != instance_map_.end ();
            it ++)
    {
      if (a_handle == it->second)
      {
        it++ ;
        break ;
      }
    }
  }

  DDS::ReturnCode_t status ;

  for (; it != instance_map_.end () ; it++)
  {
    handle = it->second ;
    status = read_instance(received_data, info_seq, max_samples,
                           handle, sample_states, view_states,
                           instance_states) ;
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      return status ;
    }
  }
    
  return ::DDS::RETCODE_NO_DATA ;
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::take_next_instance (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
 ::DDS::InstanceHandle_t handle(::TAO::DCPS::HANDLE_NIL) ;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  if (a_handle == ::TAO::DCPS::HANDLE_NIL)
  {
    it = instance_map_.begin () ;
  }
  else
  {
    for (it = instance_map_.begin () ; it != instance_map_.end ();
            it ++)
    {
      if (a_handle == it->second)
      {
        it++ ;
        break ;
      }
    }
  }

  DDS::ReturnCode_t status ;

  for (; it != instance_map_.end () ; it++)
  {
    handle = it->second ;
    status = take_instance(received_data, info_seq, max_samples,
                           handle, sample_states, view_states,
                           instance_states) ;
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples() ;  // see if we are empty
      return status ;
    }
  }
    
  return ::DDS::RETCODE_NO_DATA ;
}

DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::return_loan (
    ::<%MODULE%><%TYPE%>Seq & received_data,
    ::DDS::SampleInfoSeq & info_seq
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (received_data.release() != info_seq.release())
    {
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }

  if (!received_data.release())
  {
    ::<%SCOPE%><%TYPE%> *buf = received_data.get_buffer();
    ::DDS::SampleInfo *info = info_seq.get_buffer();

    delete[] buf;
    delete[] info;
  }
  
  return ::DDS::RETCODE_OK;
}

DDS::ReturnCode_t 
<%TYPE%>DataReaderImpl::get_key_value (
    ::<%SCOPE%><%TYPE%> & key_holder,
    ::DDS::InstanceHandle_t handle
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  
  InstanceMap::iterator it;
  for (it = instance_map_.begin (); 
        it != instance_map_.end ();
        it ++)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}

void
<%TYPE%>DataReaderImpl::demarshal(const ReceivedDataSample& sample)
{
  ::<%SCOPE%><%TYPE%> *data /* = new ::<%SCOPE%><%TYPE%>(instance_data) */ ;
  
  ACE_NEW_MALLOC_NORETURN (data,
                         static_cast< ::<%SCOPE%><%TYPE%> *> (
                         data_allocator_->malloc (
                              sizeof (::<%SCOPE%><%TYPE%>))),
                         ::<%SCOPE%><%TYPE%>) ;
 
  Serializer ser(sample.sample_, sample.header_.byte_order_) ;
  ser >> *data ;

  store_instance_data(data, sample.header_) ;
}

::DDS::ReturnCode_t
<%TYPE%>DataReaderImpl::store_instance_data(
    ::<%SCOPE%><%TYPE%> *instance_data,
    const TAO::DCPS::DataSampleHeader& header )
{
  DDS::InstanceHandle_t handle(::TAO::DCPS::HANDLE_NIL) ;

  //!!! caller should already have the sample_lock_

  InstanceMap::const_iterator it = instance_map_.find(*instance_data);

  if (it == instance_map_.end()) 
  {
    SubscriptionInstance* instance;
    ACE_NEW_RETURN (instance,
                    SubscriptionInstance(this),
                    ::DDS::RETCODE_ERROR);

    handle = (::DDS::InstanceHandle_t)instance;
    
    std::pair<SubscriptionInstances::iterator, bool> pair
        = instances_.insert(handle);

    if (pair.second == false)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) "
                        "<%TYPE%>DataReaderImpl::store_instance_data, ")
                        ACE_TEXT("insert handle failed. \n")),
                        ::DDS::RETCODE_ERROR);
      return ::DDS::RETCODE_ERROR;
    }

    std::pair<InstanceMap::iterator, bool> bpair
        = instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) "
                        "<%TYPE%>DataReaderImpl::store_instance_data, ")
                        ACE_TEXT("insert ::<%SCOPE%><%TYPE%> failed. \n")),
                        ::DDS::RETCODE_ERROR);
    }
  }
  else
  {
    handle = it->second;
  }

  if (header.message_id_ != INSTANCE_REGISTRATION)
  {
    SubscriptionInstance* instance_ptr = reinterpret_cast<SubscriptionInstance *> (handle) ;
    
    // TBD - we also need to reject for > RESOURCE_LIMITS.max_samples
    //       and RESOURCE_LIMITS.max_instances.
    if ((this->qos_.resource_limits.max_samples_per_instance != 
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_sample_.size_ >= 
        this->qos_.resource_limits.max_samples_per_instance))
    {
      if  (instance_ptr->rcvd_sample_.head_->sample_state_ 
            == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::POA_DDS::DataReaderListener* listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        sample_rejected_status_.last_reason =
            ::DDS::REJECTED_BY_INSTANCE_LIMIT ;
        sample_rejected_status_.total_count++ ;
        sample_rejected_status_.total_count_change++ ;
        sample_rejected_status_.last_instance_handle = handle ;

        if (listener != 0)
        {
          ::DDS::DataReader_var dr = get_dr_obj_ref();
          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      <%TYPE%> );

        return ::DDS::RETCODE_OK ; //OK?
       }
       else
       {
         // Discard the oldest previously-read sample
         ReceivedDataElement *item = instance_ptr->rcvd_sample_.head_;
         instance_ptr->rcvd_sample_.remove(item) ;
         
         ::<%SCOPE%><%TYPE%>* ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(item->registered_data_);
         ACE_DES_FREE (ptr,
                       data_allocator_->free,
                       <%TYPE%> );

         ACE_DES_FREE (item,
                       rd_allocator_->free,
                       ReceivedDataElement);
      }
    }
    
    ReceivedDataElement *ptr /* = new ReceivedDataElement(data) */ ;
    ACE_NEW_MALLOC_RETURN (ptr,
                           static_cast<ReceivedDataElement *> (
                           rd_allocator_->malloc (
                              sizeof (ReceivedDataElement))),
                           ReceivedDataElement(instance_data),
                           ::DDS::RETCODE_ERROR);

    instance_ptr->instance_state_.data_was_received() ;

    ptr->source_timestamp_.sec = header.source_timestamp_sec_ ;
    ptr->source_timestamp_.nanosec = header.source_timestamp_nanosec_ ;
    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count() ;
    ptr->no_writers_generation_count_ = 
        instance_ptr->instance_state_.no_writers_generation_count() ;

    ptr->sequence_ = header.sequence_ ;
    instance_ptr->last_sequence_ = header.sequence_ ;

    instance_ptr->rcvd_sample_.add(ptr) ;

    if (instance_ptr->rcvd_sample_.size_ > get_depth())
    {
      ReceivedDataElement *head_ptr =
        instance_ptr->rcvd_sample_.head_ ;
            
      instance_ptr->rcvd_sample_.remove(head_ptr) ;

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::POA_DDS::DataReaderListener* listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        sample_lost_status_.total_count++ ;
        sample_lost_status_.total_count_change++ ;

        if (listener)
        {
          ::DDS::DataReader_var dr = get_dr_obj_ref();
          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }
      }

      ::<%SCOPE%><%TYPE%>* delete_ptr = static_cast< ::<%SCOPE%><%TYPE%>* >(head_ptr->registered_data_);
      ACE_DES_FREE (delete_ptr,
                    data_allocator_->free,
                    <%TYPE%> );
      ACE_DES_FREE (head_ptr,
                    rd_allocator_->free,
                    ReceivedDataElement);
    }

    SubscriberImpl* sub = get_subscriber_servant () ;
    ::POA_DDS::SubscriberListener* sub_listener =
        sub->listener_for(::DDS::DATA_ON_READERS_STATUS) ;
    if (sub_listener != 0)
    {
      sub_listener->on_data_on_readers(get_subscriber()) ;
    }
    else
    {
      ::POA_DDS::DataReaderListener* listener
            = listener_for (::DDS::DATA_AVAILABLE_STATUS);
        
      if (listener != 0)
      {
        ::DDS::DataReader_var dr = get_dr_obj_ref();
        listener->on_data_available(dr.in ());
      }
    }
  }
  else
  {
    SubscriptionInstance *instance_ptr = 
         reinterpret_cast<SubscriptionInstance *> (handle) ;
    instance_ptr->instance_state_.lively(header.publication_id_) ;
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  <%TYPE%> );
  }

  return ::DDS::RETCODE_OK;
}

void 
<%TYPE%>DataReaderImpl::dispose(const ReceivedDataSample& sample)
{
  //!!! caller should already have the sample_lock_

  ::<%SCOPE%><%TYPE%> *data /* = new ::<%SCOPE%><%TYPE%>(instance_data) */ ;
  ACE_NEW_MALLOC_NORETURN (data,
                         static_cast< ::<%SCOPE%><%TYPE%> *> (
                         data_allocator_->malloc (
                              sizeof (::<%SCOPE%><%TYPE%>))),
                         ::<%SCOPE%><%TYPE%>) ;
 
  Serializer ser(sample.sample_, sample.header_.byte_order_) ;
  ser >> *data ;
  
  DDS::InstanceHandle_t handle(::TAO::DCPS::HANDLE_NIL) ;

  InstanceMap::const_iterator it = instance_map_.find(*data);

  if (it != instance_map_.end()) 
  {
    handle = it->second;
    SubscriptionInstance* instance_ptr = 
          reinterpret_cast<SubscriptionInstance *> (handle) ;
    instance_ptr->instance_state_.dispose_was_received() ;
  }
  else
  {
    ACE_ERROR((LM_ERROR, 
              ACE_TEXT("(%P|%t) ")
              ACE_TEXT("<%TYPE%>DataReaderImpl::disposed, ")
              ACE_TEXT("The instance is not registered.\n")));
  }
      
  ACE_DES_FREE (data,
                data_allocator_->free,
                <%TYPE%> );
}

//TAO::DCPS::DataReaderRemote_ptr
//<%TYPE%>DataReaderImpl::get_datareaderremote_obj_ref ()
//{
//  ::TAO::DCPS::DataReaderRemote_ptr reader_obj 
//      = ::TAO::DCPS::servant_to_reference<TAO::DCPS::DataReaderRemote, 
//                                          <%TYPE%>DataReaderImpl, 
//                                          TAO::DCPS::DataReaderRemote_ptr> 
//            (this ACE_ENV_ARG_PARAMETER);
//  ACE_CHECK_RETURN (::TAO::DCPS::DataReaderRemote::_nil());
//
//  // servant_to_reference does not duplicate when the object is already active
//  return TAO::DCPS::DataReaderRemote::_duplicate(reader_obj);
//}
<%NAMESPACEEND%>


!EOT

}

1;

