#! /usr/bin/perl
# -*- CPerl -*-
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
    & eval 'exec perl -S $0 $argv:q'
    if 0;

# configure script for OpenDDS
# Distributed under the OpenDDS License.
# See: http://www.opendds.org/license.html

use Getopt::Long;
use Dumpvalue;
use File::Spec;
use File::Basename;
use File::Copy;
require File::Temp;
use File::Temp ();
use FileHandle;
use Cwd;
use strict;
use warnings;

## Version of OCI's TAO to download
my $oci_tao_version = '2.2a';
## Version of DOC Group ACE/TAO to download, uses the ACE version number
my $doc_tao_version = '6.4.4';

# save args before Getopt modifies them
my @ARGS = @ARGV;

sub perlOS_to_host {
  return 'win32' if $^O eq 'MSWin32';
  return 'macosx' if $^O eq 'darwin';
  return $^O;
}

sub perlOS_to_java_platform {
  return 'win32' if $^O eq 'MSWin32';
  return $^O;
}

my %platforminfo =
  ('win32' => {
               'compilers' => ['cl'],
               'libpath' => 'PATH',
               'cl_versions' => {13 => 'vc71', 14 => 'vc8', 15 => 'vc9',
                                 16 => 'vc10', 17 => 'vc11', 18 => 'vc12',
                                 19 => 'vc14', 19.1 => 'vs2017'},
              },
   'macosx' => {
                'compilers' => ['g++'],
                'libpath' => 'DYLD_LIBRARY_PATH',
                'versions' => {5 => 'leopard', 6 => 'snowleopard', 7 => 'lion',
                               8 => 'mountainlion', 9 => 'mavericks',
                               10 => 'yosemite', 11 => 'elcapitan'},
               },
   'solaris' => {
                 'compilers' => ['CC', 'g++'],
                 'libpath' => 'LD_LIBRARY_PATH',
                 'aceplatform' => 'sunos5_$COMP', # $COMP = sunc++ or g++
                 'aceconfig' => 'sunos$UNAMER', # $UNAMER = `uname -r`
                },
   'linux' => {
               'compilers' => ['g++', 'clang', 'clang++'],
               'libpath' => 'LD_LIBRARY_PATH',
               'aceplatform' => 'linux_$NONSTDCOMP', # $NONSTDCOMP = clang
              },
   'linux-cross' => {
                     'libpath' => 'LD_LIBRARY_PATH',
                     'aceplatform' => 'linux',
                     'aceconfig' => 'linux',
                     'no_host' => 1,
                     'usage' => ['Use --target-compiler to specify the ' .
                                 'cross-compiler binary',
                                ],
                    },
   'freebsd' => {
                    'compilers' => ['clang++'],
                    'libpath' => 'LD_LIBRARY_PATH',
                },
   'lynxos-178' => {
                    'libpath' => 'LD_LIBRARY_PATH',
                    'no_host' => 1,
                    'aceplatform' => 'lynxos',
                    'compiler_root_env' => 'ENV_PREFIX',
                    'usage' => ['Set up the cross-compile using '.
                                'the script from LynxOS',
                               ],
                   },
   'vxworks' => {
                 'libpath' => 'LD_LIBRARY_PATH',
                 'no_host' => 1,
                 'usage' => ['Use the wrenv script before running configure',
                             'Specify the VSB with --macros=VSB_DIR=<dir>',
                            ],
                },
  );

sub targetUsage {
  print "Cross-compile targets: specify --target=TGT where TGT is one of:\n";
  for my $k (sort keys %platforminfo) {
    if ($platforminfo{$k}->{'no_host'}) {
      print "\t$k\n";
      if ($platforminfo{$k}->{'usage'}) {
        for my $line (@{$platforminfo{$k}->{'usage'}}) {
          print "\t\t$line\n";
        }
      }
    }
  }
  exit 1;
}

## arg processing and usage

my @specs = # Array of array-refs, each inner array is an option group which
            # has the format [Group Description, Opt1 Spec, Opt1 Description,
            # Opt2 Spec, Opt2 Description, ...]
  (
   ['Options controlling the configure script:',
    'help|h|?', 'Show this help and exit',
    'target-help', 'Show details of cross-compile target configs',
    'verbose|v', 'Trace script execution',
    'dry-run|n', 'Don\'t do anything',
   ],
   ['Build platform and compiler:',
    'host=s', 'Host (auto detect: linux, win32, solaris, macosx)',
    'compiler=s', 'Compiler (auto detect / guess by searching PATH)',
    'std=s', 'C++ standard version (for compilers that use -std)',
    'target=s', 'Cross-compile target (none): see --target-help',
    'target-compiler=s', 'Compiler for target (if req\'d): see --target-help',
    'prefix=s', 'Installation prefix (none)',
   ],
   ['Build flags:',
    'debug!', 'Debugging (yes)',
    'optimize!', 'Optimization (no)',
    'inline!', 'Inlining (yes)',
    'static!', 'Static libraries (no)',
    'ipv6!', 'IPv6 support (no)',
   ],
   ['Required dependencies for OpenDDS:',
    'ace=s', 'ACE (use ACE_ROOT, ACE_wrappers, or download)',
    'tao=s', 'TAO (use TAO_ROOT, ACE_ROOT/TAO, or download)',
    'mpc=s', 'MPC (use MPC_ROOT, ACE_ROOT/MPC, or download)',
    'doc_group!', 'Use the DOC Group release of TAO',
   ],
   ['Advanced configuration:',
    'configh=s@', 'Extra text for config.h',
    'macros=s@', 'Extra text for platform_macros.GNU',
    'features=s@', 'Extra text for default.features',
    'mpcopts=s@', 'Extra command-line args for MPC (if MPC is run)',
   ],
   ['Optional dependencies for OpenDDS:',
    'java:s', 'Java development kit (use JAVA_HOME)',
    'jboss:s', 'JBoss application server (use JBOSS_HOME)',
    'ant:s', 'Ant for JBoss (use ANT_HOME or system pkg)',
    'wireshark:s', 'Wireshark (use WIRESHARK_SRC)',
    'glib:s', 'GLib for wireshark (use GLIB_ROOT or system pkg)',
    'rapidjson', 'RapidJSON for wireshark itl (optional)',
    'qt:s', 'Qt (use QTDIR or system pkg)',
    'qt-include:s', 'Qt include dir (use QT4_INCDIR or QTDIR/include)',
    'boost:s', 'Boost (use BOOST_ROOT or system pkg)',
    'boost-version:s', 'Boost version (only if needed to find headers)',
    'xerces3:s', 'Xerces-C++ 3 for QoS XML handling (optional)',
   ],
   ['Minimizing OpenDDS:',
    'built-in-topics!', 'Built-in Topics (yes)',
    'content-subscription!', 'Content-Subscription Profile (yes)',
    'content-filtered-topic!', 'ContentFilteredTopic (CS Profile) (yes)',
    'multi-topic!', 'MultiTopic (CS Profile) (yes)',
    'query-condition!', 'QueryCondition (CS Profile) (yes)',
    'ownership-profile!', 'Ownership Profile (yes)',
    'ownership-kind-exclusive!', 'Exclusive Ownership (Ownership Profile) (yes)',
    'object-model-profile!', 'Object Model Profile (yes)',
    'persistence-profile!', 'Persistence Profile (yes)',
    'safety-profile:s', 'Safety Profile: base or extended (none)',
    'tests!', 'Build tests, examples, and performance tests (yes)',
   ],
  );

sub iterate {
  my $callback = shift;
  for my $group (@specs) {
    for my $n (1 .. (scalar @{$group} / 2)) {
      my $opt = ${$group}[$n * 2 - 1];
      my $descr = ${$group}[$n * 2];
      my ($optkey) = ($opt =~ /([\w-]+)/);
      &$callback(${$group}[0], $opt, $descr, $optkey, @_);
    }
  }
}

sub usage {
  my $current;
  my $ver;
  open VER, 'dds/Version.h' or die "can't open dds/Version.h, stopped";
  while (<VER>) {
    $ver = $1 if /#define DDS_VERSION "([^"]+)"/;
  }
  close VER;
  print <<"EOT";
Welcome to OpenDDS version $ver

Options for this script are listed below, with the default behavior described
in parenthesis after the option description.
Boolean options can take the form "--opt" or "--no-opt", the more commonly
needed one (the one that changes the default behavior) is shown below.
Options that require arguments are shown as "--opt=VAL"  Options with optional
arguments are shown as "--opt[=VAL]".  Options that can be repeated with
cumulative effect are shown with a trailing "...".  Some third-party
optional dependencies can be automatically located if they are installed in the
expected locations (see entries below marked with "system pkg").  In those
cases, specify the option as --opt without an = to enable the corresponding
feature in OpenDDS and use the default installation location.
EOT
  iterate(sub {
            my ($group, $opt, $descr, $optkey) = @_;
            if (!defined $current || $group ne $current) {
              $current = $group;
              print "\n$group\n";
            }
            $optkey .= '=VAL' if $opt =~ /=s/;
            $optkey .= '[=VAL]' if $opt =~ /:s/;
            $optkey = "[no-]$optkey" if ($opt =~ /!$/ && $descr =~ / \(yes\)$/);
            $optkey .= '...' if $opt =~ /s\@$/;
            my $pad = 27 - length $optkey;
            print "--$optkey" . ' ' x (($pad > 0) ? $pad : 0) . " $descr\n";
          }
         );
  exit 1;
}

sub parseArgs {
  my @getopts = ();
  iterate(sub {
            my ($group, $opt, $descr, $optkey) = @_;
            push @getopts, $opt;
          }
         );

  if (! -r 'rules.dds.GNU') {
    print "ERROR: this script must be run from its own directory\n";
    exit 1;
  }

  my $opts = {};
  GetOptions($opts, @getopts) or usage();
  usage() if $opts->{'help'};
  targetUsage() if $opts->{'target-help'};

  if ($opts->{'verbose'}) {
    print "Options:\n";
    new Dumpvalue()->dumpValue($opts);
  }
  return $opts;
}

my $cross_compile = 0;
my %opts = %{parseArgs()};

$opts{'host'} = perlOS_to_host() unless $opts{'host'};

my ($slash, $exeext) = ($opts{'host'} eq 'win32') ? ('\\', '.exe') : ('/', '');

my %specific =
  ($slash eq '/' ?
   ('ext' => 'sh', 'export' => 'export', 'pathsep' => ':', 'refpre' => '${',
    'refpost' => '}', 'comment' => '#') :
   ('ext' => 'cmd', 'export' => 'set', 'pathsep' => ';', 'refpre' => '%',
    'refpost' => '%', 'comment' => '::')
  );

sub which {
  my $file = shift;
  for my $p (File::Spec->path()) {
    if (-x "$p/$file") {
      return "$p/$file";
    }
    elsif ($exeext ne '' && -x "$p/$file$exeext") {
      return "$p/$file$exeext";
    }
  }
  return undef;
}

sub addCurLibPathRef {
  my $buildEnvRef = shift;
  my $platform = $opts{$buildEnvRef->{'build'}};
  my $libpathname = $platforminfo{$platform}->{'libpath'};
  my $curLibPathRef = $specific{'refpre'} . $libpathname . $specific{'refpost'};
  $buildEnvRef->{$libpathname} = $curLibPathRef;
}

my $curpathRef = $specific{'refpre'} . 'PATH' . $specific{'refpost'};
my %hostEnv = ('build' => 'host', 'PATH' => $curpathRef);
my %targetEnv = ('build' => 'target', 'PATH' => $curpathRef);

my $would_download; # can dry-run assume directories that don't exist yet?

sub locate_mpc {
  my $ace_src = shift;
  if (defined $opts{'mpc'}) {
    setEnv('MPC_ROOT', $opts{'mpc'});
  }
  elsif (!$ENV{'MPC_ROOT'} && (-r $ace_src . '/MPC/MPC.ico'
                               || ($opts{'dry-run'} && $would_download))) {
    setEnv('MPC_ROOT', $ace_src . $slash . 'MPC');
  }
  elsif (!$ENV{'MPC_ROOT'}) {
    die "Can't find MPC.  Please set MPC_ROOT or make sure MPC exists in\n".
      "the 'MPC' directory under ACE_ROOT ($ace_src), stopped";
  }
  else {
    $targetEnv{'MPC_ROOT'} = $ENV{'MPC_ROOT'};
  }
  $hostEnv{'MPC_ROOT'} = $targetEnv{'MPC_ROOT'};
}

if (!exists $platforminfo{$opts{'host'}} ||
    $platforminfo{$opts{'host'}}->{'no_host'}) {
  die "ERROR: unknown host $opts{'host'}, stopped";
}
print "host system is: $opts{'host'}\n" if $opts{'verbose'};


$opts{'target'} = $opts{'host'} unless $opts{'target'};

if (!exists $platforminfo{$opts{'target'}}) {
  die "ERROR: unknown target $opts{'target'}, stopped";
}

# Set initial libpath
addCurLibPathRef(\%hostEnv);
addCurLibPathRef(\%targetEnv);


if (defined $opts{'safety-profile'} && $opts{'safety-profile'} eq '') {
  print "Defaulting safety profile to extended\n";
  $opts{'safety-profile'} = 'extended';
}

if ($opts{'host'} ne $opts{'target'} || $opts{'safety-profile'}) {
  print "Setting cross-compile build\n" if $opts{'verbose'};
  $cross_compile = 1;
}

if ($platforminfo{$opts{'target'}}->{'compiler_root_env'}) {
  # This target puts its cross-compiler in the PATH before the host compiler,
  # we will need to override (not append to) PATH for the host build.
  my $root_env = $platforminfo{$opts{'target'}}->{'compiler_root_env'};
  my $root_dir = $ENV{$root_env};
  my @oldpath = split /$specific{'pathsep'}/, $ENV{'PATH'};
  my $newpath = join($specific{'pathsep'}, grep {!/^$root_dir/} @oldpath);
  $hostEnv{'PATH'} =~
    s/\Q$specific{'refpre'}\EPATH\Q$specific{'refpost'}\E/$newpath/;
}

## compiler

if ($opts{'compiler'}) {
  my $standard = 0;
  for my $stdcomp (@{$platforminfo{$opts{'host'}}->{'compilers'}}) {
    $standard = 1 if $opts{'compiler'} eq $stdcomp;
  }
  $opts{'nonstdcompiler'} = 1 unless $standard;
}
else {
  print "Auto-detecting compiler\n" if $opts{'verbose'};
  for my $stdcomp (@{$platforminfo{$opts{'host'}}->{'compilers'}}) {
    my $path = which($stdcomp);
    if ($path) {
      print "Found $stdcomp at: $path\n" if $opts{'verbose'};
      $opts{'compiler'} = $stdcomp;
      last;
    }
  }
  if (!defined $opts{'compiler'}) {
    die "Can't find a compiler, set PATH or run this script with the ".
      "--compiler option.\n" . ($slash eq '\\' ? "  For Microsoft Visual C++, ".
                                "run this script from the Visual Studio ".
                                "Command Prompt.\n" : '') . "Stopped";
  }
}
print "compiler is: $opts{'compiler'}\n" if $opts{'verbose'};

if ($opts{'compiler'} =~ /cl(\.exe)?$/i) {
  my $savepath = $ENV{'PATH'};
  my $clpath = which($opts{'compiler'});
  if ($clpath) {
    $clpath =~ s/vc\\bin(\\(x86_)?amd64)?/common7\\ide/i;
    $ENV{'PATH'} .= ";$clpath";
  }
  open(CL, "\"$opts{'compiler'}\" /v 2>&1 |");
  while (<CL>) {
    if (/version (\d+)\.(\d+)/i) { # match i18n version strings
      my $ver = ($2 == 0) ? $1 : "$1.$2";
      $ver =~ s/0+$// unless $2 == 0;
      if (!exists $platforminfo{'win32'}->{'cl_versions'}->{$ver}) {
        die "Unknown or unsupported Visual C++ compiler version: $ver\nStopped";
      }
      $opts{'compiler_version'} =
        $platforminfo{'win32'}->{'cl_versions'}->{$ver};
      if ($ver >= 19) {
        push(@{$opts{'features'}}, 'no_cxx11=0');
        print "Visual C++ has C++11 support\n" if $opts{'verbose'};
      }
      last;
    }
  }
  close CL;
  if (!$opts{'compiler_version'}) {
    die "Could not detect Visual C++ version, try running this script from\n" .
      "the Visual Studio Command Prompt.\nStopped";
  }
  $ENV{'PATH'} = $savepath;
  print "Detected Visual C++ version: $opts{'compiler_version'}\n"
    if $opts{'verbose'};
}
elsif ($opts{'compiler'} =~ /g\+\+/) {
  if ($opts{'std'}) {
    push(@{$opts{'macros'}}, 'CCFLAGS += -std=' . $opts{'std'});
    print "Added platform_macros for -std=$opts{std}\n" if $opts{'verbose'};
  }
  else {
    my $ver = `$opts{'compiler'} --version`;
    if ($ver =~ /\(.*\) (\d+)\.\d+/ && $1 >= 6) {
      $opts{'std'} = 'gnu++14';
      print "Detected GCC >=6, default -std=gnu++14\n" if $opts{'verbose'};
    }
  }

  if ($opts{'std'} && $opts{'std'} =~ /(0x|11|0y|14|1z|17)$/) {
    push(@{$opts{'features'}}, 'no_cxx11=0');
    print "Compiler has C++11 support\n" if $opts{'verbose'};
  }
}

sub looksRelative {
  my $val = shift;
  return substr($val, 0, 1) ne $slash && ($slash eq '/' || $val !~ /^[a-z]:/i);
}

sub normalizePath {
  my $val = shift;
  return Cwd::abs_path($val) if $val && -d $val && $val =~ /../;
  return $val;
}

sub setSomeEnv {
  my($hashref, $name, $val, $notdir) = @_;
  $val = Cwd::abs_path($val) if -d $val;
  if ($opts{'dry-run'} && !$notdir && looksRelative($val)) {
    $val = getcwd . $slash . $val;
  }
  $val =~ s!/!\\!g if $slash eq '\\';
  $hashref->{$name} = $val;
}

sub setEnv {
  setSomeEnv(\%targetEnv, @_);
}

sub setHostEnv {
  setSomeEnv(\%hostEnv, @_);
}

## ace
my $ace_src;

if ($opts{'ace'}) {
  if ($opts{'ace'} ne 'download') {
    if (!-r $opts{'ace'} . '/ace/ACE.h') {
      die "Can't find ACE at $opts{'ace'}\n";
    }
    $ace_src = $opts{'ace'};
  }
}
elsif ($ENV{'ACE_ROOT'}) {
  if (!-r $ENV{'ACE_ROOT'} . '/ace/ACE.h') {
    die "Can't find ACE at $ENV{'ACE_ROOT'}\n";
  }
  $ace_src = $ENV{'ACE_ROOT'};
}
elsif (-r '../ACE_wrappers/ace/ACE.h') {
  die "Older versions of this script would default to using ACE at " .
    "../ACE_wrappers, but this version doesn't.  Use the --ace command line " .
    "option to override this error.  Use --ace=download to have this script " .
    "download an ACE+TAO package and expand it to ACE_wrappers.\n";
}
elsif (-r 'ACE_wrappers/ace/ACE.h') {
  $ace_src = 'ACE_wrappers';
}
elsif (-r 'ATCD/ACE/ace/ACE.h') {
  $ace_src = 'ATCD/ACE';
}
elsif (-r 'ACE_TAO/ACE/ace/ACE.h') {
  $ace_src = 'ACE_TAO/ACE';
}

$ace_src = normalizePath($ace_src);

## tao
my $tao_src;

if ($opts{'tao'}) {
  if (!-r $opts{'tao'} . '/tao/ORB.h') {
    die "Can't find TAO at $opts{'tao'}\n";
  }
  $tao_src = $opts{'tao'};
}
elsif ($ENV{'TAO_ROOT'}) {
  if  (!-r $ENV{'TAO_ROOT'} . '/tao/ORB.h') {
    die "Can't find TAO at $ENV{'TAO_ROOT'}\n";
  }
  $tao_src = $ENV{'TAO_ROOT'};
}
elsif (defined $ace_src && -r $ace_src . '/TAO/tao/ORB.h') {
  $tao_src = $ace_src . $slash . 'TAO';
}
elsif (defined $ace_src && -r $ace_src . '/../TAO/tao/ORB.h') {
  $tao_src = (File::Spec->splitpath($ace_src))[1] .'TAO';
}

$tao_src = normalizePath($tao_src);

if ($opts{'safety-profile'}) {
  # convert to lower case
  $opts{'safety-profile'} = lc($opts{'safety-profile'});
}

## Download ACE+TAO
my $tao_maj = 1;
if (!$ace_src || !$tao_src) {
  my $urlbase;
  my $file;
  my $download_message;
  if ($opts{'doc_group'}) {
    $urlbase = 'http://download.dre.vanderbilt.edu/previous_versions/';
    $file = 'ACE+TAO-src-' . $doc_tao_version . '.'
      . ($slash eq '/' ? 'tar.gz' : 'zip');
    $download_message = "Downloading $file";
  } else {
    $urlbase = 'http://download.ociweb.com/TAO-' . $oci_tao_version . '/';
    $file = 'ACE+TAO-' . $oci_tao_version . '_with_latest_patches_NO_makefiles.'
      . ($slash eq '/' ? 'tar.gz' : 'zip');
    $download_message = "Downloading ACE+TAO $oci_tao_version with latest patches";
  }
  $tao_maj = 2 if $opts{'dry-run'};
  if (-r $file) {
    print "Using ACE+TAO source package $file\n" if $opts{'verbose'};
  }
  else {
    $would_download = 1;
    eval {
      require LWP::UserAgent;
      my $ua = LWP::UserAgent->new;
      $ua->env_proxy;
      print $download_message . "\n";
      if ($opts{'dry-run'}) {
        print "Dry-run: would LWP::UserAgent get $urlbase$file\n";
      }
      else {
        my $response = $ua->get($urlbase . $file, ':content_file' => $file);
        if ($response->is_error) {
          die $response->message . "\nstopped";
        }
      }
    };
    if ($@) {
      if (which('wget')) {
        print $download_message . " (using wget)\n";
        if ($opts{'dry-run'}) {
          print "Dry-run: would run wget $urlbase$file\n";
        }
        elsif (system("wget $urlbase$file")) {
          die "ERROR from wget, stopped";
        }
      }
      elsif (which('curl')) {
        print $download_message . " (using curl)\n";
        if ($opts{'dry-run'}) {
          print "Dry-run: would run curl $urlbase$file -o $file\n";
        }
        elsif (system("curl $urlbase$file -o $file")) {
          die "ERROR from curl, stopped";
        }
      }
      else {
        die "Can't download ACE+TAO using LWP, wget, or curl.\nDownload ACE+TAO ".
          "from $urlbase$file, place the file here\n, and re-run the script.\n";
      }
    }
  }

  print "Extracting archive $file\n";
  $ENV{'ACTIVEPERL_CONFIG_DISABLE'} = 1 if $^O eq 'MSWin32';
  $ENV{'ACTIVEPERL_CONFIG_SILENT'} = 1 if $^O eq 'MSWin32';
  eval {require Archive::Extract;};
  if ($@) {
    my $err = 1;
    my $ddsroot = getcwd;
    if ($slash eq '/') {
      if ($opts{'dry-run'}) {
        print "Dry-run: would run " . ($^O eq 'solaris' ? 'g' : '') .
          "tar xzf $ddsroot/$file\n";
        $err = 0;
      }
      else {
        $err = system(($^O eq 'solaris' ? 'g' : '') . "tar xzf $ddsroot/$file");
      }
    }
    if ($err) {
      die "Can't extract $file, extract it to " . Cwd::abs_path('.') .
        "\nand run this script again.\nStopped";
    }
  }
  else {
    if ($opts{'dry-run'}) {
      print "Dry-run: would Archive::Extract $file\n";
    }
    else {
      if ($^O ne 'MSWin32') {
        no warnings 'once';
        $Archive::Extract::PREFER_BIN = 1;
      }
      my $ae = Archive::Extract->new('archive' => $file);
      if (!$ae->extract('to' => '.')) {
        die $ae->error . "\nstopped";
      }
    }
  }

  unlink $file;
  print "Removed $file\n" if $opts{'verbose'};
  $ace_src = 'ACE_wrappers';
  $tao_src = 'ACE_wrappers/TAO';
}

print "Using ace_src: $ace_src\n" if $opts{'verbose'};
print "Using tao_src: $tao_src\n" if $opts{'verbose'};

unless ($opts{'dry-run'} && $would_download) {
  open TAOVER, $tao_src . '/VERSION' or die "can't open TAO VERSION\n";
  while (<TAOVER>) {
    if (/^This is TAO version (\d)/) {
      $tao_maj = $1;
      last;
    }
  }
  close TAOVER;
}

sub clone_host_and_target {
  my $source_dir = shift;
  locate_mpc($ace_src);
  my $cur_dir = getcwd;
  if ($source_dir ne '.') {
    print "Changing dir to $source_dir\n" if $opts{'verbose'};
    chdir($source_dir);
  }
  print "cloning build tree\n" if $opts{'verbose'};
  if (!$opts{'dry-run'}) {
    eval {
      system("$targetEnv{'MPC_ROOT'}/clone_build_tree.pl host target");
    };
  }
  if ($source_dir ne '.') {
    print "Changing dir back to $cur_dir\n" if $opts{'verbose'};
    chdir($cur_dir);
  }
}

sub backup_and_open {
  my $file = shift;
  if (!$opts{'dry-run'} && -r $file) {
    my $backup = (-e $file . '.bak') ? ($file . '.bak') : $file . ".bak.$$";
    copy($file, $backup);
    print "WARNING: overwriting existing $file (saved a backup copy as " .
      "$backup)\n";
    unlink $file;
  }
  if ($opts{'dry-run'}) {
    return File::Temp->new();
  }
  my $fh = new FileHandle;
  open $fh, ">$file" or die "Can't write to $file, stopped";
  return $fh;
}

sub dump_and_unlink { # removes temp files created by dry-run
  my $tfile = shift;
  if ($opts{'verbose'}) {
    open TMP, $tfile;
    print <TMP>;
    close TMP;
  }
  unlink $tfile;
}

sub write_config_h {
  my %buildEnv = %{shift()};
  my $pi = $platforminfo{$opts{$buildEnv{'build'}}};
  $opts{'optimize'} = 0 if !exists $opts{'optimize'};

  my $CFGH = backup_and_open("$buildEnv{'ACE_ROOT'}/ace/config.h");
  if ($buildEnv{'build'} eq 'target') {
    for my $line (@{$opts{'configh'}}) {
      print $CFGH "$line\n";
    }
  }
  my $cfg = $opts{$buildEnv{'build'}};
  if ($pi->{'aceconfig'}) {
    $cfg = $pi->{'aceconfig'};
    $cfg =~ s/\$UNAMER/my $u = `uname -r`; chomp $u; $u/e;
  }
  $cfg .= '-' . $opts{'host_version'} if $opts{'host_version'};
  print $CFGH "#include \"ace/config-$cfg.h\"\n";
  if (defined $opts{'no-opendds-safety-profile'}) {
    print $CFGH "#define ACE_FACE_SAFETY_" . uc($opts{'safety-profile'}) . "\n";
    if ($opts{'safety-profile'} eq 'extended') {
      print $CFGH "#ifndef ACE_HAS_ALLOC_HOOKS\n";
      print $CFGH "#  define ACE_HAS_ALLOC_HOOKS\n";
      print $CFGH "#endif\n";
    }
  }

  close $CFGH;
  print "Wrote $buildEnv{'ACE_ROOT'}/ace/config.h\n" if $opts{'verbose'};
  dump_and_unlink($CFGH) if $opts{'dry-run'};
}

my $wrote_df = 0;

sub write_default_features {
  my %buildEnv = %{shift()};
  my @feat;
  if ($buildEnv{'build'} eq 'target') {
    push(@feat, 'ipv6=1') if $opts{'ipv6'};
    push(@feat, @{$opts{'features'}}) if $opts{'features'};
  }
  elsif ($opts{'java'}) {
    push(@feat, 'java=1');
  }

  if (@feat) {
    my $DF = backup_and_open("$buildEnv{'ACE_ROOT'}/bin/MakeProjectCreator" .
                             "/config/default.features");
    $wrote_df = 1;
    for my $f (@feat) {
      print $DF "$f\n";
    }
    $DF->close;
    print "Wrote $buildEnv{'ACE_ROOT'}/.../default.features\n"
      if $opts{'verbose'};
    dump_and_unlink($DF) if $opts{'dry-run'};
  }
}

my @platformmacros;
sub write_platform_macros {
  my %buildEnv = %{shift()};
  if ($slash eq '/') {
    my $pi = $platforminfo{$opts{$buildEnv{'build'}}};
    my $PMG = backup_and_open("$buildEnv{'ACE_ROOT'}/include/makeinclude" .
                               "/platform_macros.GNU");
    if ($buildEnv{'build'} eq 'target') {
      for my $line (@{$opts{'macros'}}) {
        print $PMG "$line\n";
      }
      for my $key ('debug', 'optimize', 'inline', 'static', 'ipv6') {
        if (exists $opts{$key}) {
          my $macro = ($key eq 'static') ? 'static_libs_only' : $key;
          print $PMG "$macro = $opts{$key}\n";
        }
      }
      if ($cross_compile) {
        print $PMG 'TAO_IDL = $(HOST_ACE)/bin/tao_idl', "\n";
        print $PMG 'TAO_IDL_DEP = $(TAO_IDL)', "\n";
        print $PMG 'TAO_IDL_PREPROCESSOR = ', $opts{'compiler'}, "\n";
        print $PMG 'TAO_IDLFLAGS += -g $(HOST_ACE)/bin/ace_gperf', "\n";
        print $PMG 'build_tao_idl_be = 0', "\n";
        if ($opts{'target-compiler'}) {
          my $tcomp = $opts{'target-compiler'};
          if ($tcomp =~ s/-g([c+])\1$/-/) {
            print $PMG 'CROSS_COMPILE = ', $tcomp, "\n";
          }
          else {
            $opts{'nonstdcompiler'} = $tcomp;
            print $PMG 'LDFLAGS += -Wl,-rpath-link,$(ACE_ROOT)/lib', "\n";
          }
        }
      }
    }
    for my $f (@platformmacros) {
      print $PMG ($f =~ /=/ ? $f : "$f=1"), "\n";
    }
    if ($buildEnv{'build'} eq 'host') {
      print $PMG "static_libs_only = 1\n";
      print $PMG "java = 1\n" if $opts{'java'};
    }
    if ($opts{'prefix'}) {
      print $PMG "INSTALL_PREFIX=" . $opts{'prefix'} . "\n";
    }
    my $plat = $opts{$buildEnv{'build'}};
    if ($pi->{'aceplatform'}) {
      $plat = $pi->{'aceplatform'};
      $plat =~ s/\$COMP/($opts{'compiler'} =~ m!CC!) ? 'sunc++' : 'g++'/e;
      $plat =~ s/\$NONSTDCOMP/($opts{'compiler'} =~ m!clang!) ? 'clang' : ''/e;
      $plat =~ s/_$//;
    }
    $plat .= '_' . $opts{'host_version'} if $opts{'host_version'};
    print $PMG "include \$(ACE_ROOT)/include/makeinclude/platform_$plat.GNU\n";
    if ($opts{'nonstdcompiler'}) {
      for my $var ('CC', 'CXX', 'LD') {
        print $PMG "$var = $opts{'compiler'}\n";
      }
    }
    $PMG->close;
    print "Wrote $buildEnv{'ACE_ROOT'}/.../platform_macros.GNU\n"
      if $opts{'verbose'};
    dump_and_unlink($PMG) if $opts{'dry-run'};
  }
}

## Optional OpenDDS dependencies

my %optdep =
# %opts key =>    [env var,         sanity check,                  MPC feature]
  ('java' =>      ['JAVA_HOME',     'include/jni.h',               'java'],
   'jboss' =>     ['JBOSS_HOME',    'lib/jboss-common.jar'],
   'ant' =>       ['ANT_HOME',      'bin/ant'],
   'wireshark' => ['WIRESHARK_SRC', 'epan/packet.h',               'wireshark'],
   'glib' =>      ['GLIB_ROOT',     'include/glib-2.0/glib.h'],
   'rapidjson' => [undef,           undef,                         'no_itl=0'],
   'qt' =>        ['QTDIR',         '',                            'qt4'],
   'boost' =>     ['BOOST_ROOT',    'include/boost/version.hpp',   'boost'],
   'xerces3' =>   ['XERCESCROOT',   'include/xercesc/dom/DOM.hpp', 'xerces3'],
  );

if (exists $opts{'java'}) {
  if ($opts{'static'}) {
    die "ERROR: --static can't be used with --java\n";
  }
  setEnv('JAVA_PLATFORM', perlOS_to_java_platform());
}

$opts{'qt'} = '' if exists $opts{'qt-include'} && !exists $opts{'qt'};
$opts{'boost'} = '' if exists $opts{'boost-version'} && !exists $opts{'boost'};

my %use_system_pkg = map {$_, 1} qw/ant glib qt boost xerces3/;
my %use_win_default = ('boost' => 'c:\\Boost');
my %need_platform_macros = map {$_, 1} qw/xerces3/;

sub default_java_home {
  my $host = $opts{'host'};
  my $result = '';
  if ($host eq 'macosx') {
    $result = `/usr/libexec/java_home`;
    chomp $result;
    return $result;
  }
  else {
    $result = which('javac');

    while (-l $result) {
      $result = readlink($result);
    }
    # remove bin/javac
    return dirname(dirname($result))
  }
}

for my $key (keys %optdep) {
  if (exists $opts{$key} && $opts{$key} eq '') {
    if (defined $optdep{$key}->[0] && $ENV{$optdep{$key}->[0]}) {
      $opts{$key} = $ENV{$optdep{$key}->[0]};

      if ($key eq 'java') {
        ## when the environmental variable JAVA_HOME is set to a JRE location,
        ## try to resolve JAVA_HOME based on the location of javac
        my $java_home = default_java_home();
        my $jre_h_path = $opts{$key} . '/' . $optdep{'java'}->[1];
        if (!-r $jre_h_path and $java_home ne '') {
          $opts{'java'} = $java_home;
        }
      }
    }
    elsif ($slash eq '/' && exists $use_system_pkg{$key}) {
      $opts{$key} = '/usr';
      print "Defaulting $key to /usr\n" if $opts{'verbose'};
    }
    elsif ($slash ne '/' && exists $use_win_default{$key}) {
      $opts{$key} = $use_win_default{$key};
      print "Defaulting $key to $use_win_default{$key}\n" if $opts{'verbose'};
    }
    elsif ($key eq 'java') {

      $opts{'java'} = default_java_home();

      if ($opts{'java'} eq '') {
          die "ERROR: --$key requires a value\n";
      }
    }
    elsif (defined $optdep{$key}->[0]) {
      die "ERROR: --$key requires a value\n";
    }
  }
}


sub env_from_opt {
  my $key = shift;
  my $e = shift;
  my $notdir = shift;
  if ($opts{$key}) {
    setEnv($e, $opts{$key}, $notdir);
  }
}

if (exists $opts{'boost'} && !exists $opts{'boost-version'}) {
  if (!-r $opts{'boost'} . '/' . $optdep{'boost'}->[1]
      && -d $opts{'boost'} . '/include') {
    opendir DIR, $opts{'boost'} . '/include';
    my @dirs = sort {$b cmp $a} grep {/boost-/} readdir DIR;
    closedir DIR;
    if (scalar @dirs && -r $opts{'boost'} . '/include/' . $dirs[0]
        . '/boost/version.hpp') {
      $opts{'boost-version'} = $dirs[0];
      print "Found boost-version = $dirs[0]\n" if $opts{'verbose'};
    }
  }
}

if (exists $opts{'boost'} && exists $opts{'boost-version'}) {
  env_from_opt('boost', $optdep{'boost'}->[0]);
  env_from_opt('boost-version', 'BOOST_VERSION', 1);
  if ($targetEnv{'BOOST_VERSION'}
      && !-r $targetEnv{'BOOST_ROOT'} . '/' . $optdep{'boost'}->[1]
      && -r $targetEnv{'BOOST_ROOT'} . '/include/' . $targetEnv{'BOOST_VERSION'}
      . '/boost/version.hpp') {
    $optdep{'boost'}->[1] = ''; # skip sanity check in for-loop below
  }
}

my @features;
for my $key (keys %optdep) {
  if (exists $opts{$key}) {
    print "Enabling $key\n" if $opts{'verbose'};
    my ($e, $s, $m) = @{$optdep{$key}};
    env_from_opt($key, $e) if defined $e;
    if ($s && !-r $targetEnv{$e} . '/' . $s) {
      die "Can't find $key at $targetEnv{$e} (using $s)\n";
    }
    push(@features, $m) if $m;
    push(@platformmacros, $m) if $need_platform_macros{$key};
  }
}

if (exists $opts{'jboss'} && !exists $opts{'java'}) {
  die "--java is required for --jboss (OpenDDS JMS Provider)\n";
}

if (exists $opts{'jboss'} && !exists $opts{'ant'}) {
  die "--ant is required for --jboss (OpenDDS JMS Provider)\n";
}

if (exists $opts{'wireshark'} && !exists $opts{'glib'}) {
  die "--glib is required for --wireshark\n";
}

if ($opts{'glib'}) {
  if (!-r "$opts{'glib'}/lib/glib-2.0/include/glibconfig.h") {
    my $pc = `pkg-config --cflags-only-I glib-2.0`;
    chomp $pc;
    if ($pc =~ m!-I$opts{'glib'}/([-\w/]+)/glib-2.0/include!) {
      print "pkg-config found GLIB_LIB_DIR=$1\n" if $opts{'verbose'};
      setEnv('GLIB_LIB_DIR', $1);
    }
    else {
      print "Failed to locate glibconfig.h using pkg-config ($pc).  Set the " .
        "environment variable GLIB_LIB_DIR and re-run MPC.\n";
    }
  }
}

if ($opts{'qt-include'}) {
  setEnv('QT4_INCDIR', $opts{'qt-include'});
}
elsif (exists $opts{'qt'} && !$ENV{'QT4_INCDIR'} && !$targetEnv{'QT4_INCDIR'}) {
  setEnv('QT4_INCDIR', $targetEnv{'QTDIR'} . "/include/qt4")
    if -r "$targetEnv{'QTDIR'}/include/qt4/QtCore/qglobal.h";
}

if (exists $opts{'qt'} && !-r ($targetEnv{'QT4_INCDIR'} ?
                               $targetEnv{'QT4_INCDIR'} :
                               "$targetEnv{'QTDIR'}/include")
    . '/QtCore/qconfig.h') {
  die "Can't find qt at " . ($targetEnv{'QT4_INCDIR'} ?
                             $targetEnv{'QT4_INCDIR'} :
                             $targetEnv{'QTDIR'}) . "\nstopped";
}

sub push_env_dir {
  my ($buildEnvRef, $var, $path) = @_;
  if (exists $buildEnvRef->{$var}) {
    $buildEnvRef->{$var} .= $specific{'pathsep'} . $path;
  }
  else {
    $buildEnvRef->{$var} = $path;
  }
}

sub push_path {
  my ($buildEnvRef, $path) = @_;
  push_env_dir($buildEnvRef, 'PATH', $path);
}

sub push_libpath {
  my ($buildEnvRef, $path) = @_;
  my $build = $buildEnvRef->{'build'};
  my $platform = $opts{$build};
  my $libpathname = $platforminfo{$platform}->{'libpath'};
  push_env_dir($buildEnvRef, $libpathname, $path);
}

sub write_host_workspace {
  my %buildEnv = %{shift()};
  my $MWC = backup_and_open($buildEnv{'DDS_ROOT'} . '/host_tools.mwc');
  print $MWC <<'EOT';
workspace {
  $(ACE_ROOT)/ace/ace.mpc
  $(ACE_ROOT)/apps/gperf/src
  $(TAO_ROOT)/TAO_IDL
  dds/idl
  java/idl2jni/codegen
EOT
  print $MWC "  \$(TAO_ROOT)/tao/tao.mpc\n" if $opts{'safety-profile'};
  print $MWC "}\n";
  $MWC->close;
  print "Wrote host_tools.mwc in $buildEnv{'DDS_ROOT'}\n" if $opts{'verbose'};
  dump_and_unlink($MWC) if $opts{'dry-run'};
}

sub mergeToEnv {
  my $buildEnv = shift;
  for my $k (keys %{$buildEnv}) {
    next if $k eq 'build';
    if ($buildEnv->{$k} =~
        /^\Q$specific{'refpre'}\E$k\Q$specific{'refpost'}\E(.*)/) {
      if ($1 ne '') {
        $ENV{$k} .= $1;
        print "ENV: Appending $1 to $k\n" if $opts{'verbose'};
      }
    }
    else {
      $ENV{$k} = $buildEnv->{$k};
      print "ENV: Setting $k to $buildEnv->{$k}\n" if $opts{'verbose'};
    }
  }
}

sub disable_feature {
  my($featureArray, $feature) = @_;
  $feature =~ s/-/_/g;
  push(@{$featureArray}, "$feature=0");
}

my $buildtao;
sub generate_workspace {
  my $buildEnv = shift;
  $buildtao = 0;

  for my $feat (qw/built-in-topics ownership-profile/) {
    if (exists $opts{$feat} && !$opts{$feat}) {
      disable_feature(\@features, $feat);
    }
  }

  # default of these depends on whether we are doing a safety-profile build
  for my $feat (qw/content-subscription content-filtered-topic
                   multi-topic query-condition ownership-kind-exclusive
                   object-model-profile persistence-profile
                   no-opendds-safety-profile/) {
    if (defined $opts{'no-opendds-safety-profile'}) {
      if (!(exists $opts{$feat} && $opts{$feat})) {
        disable_feature(\@features, $feat);
      }
    }
    elsif (exists $opts{$feat} && !$opts{$feat}) {
      disable_feature(\@features, $feat);
    }
  }

  if ($slash eq '/') {
    if ($buildEnv->{'build'} eq 'target') {
      print "Writing $buildEnv->{'DDS_ROOT'}/user_macros.GNU\n"
        if $opts{'verbose'};
      my $UM = backup_and_open($buildEnv->{'DDS_ROOT'} . '/user_macros.GNU');
      for my $feat (@features) {
        my $key = $feat;
        $key =~ s/=.*//;
        print $UM ($feat =~ /=/ ? $feat : "$feat=1"), "\n"
          unless $need_platform_macros{$key};
      }
      if ($cross_compile) {
        print $UM <<'EOT';
OPENDDS_IDL = $(HOST_DDS)/bin/opendds_idl
OPENDDS_IDL_DEP = $(OPENDDS_IDL)
IDL2JNI = $(HOST_DDS)/bin/idl2jni
IDL2JNI_DEP = $(IDL2JNI)
CROSS-COMPILE = 1
EOT
      }
      $UM->close;
      dump_and_unlink($UM) if $opts{'dry-run'};
    }
  }

  my $tests = !exists $opts{'tests'} || $opts{'tests'};

  if ($opts{'safety-profile'} && $buildEnv->{'build'} eq 'target') {
    $buildtao = 0; # TAO will be built seperately
  }
  else {
    # build tao if tao_idl does not exist
    $buildtao = 1 if !-x "$buildEnv->{'ACE_ROOT'}/bin/tao_idl$exeext";
  }

  my $mpctype = ($slash eq '/') ? 'gnuace' : $opts{'compiler_version'};
  locate_mpc($ace_src);

  # Append to default.features
  if ($buildEnv->{'build'} eq 'target') {
    push(@features, 'cross_compile') if $cross_compile;
    if (@features) {
      my $df_file = "$buildEnv->{'ACE_ROOT'}/bin/MakeProjectCreator/config" .
        "/default.features";
      my $DF = $wrote_df
        ? ($opts{'dry-run'} ? File::Temp->new() : new FileHandle(">>$df_file"))
        : backup_and_open($df_file);
      for my $f (@features) {
        print $DF ($f =~ /=/ ? $f : "$f=1"), "\n";
      }
      $DF->close;
      if ($opts{'verbose'}) {
        print '' . ($wrote_df ? 'Appended to' : 'Wrote') .
          " $buildEnv->{'ACE_ROOT'}/.../default.features\n";
      }
      dump_and_unlink($DF) if $opts{'dry-run'};
    }
  }

  my $ws = 'DDS.mwc';
  if (-r $buildEnv->{'DDS_ROOT'} . "/host_tools.mwc") {
    $ws = 'host_tools.mwc';
  }
  elsif (!$tests && $buildtao) {
    $ws = 'DDS_TAOv2.mwc';
  }
  elsif (!$tests && !$buildtao) {
    $ws = 'DDS_no_tests.mwc';
  }
  elsif ($buildtao) {
    $ws = 'DDS_TAOv2_all.mwc';
  }

  my $static = ($opts{'static'} && $slash ne '/') ? '-static' : '';

  # We are not using CIAO or DAnCE, but MPC.cfg expands $CIAO_ROOT and
  # $DANCE_ROOT so leaving them empty/undefined would cause /MPC/config
  # to be on the include path for .mpb files.
  for my $var ('CIAO_ROOT', 'DANCE_ROOT') {
    $buildEnv->{$var} = 'unused' unless defined $buildEnv->{$var};
  }

  my %savedEnv = %ENV;
  print "ENV: saving current environment\n" if $opts{'verbose'};
  mergeToEnv($buildEnv);

  my $mwcargs = "-type $mpctype $buildEnv->{'DDS_ROOT'}$slash$ws $static";
  $mwcargs .= ' ' . join(' ', @{$opts{'mpcopts'}}) if defined $opts{'mpcopts'};
  print "OpenDDS mwc command line: $mwcargs\n" if $opts{'verbose'};
  print 'Running MPC to generate ', ($mpctype eq 'gnuace' ? 'makefiles' :
                                     'project files'), ".\n";
  if (!$opts{'dry-run'}) {
    if (system("perl $ENV{'ACE_ROOT'}/bin/mwc.pl $mwcargs") != 0) {
      die "Error from MPC, stopped";
    }
  }

  # If this is a target safety profile build
  if (defined $opts{'no-opendds-safety-profile'}) {
    # Generate ACE workspace separately, to exclude TAO
    my $mwcargs = "-type $mpctype $static " . $buildEnv->{'ACE_ROOT'}. "/ace";
    $mwcargs .= ' ' . join(' ', @{$opts{'mpcopts'}}) if defined $opts{'mpcopts'};
    print "ACE mwc command line: $mwcargs\n" if $opts{'verbose'};

    if (!$opts{'dry-run'}) {
      if (system("perl $ENV{'ACE_ROOT'}/bin/mwc.pl $mwcargs") != 0) {
        die "Error from MPC, stopped";
      }
    }
  }

  %ENV = %savedEnv;
  print "ENV: restoring previous environment\n" if $opts{'verbose'};

  $ws =~ s/\.mwc$/.sln/;
  $opts{'solution_file'} = $ws;
}

sub write_environment {
  my %buildEnv = %{shift()};
  my $dir = shift;
  my $MK = undef;
  if ($slash eq '/') {
    if (!$opts{'dry-run'}) {
      move($dir . '/GNUmakefile', $dir . '/GNUmakefile.dist');
    }
    $MK = backup_and_open($dir . '/GNUmakefile');
  }

  my $SE = backup_and_open($dir . '/setenv.' . $specific{'ext'});

  my $args_ = join(' ', map {/ / ? ('"' . $_ . '"') : $_} @ARGS);
  print $SE "$specific{'comment'} OpenDDS configure script: $0 $args_\n";
  print $MK "$specific{'comment'} OpenDDS configure script: $0 $args_\n" if $MK;

  for my $key (keys %buildEnv) {
    if ($key ne 'build') {
      print $SE "$specific{'export'} $key=$buildEnv{$key}\n";
      print $MK "export $key := $buildEnv{$key}\n" if $MK;
    }
  }

  $SE->close;
  print "Wrote $dir/setenv.$specific{'ext'}\n" if $opts{'verbose'};
  dump_and_unlink($SE) if $opts{'dry-run'};

  if ($MK) {
    print $MK "include GNUmakefile.dist\n";
    $MK->close;
    print "Wrote $dir/GNUmakefile, wrapping original GNUmakefile.dist\n"
      if $opts{'verbose'};
    dump_and_unlink($MK) if $opts{'dry-run'};
  }
}

sub get_mac_version {
  my $buildEnvRef = shift;
  if (-r "$buildEnvRef->{ACE_ROOT}/ace/config-macosx.h") {
    my $cfg = new FileHandle("$buildEnvRef->{ACE_ROOT}/ace/config-macosx.h");
    while (<$cfg>) {
      if (/__MAC_OS_X_VERSION_MAX_ALLOWED/) {
        return;
      }
    }
  }

  my $vers = `sw_vers -productVersion`;
  $vers =~ /10\.(\d+)\.?/;
  if (!exists $platforminfo{'macosx'}->{'versions'}->{$1}) {
    die "ERROR: Unknown/unsupported Mac OS X version: $1, stopped";
  }
  $opts{'host_version'} = $platforminfo{'macosx'}->{'versions'}->{$1};
  print "Mac OS X version is: $opts{'host_version'}\n" if $opts{'verbose'};
}

sub configure_build {
  my $buildEnvRef = shift;
  if (-r "$buildEnvRef->{ACE_ROOT}/ace/config.h") {
    print "ACE_ROOT/ace/config.h exists, skipping configuration of ACE+TAO\n";
  }
  else {
    get_mac_version($buildEnvRef) if $opts{'host'} eq 'macosx';

    write_config_h($buildEnvRef);
    write_default_features($buildEnvRef);
    write_platform_macros($buildEnvRef);
  }
  generate_workspace($buildEnvRef);
  write_environment($buildEnvRef, $buildEnvRef->{'DDS_ROOT'});
}

sub write_cross_compile_makefile {
  my $MF = backup_and_open('GNUmakefile');
  my $safety_profile_step = $opts{'safety-profile'} ?
    "\tcd $targetEnv{'ACE_ROOT'}/ace && " .
    '$(MAKE) $(if $(filter all,$@),ACE,$@)' . "\n" : '';
  print $MF <<"EOT";
# OpenDDS configure script: $0 @ARGS
all clean realclean depend:
\tcd build/host && \$(MAKE) \$@
$safety_profile_step\tcd build/target && \$(MAKE) \$@
.PHONY: all clean realclean depend
EOT
  $MF->close;
  print "Wrote top-level GNUmakefile for cross-compile\n" if $opts{'verbose'};
  dump_and_unlink($MF) if $opts{'dry-run'};
}

sub nested {
  my($sub, $top) = @_;
  my $subdir = $opts{'dry-run'} ? $sub : Cwd::abs_path($sub);
  my $parent = $opts{'dry-run'} ? $top : Cwd::abs_path($top);
  if ($opts{'dry-run'} && $top eq '.' && looksRelative($sub)) {
    return $slash . $sub;
  }
  if (index($subdir, $parent) == 0) {
    return substr($subdir, length($parent));
  }
  return undef;
}

if ($cross_compile) {
  clone_host_and_target('.');
  setHostEnv('DDS_ROOT', 'build/host');
  setEnv('HOST_DDS', 'build/host');
  setEnv('DDS_ROOT', 'build/target');

  my $tao_clone = $opts{'safety-profile'} ? 'host' : 'target';
  my $ace_sub_dds = nested($ace_src, '.');
  my $tao_sub_dds = nested($tao_src, '.');
  my $tao_sub_ace = nested($tao_src, $ace_src);

  if ($ace_sub_dds) {
    setHostEnv('ACE_ROOT', 'build/host' . $ace_sub_dds);
    setEnv('HOST_ACE', 'build/host' . $ace_sub_dds);
    setEnv('ACE_ROOT', 'build/target' . $ace_sub_dds);
  }
  else {
    clone_host_and_target($ace_src);
    setHostEnv('ACE_ROOT', $ace_src . '/build/host');
    setEnv('HOST_ACE', $ace_src . '/build/host');
    setEnv('ACE_ROOT', $ace_src . '/build/target');
    if ($tao_sub_ace) {
      setHostEnv('TAO_ROOT', $ace_src . '/build/host' . $tao_sub_ace);
      setEnv('TAO_ROOT', $ace_src . '/build/' . $tao_clone . $tao_sub_ace);
    }
  }

  if ($tao_sub_dds) {
    setHostEnv('TAO_ROOT', 'build/host' . $tao_sub_dds);
    setEnv('TAO_ROOT', 'build/' . $tao_clone . $tao_sub_dds);
  }
  elsif (!$tao_sub_ace) {
    if ($opts{'safety-profile'}) {
      setHostEnv('TAO_ROOT', $tao_src);
      setEnv('TAO_ROOT', $tao_src);
    }
    else {
      clone_host_and_target($tao_src);
      setHostEnv('TAO_ROOT', $tao_src . '/build/host');
      setEnv('TAO_ROOT', $tao_src . '/build/target');
    }
  }

  push_path(\%targetEnv, $hostEnv{'ACE_ROOT'} . $slash . 'bin');
  push_path(\%targetEnv, $hostEnv{'DDS_ROOT'} . $slash . 'bin');

  print "Cross-compile configuring host\n" if $opts{'verbose'};

  write_host_workspace(\%hostEnv); # host_tools.mwc
  configure_build(\%hostEnv);

  print "Cross-compile configuring target\n" if $opts{'verbose'};

  if ($opts{'safety-profile'}) {
    $opts{'no-opendds-safety-profile'} = 0; # only set for target
  }

  unless ($opts{'static'}) {
    push_libpath(\%targetEnv, $targetEnv{'ACE_ROOT'} . $slash . 'lib');
    push_libpath(\%targetEnv, $targetEnv{'DDS_ROOT'} . $slash . 'lib');
  }

  configure_build(\%targetEnv);

  write_environment(\%targetEnv, $targetEnv{'ACE_ROOT'} . '/ace')
    if $opts{'safety-profile'};

  write_cross_compile_makefile() if $slash eq '/';
}
else { # not cross-compiling:
  setEnv('ACE_ROOT', $ace_src);
  setEnv('TAO_ROOT', $tao_src);
  setEnv('DDS_ROOT', '.');

  push_path(\%targetEnv, $targetEnv{'ACE_ROOT'} . $slash . 'bin');
  push_path(\%targetEnv, $targetEnv{'DDS_ROOT'} . $slash . 'bin');

  unless ($opts{'static'}) {
    push_libpath(\%targetEnv, $targetEnv{'ACE_ROOT'} . $slash . 'lib');
    push_libpath(\%targetEnv, $targetEnv{'DDS_ROOT'} . $slash . 'lib');
  }

  configure_build(\%targetEnv);
}

print "Completed configuring OpenDDS, next ";
if ($slash eq '/') {
  print "run '", (($^O eq 'solaris' || $^O eq 'freebsd') ? 'g' : ''), "make'";
}
else {
  print "build '", $opts{'solution_file'}, "' using the '",
    ($opts{'optimize'} ? 'Release' : 'Debug'), "' configuration";
}
print " to compile ",
  ($cross_compile ? "\nthe host and target builds of " : ''),
  "OpenDDS", (($buildtao || $cross_compile) ? ' and ACE+TAO' : '') ,".\n",
  "You can use the generated setenv.$specific{'ext'} script ",
  ($cross_compile ?
   "in the\nbuild${slash}host and build${slash}target dirs " : ''),
  "to set environment\nvariables for future shell sessions.\n";
if ($slash ne '/') {
  print "Start Visual Studio from this command prompt so that it inherits ",
    "the correct\nenvironment variables.\n";
}
