/*
 *
 *
 * Distributed under the OpenDDS License.
 * See: http://www.opendds.org/license.html
 */

#ifndef OPENDDS_DCPS_REACTORTASK_H
#define OPENDDS_DCPS_REACTORTASK_H

#include "ConditionVariable.h"
#include "Definitions.h"
#include "RcEventHandler.h"
#include "RcObject.h"
#include "SafetyProfileStreams.h"
#include "ThreadStatusManager.h"
#include "TimeTypes.h"
#include "dcps_export.h"

#include <ace/Hash_Map_Manager_T.h>
#include <ace/Event_Handler_Handle_Timeout_Upcall.h>
#include <ace/Synch_Traits.h>
#include <ace/Task.h>
#include <ace/Timer_Heap_T.h>

ACE_BEGIN_VERSIONED_NAMESPACE_DECL
class ACE_Proactor;
class ACE_Reactor;
ACE_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL

namespace OpenDDS {
namespace DCPS {

class OpenDDS_Dcps_Export ReactorWrapper
  : public RcEventHandler
{
public:
  ReactorWrapper()
    : reactor_(0)
#if OPENDDS_CONFIG_BOOTTIME_TIMERS
    , timer_fd_(ACE_INVALID_HANDLE)
#endif
  {}

  bool open(ACE_Reactor* reactor);
  void close();

  typedef long TimerId; // from ACE_Reactor
  static const TimerId InvalidTimerId;

  TimerId schedule(RcEventHandler& handler,
                   const void* arg,
                   const TimeDuration& delay,
                   const TimeDuration& interval = TimeDuration());

  void cancel(TimerId timer);

  int register_handler(ACE_HANDLE io_handle,
                       ACE_Event_Handler* event_handler,
                       ACE_Reactor_Mask mask);

  int register_handler(ACE_Event_Handler* event_handler,
                       ACE_Reactor_Mask mask);

  int remove_handler(ACE_HANDLE io_handle,
                     ACE_Reactor_Mask mask);

  int remove_handler(ACE_Event_Handler* event_handler,
                     ACE_Reactor_Mask mask);

private:
  ACE_Reactor* reactor_;

#if OPENDDS_CONFIG_BOOTTIME_TIMERS
  // CLOCK_BOOTTIME timers on Linux can be set using the timerfd_*
  // functions.  The file descriptor created by timerfd_ can be used
  // with ACE's reactor so that events generated by these timers can be
  // demultiplexed along with other events on the same thread.  To
  // maintain the ACE timers abstraction for users of the
  // OpenDDS::DCPS::ReactorWrapper functions, we'll translate the
  // timerfd's input/read event to handle_timeout.
  ACE_HANDLE get_handle() const { return timer_fd_; }
  int handle_input(ACE_HANDLE);
  int handle_close(ACE_HANDLE, ACE_Reactor_Mask) { ::close(timer_fd_); return 0; }
  bool arm();
  ACE_HANDLE timer_fd_;
  ACE_Timer_Heap_T<ACE_Event_Handler*, ACE_Event_Handler_Handle_Timeout_Upcall, ACE_SYNCH_RECURSIVE_MUTEX, MonotonicClock> timer_heap_;
#endif
};

class OpenDDS_Dcps_Export ReactorTask
  : public virtual ACE_Task_Base
  , public virtual RcObject
{
public:
  explicit ReactorTask(bool useAsyncSend = false);
  virtual ~ReactorTask();

  // Use init_reactor_task (and not open_reactor_task) to initialize this
  // object without spawning a thread.
  // A subsequent call to run_reactor can optionally spawn threads to
  // run the reactor.
  // Takes ownership of the reactor.
  int init_reactor_task(ThreadStatusManager* thread_status_manager = 0,
                        const String& name = "",
                        ACE_Reactor* reactor = 0);

  // Use open_reactor_task (and not init_reactor_task) to spawn a single thread
  // that runs the reactor until stop().
  // Takes ownership of the reactor.
  int open_reactor_task(ThreadStatusManager* thread_status_manager = 0,
                        const String& name = "",
                        ACE_Reactor* reactor = 0);

  virtual int open(void*) { return open_reactor_task(); }
  virtual int svc();
  virtual int close(u_long flags = 0);

  // Block and run the reactor until it's shut down or run_time expires.
  // If run_time is 0, the run time is unlimited.
  // If threads > 1, spawn that number of threads and wait until they all complete.
  //   The reactor must be capable of multi-threaded execution (see TP_Reactor).
  // If threads == 1, run the reactor directly in this function.
  int run_reactor(size_t threads, const TimeDuration& run_time);

  void stop();

  bool on_thread() const;

  ACE_Reactor* get_reactor();
  const ACE_Reactor* get_reactor() const;

  ACE_Proactor* get_proactor();
  const ACE_Proactor* get_proactor() const;

  class OpenDDS_Dcps_Export Command
    : public virtual RcObject {
  public:
    Command() { }
    virtual ~Command() { }

    virtual void execute(ReactorWrapper& reactor_wrapper) = 0;
  };
  typedef RcHandle<Command> CommandPtr;

  CommandPtr execute_or_enqueue(CommandPtr command);
  void wait_until_empty();

  size_t command_queue_size() const;

  OPENDDS_POOL_ALLOCATION_FWD

private:
  virtual void reactor(ACE_Reactor* reactor);
  virtual ACE_Reactor* reactor() const;

  int init_i(ThreadStatusManager* thread_status_manager,
             const String& name,
             ACE_Reactor* reactor);

  void cleanup();
  void wait_for_startup_i() const;
  int run_reactor_i();

  typedef ACE_SYNCH_MUTEX LockType;
  typedef ACE_Guard<LockType> GuardType;
  typedef ConditionVariable<LockType> ConditionVariableType;
  typedef ACE_Timer_Heap_T<
    ACE_Event_Handler*, ACE_Event_Handler_Handle_Timeout_Upcall,
    ACE_SYNCH_RECURSIVE_MUTEX, MonotonicClock> TimerQueueType;

  struct ThreadEqual {
    bool operator()(const ACE_thread_t& lhs, const ACE_thread_t& rhs) const
    {
      return ACE_OS::thr_equal(lhs, rhs);
    }
  };

  mutable LockType lock_;
  mutable ConditionVariableType condition_;
  enum State { STATE_UNINITIALIZED, STATE_RUNNING, STATE_SHUT_DOWN };
  State state_;
  ACE_Reactor* reactor_;
  ACE_Hash_Map_Manager_Ex<ACE_thread_t, int, ACE_Hash<ACE_thread_t>, ThreadEqual, ACE_Null_Mutex> reactor_owners_;
  ACE_Proactor* proactor_;
  size_t n_threads_;
  TimeDuration run_time_;

#if defined ACE_WIN32 && defined ACE_HAS_WIN32_OVERLAPPED_IO
#define OPENDDS_REACTOR_TASK_ASYNC
  bool use_async_send_;
#endif

  TimerQueueType* timer_queue_;

  typedef OPENDDS_VECTOR(CommandPtr) Queue;
  Queue command_queue_;

  enum ReactorState {
    RS_NONE,
    RS_NOTIFIED,
    RS_PROCESSING
  };
  ReactorState reactor_state_;

  int handle_exception(ACE_HANDLE /*fd*/);
  void process_command_queue_i(ACE_Guard<ACE_Thread_Mutex>& guard,
                               ACE_Reactor* reactor);

  ReactorWrapper reactor_wrapper_;

  // thread status reporting
  String name_;
  ThreadStatusManager* thread_status_manager_;
};

class OpenDDS_Dcps_Export RegisterHandler : public ReactorTask::Command {
public:
  RegisterHandler(ACE_HANDLE io_handle,
                  ACE_Event_Handler* event_handler,
                  ACE_Reactor_Mask mask)
    : io_handle_(io_handle)
    , event_handler_(event_handler)
    , mask_(mask)
  {}

private:
  ACE_HANDLE io_handle_;
  ACE_Event_Handler* event_handler_;
  ACE_Reactor_Mask mask_;

  void execute(ReactorWrapper& reactor_wrapper);
};

class OpenDDS_Dcps_Export RemoveHandler : public ReactorTask::Command {
public:
  RemoveHandler(ACE_HANDLE io_handle,
                ACE_Reactor_Mask mask)
    : io_handle_(io_handle)
    , mask_(mask)
  {}

private:
  ACE_HANDLE io_handle_;
  ACE_Reactor_Mask mask_;

  void execute(ReactorWrapper& reactor_wrapper);
};

} // namespace DCPS
} // namespace OpenDDS

OPENDDS_END_VERSIONED_NAMESPACE_DECL

#if defined (__ACE_INLINE__)
#include "ReactorTask.inl"
#endif /* __ACE_INLINE__ */

#endif  /* OPENDDS_DCPS_REACTORTASK_H */
