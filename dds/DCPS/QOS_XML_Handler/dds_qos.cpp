/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "dds_qos.hpp"

#include "ace/ace_wchar.h"
namespace dds
{
  // destinationOrderKind

  destinationOrderKind::Value destinationOrderKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::destinationOrderKind const& a, ::dds::destinationOrderKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::destinationOrderKind const& a, ::dds::destinationOrderKind const& b)
  {
    return a.v_ != b.v_;
  }

  destinationOrderKind::
  destinationOrderKind (destinationOrderKind::Value v)
  : v_ (v)
  {
  }

  // durabilityKind

  durabilityKind::Value durabilityKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::durabilityKind const& a, ::dds::durabilityKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::durabilityKind const& a, ::dds::durabilityKind const& b)
  {
    return a.v_ != b.v_;
  }

  durabilityKind::
  durabilityKind (durabilityKind::Value v)
  : v_ (v)
  {
  }

  // historyKind

  historyKind::Value historyKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::historyKind const& a, ::dds::historyKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::historyKind const& a, ::dds::historyKind const& b)
  {
    return a.v_ != b.v_;
  }

  historyKind::
  historyKind (historyKind::Value v)
  : v_ (v)
  {
  }

  // livelinessKind

  livelinessKind::Value livelinessKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::livelinessKind const& a, ::dds::livelinessKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::livelinessKind const& a, ::dds::livelinessKind const& b)
  {
    return a.v_ != b.v_;
  }

  livelinessKind::
  livelinessKind (livelinessKind::Value v)
  : v_ (v)
  {
  }

  // presentationAccessScopeKind

  presentationAccessScopeKind::Value presentationAccessScopeKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::presentationAccessScopeKind const& a, ::dds::presentationAccessScopeKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::presentationAccessScopeKind const& a, ::dds::presentationAccessScopeKind const& b)
  {
    return a.v_ != b.v_;
  }

  presentationAccessScopeKind::
  presentationAccessScopeKind (presentationAccessScopeKind::Value v)
  : v_ (v)
  {
  }

  // reliabilityKind

  reliabilityKind::Value reliabilityKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::reliabilityKind const& a, ::dds::reliabilityKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::reliabilityKind const& a, ::dds::reliabilityKind const& b)
  {
    return a.v_ != b.v_;
  }

  reliabilityKind::
  reliabilityKind (reliabilityKind::Value v)
  : v_ (v)
  {
  }

  // ownershipKind

  ownershipKind::Value ownershipKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::ownershipKind const& a, ::dds::ownershipKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::ownershipKind const& a, ::dds::ownershipKind const& b)
  {
    return a.v_ != b.v_;
  }

  ownershipKind::
  ownershipKind (ownershipKind::Value v)
  : v_ (v)
  {
  }

  // dataRepresentationIdKind

  dataRepresentationIdKind::Value dataRepresentationIdKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::dataRepresentationIdKind const& a, ::dds::dataRepresentationIdKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::dataRepresentationIdKind const& a, ::dds::dataRepresentationIdKind const& b)
  {
    return a.v_ != b.v_;
  }

  dataRepresentationIdKind::
  dataRepresentationIdKind (dataRepresentationIdKind::Value v)
  : v_ (v)
  {
  }

  // typeConsistencyKind

  typeConsistencyKind::Value typeConsistencyKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::typeConsistencyKind const& a, ::dds::typeConsistencyKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::typeConsistencyKind const& a, ::dds::typeConsistencyKind const& b)
  {
    return a.v_ != b.v_;
  }

  typeConsistencyKind::
  typeConsistencyKind (typeConsistencyKind::Value v)
  : v_ (v)
  {
  }

  // duration

  duration::duration ()
  : ::XSCRT::Type ()
  {
  }

  duration::duration (duration const& s) :
  ::XSCRT::Type (s)
  , sec_ (s.sec_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.sec_) : nullptr)
  , nanosec_ (s.nanosec_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.nanosec_) : nullptr)
  {
  }

  duration&
  duration::operator= (duration const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.sec_)
        sec (*(s.sec_));
      else
        sec_.release ();

      if (s.nanosec_)
        nanosec (*(s.nanosec_));
      else
        nanosec_.release ();
    }

    return *this;
  }


  // duration
  bool duration::
  sec_p () const
  {
    return !!sec_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& duration::
  sec () const
  {
    return *sec_;
  }

  void duration::
  sec (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (sec_)
    {
      *sec_ = e;
    }

    else
    {
      sec_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // duration
  bool duration::
  nanosec_p () const
  {
    return !!nanosec_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& duration::
  nanosec () const
  {
    return *nanosec_;
  }

  void duration::
  nanosec (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (nanosec_)
    {
      *nanosec_ = e;
    }

    else
    {
      nanosec_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // stringSeq

  stringSeq::stringSeq ()
  : ::XSCRT::Type ()
  {
  }

  stringSeq::stringSeq (stringSeq const& s) :
  ::XSCRT::Type (s)
  , element_ (s.element_)
  {
  }

  stringSeq&
  stringSeq::operator= (stringSeq const& s)
  {
    if (std::addressof(s) != this)
    {
      element_ = s.element_;
    }

    return *this;
  }


  // stringSeq
  stringSeq::element_const_iterator stringSeq::
  begin_element () const
  {
    return element_.cbegin ();
  }

  stringSeq::element_const_iterator stringSeq::
  end_element () const
  {
    return element_.cend ();
  }

  size_t stringSeq::
  count_element() const
  {
    return element_.size ();
  }


  // dataRepresentationIdSeq

  dataRepresentationIdSeq::dataRepresentationIdSeq ()
  : ::XSCRT::Type ()
  {
  }

  dataRepresentationIdSeq::dataRepresentationIdSeq (dataRepresentationIdSeq const& s) :
  ::XSCRT::Type (s)
  , element_ (s.element_)
  {
  }

  dataRepresentationIdSeq&
  dataRepresentationIdSeq::operator= (dataRepresentationIdSeq const& s)
  {
    if (std::addressof(s) != this)
    {
      element_ = s.element_;
    }

    return *this;
  }


  // dataRepresentationIdSeq
  dataRepresentationIdSeq::element_const_iterator dataRepresentationIdSeq::
  begin_element () const
  {
    return element_.cbegin ();
  }

  dataRepresentationIdSeq::element_const_iterator dataRepresentationIdSeq::
  end_element () const
  {
    return element_.cend ();
  }

  size_t dataRepresentationIdSeq::
  count_element() const
  {
    return element_.size ();
  }


  // deadlineQosPolicy

  deadlineQosPolicy::deadlineQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  deadlineQosPolicy::deadlineQosPolicy (deadlineQosPolicy const& s) :
  ::XSCRT::Type (s)
  , period_ (s.period_ ? std::make_unique<::dds::duration> (*s.period_) : nullptr)
  {
  }

  deadlineQosPolicy&
  deadlineQosPolicy::operator= (deadlineQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.period_)
        period (*(s.period_));
      else
        period_.release ();
    }

    return *this;
  }


  // deadlineQosPolicy
  bool deadlineQosPolicy::
  period_p () const
  {
    return !!period_;
  }

  ::dds::duration const& deadlineQosPolicy::
  period () const
  {
    return *period_;
  }

  void deadlineQosPolicy::
  period (::dds::duration const& e)
  {
    if (period_)
    {
      *period_ = e;
    }

    else
    {
      period_ = std::make_unique<::dds::duration> (e);
    }
  }


  // destinationOrderQosPolicy

  destinationOrderQosPolicy::destinationOrderQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  destinationOrderQosPolicy::destinationOrderQosPolicy (destinationOrderQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::destinationOrderKind> (*s.kind_) : nullptr)
  {
  }

  destinationOrderQosPolicy&
  destinationOrderQosPolicy::operator= (destinationOrderQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();
    }

    return *this;
  }


  // destinationOrderQosPolicy
  bool destinationOrderQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::destinationOrderKind const& destinationOrderQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void destinationOrderQosPolicy::
  kind (::dds::destinationOrderKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::destinationOrderKind> (e);
    }
  }


  // durabilityQosPolicy

  durabilityQosPolicy::durabilityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  durabilityQosPolicy::durabilityQosPolicy (durabilityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::durabilityKind> (*s.kind_) : nullptr)
  {
  }

  durabilityQosPolicy&
  durabilityQosPolicy::operator= (durabilityQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();
    }

    return *this;
  }


  // durabilityQosPolicy
  bool durabilityQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::durabilityKind const& durabilityQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void durabilityQosPolicy::
  kind (::dds::durabilityKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::durabilityKind> (e);
    }
  }


  // durabilityServiceQosPolicy

  durabilityServiceQosPolicy::durabilityServiceQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  durabilityServiceQosPolicy::durabilityServiceQosPolicy (durabilityServiceQosPolicy const& s) :
  ::XSCRT::Type (s)
  , service_cleanup_delay_ (s.service_cleanup_delay_ ? std::make_unique<::dds::duration> (*s.service_cleanup_delay_) : nullptr)
  , history_kind_ (s.history_kind_ ? std::make_unique<::dds::historyKind> (*s.history_kind_) : nullptr)
  , history_depth_ (s.history_depth_ ? std::make_unique<::XMLSchema::positiveInteger> (*s.history_depth_) : nullptr)
  , max_samples_ (s.max_samples_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_samples_) : nullptr)
  , max_instances_ (s.max_instances_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_instances_) : nullptr)
  , max_samples_per_instance_ (s.max_samples_per_instance_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_samples_per_instance_) : nullptr)
  {
  }

  durabilityServiceQosPolicy&
  durabilityServiceQosPolicy::operator= (durabilityServiceQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.service_cleanup_delay_)
        service_cleanup_delay (*(s.service_cleanup_delay_));
      else
        service_cleanup_delay_.release ();

      if (s.history_kind_)
        history_kind (*(s.history_kind_));
      else
        history_kind_.release ();

      if (s.history_depth_)
        history_depth (*(s.history_depth_));
      else
        history_depth_.release ();

      if (s.max_samples_)
        max_samples (*(s.max_samples_));
      else
        max_samples_.release ();

      if (s.max_instances_)
        max_instances (*(s.max_instances_));
      else
        max_instances_.release ();

      if (s.max_samples_per_instance_)
        max_samples_per_instance (*(s.max_samples_per_instance_));
      else
        max_samples_per_instance_.release ();
    }

    return *this;
  }


  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  service_cleanup_delay_p () const
  {
    return !!service_cleanup_delay_;
  }

  ::dds::duration const& durabilityServiceQosPolicy::
  service_cleanup_delay () const
  {
    return *service_cleanup_delay_;
  }

  void durabilityServiceQosPolicy::
  service_cleanup_delay (::dds::duration const& e)
  {
    if (service_cleanup_delay_)
    {
      *service_cleanup_delay_ = e;
    }

    else
    {
      service_cleanup_delay_ = std::make_unique<::dds::duration> (e);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  history_kind_p () const
  {
    return !!history_kind_;
  }

  ::dds::historyKind const& durabilityServiceQosPolicy::
  history_kind () const
  {
    return *history_kind_;
  }

  void durabilityServiceQosPolicy::
  history_kind (::dds::historyKind const& e)
  {
    if (history_kind_)
    {
      *history_kind_ = e;
    }

    else
    {
      history_kind_ = std::make_unique<::dds::historyKind> (e);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  history_depth_p () const
  {
    return !!history_depth_;
  }

  ::XMLSchema::positiveInteger const& durabilityServiceQosPolicy::
  history_depth () const
  {
    return *history_depth_;
  }

  void durabilityServiceQosPolicy::
  history_depth (::XMLSchema::positiveInteger const& e)
  {
    if (history_depth_)
    {
      *history_depth_ = e;
    }

    else
    {
      history_depth_ = std::make_unique<::XMLSchema::positiveInteger> (e);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_samples_p () const
  {
    return !!max_samples_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_samples () const
  {
    return *max_samples_;
  }

  void durabilityServiceQosPolicy::
  max_samples (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_)
    {
      *max_samples_ = e;
    }

    else
    {
      max_samples_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_instances_p () const
  {
    return !!max_instances_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_instances () const
  {
    return *max_instances_;
  }

  void durabilityServiceQosPolicy::
  max_instances (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_instances_)
    {
      *max_instances_ = e;
    }

    else
    {
      max_instances_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_samples_per_instance_p () const
  {
    return !!max_samples_per_instance_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_samples_per_instance () const
  {
    return *max_samples_per_instance_;
  }

  void durabilityServiceQosPolicy::
  max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_per_instance_)
    {
      *max_samples_per_instance_ = e;
    }

    else
    {
      max_samples_per_instance_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // entityFactoryQosPolicy

  entityFactoryQosPolicy::entityFactoryQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  entityFactoryQosPolicy::entityFactoryQosPolicy (entityFactoryQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autoenable_created_entities_ (s.autoenable_created_entities_ ? std::make_unique<::XMLSchema::boolean> (*s.autoenable_created_entities_) : nullptr)
  {
  }

  entityFactoryQosPolicy&
  entityFactoryQosPolicy::operator= (entityFactoryQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.autoenable_created_entities_)
        autoenable_created_entities (*(s.autoenable_created_entities_));
      else
        autoenable_created_entities_.release ();
    }

    return *this;
  }


  // entityFactoryQosPolicy
  bool entityFactoryQosPolicy::
  autoenable_created_entities_p () const
  {
    return !!autoenable_created_entities_;
  }

  ::XMLSchema::boolean const& entityFactoryQosPolicy::
  autoenable_created_entities () const
  {
    return *autoenable_created_entities_;
  }

  void entityFactoryQosPolicy::
  autoenable_created_entities (::XMLSchema::boolean const& e)
  {
    if (autoenable_created_entities_)
    {
      *autoenable_created_entities_ = e;
    }

    else
    {
      autoenable_created_entities_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }


  // groupDataQosPolicy

  groupDataQosPolicy::groupDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  groupDataQosPolicy::groupDataQosPolicy (groupDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.value_) : nullptr)
  {
  }

  groupDataQosPolicy&
  groupDataQosPolicy::operator= (groupDataQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // groupDataQosPolicy
  bool groupDataQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& groupDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void groupDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // historyQosPolicy

  historyQosPolicy::historyQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  historyQosPolicy::historyQosPolicy (historyQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::historyKind> (*s.kind_) : nullptr)
  , depth_ (s.depth_ ? std::make_unique<::XMLSchema::positiveInteger> (*s.depth_) : nullptr)
  {
  }

  historyQosPolicy&
  historyQosPolicy::operator= (historyQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();

      if (s.depth_)
        depth (*(s.depth_));
      else
        depth_.release ();
    }

    return *this;
  }


  // historyQosPolicy
  bool historyQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::historyKind const& historyQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void historyQosPolicy::
  kind (::dds::historyKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::historyKind> (e);
    }
  }

  // historyQosPolicy
  bool historyQosPolicy::
  depth_p () const
  {
    return !!depth_;
  }

  ::XMLSchema::positiveInteger const& historyQosPolicy::
  depth () const
  {
    return *depth_;
  }

  void historyQosPolicy::
  depth (::XMLSchema::positiveInteger const& e)
  {
    if (depth_)
    {
      *depth_ = e;
    }

    else
    {
      depth_ = std::make_unique<::XMLSchema::positiveInteger> (e);
    }
  }


  // latencyBudgetQosPolicy

  latencyBudgetQosPolicy::latencyBudgetQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  latencyBudgetQosPolicy::latencyBudgetQosPolicy (latencyBudgetQosPolicy const& s) :
  ::XSCRT::Type (s)
  , duration_ (s.duration_ ? std::make_unique<::dds::duration> (*s.duration_) : nullptr)
  {
  }

  latencyBudgetQosPolicy&
  latencyBudgetQosPolicy::operator= (latencyBudgetQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.duration_)
        duration (*(s.duration_));
      else
        duration_.release ();
    }

    return *this;
  }


  // latencyBudgetQosPolicy
  bool latencyBudgetQosPolicy::
  duration_p () const
  {
    return !!duration_;
  }

  ::dds::duration const& latencyBudgetQosPolicy::
  duration () const
  {
    return *duration_;
  }

  void latencyBudgetQosPolicy::
  duration (::dds::duration const& e)
  {
    if (duration_)
    {
      *duration_ = e;
    }

    else
    {
      duration_ = std::make_unique<::dds::duration> (e);
    }
  }


  // lifespanQosPolicy

  lifespanQosPolicy::lifespanQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  lifespanQosPolicy::lifespanQosPolicy (lifespanQosPolicy const& s) :
  ::XSCRT::Type (s)
  , duration_ (s.duration_ ? std::make_unique<::dds::duration> (*s.duration_) : nullptr)
  {
  }

  lifespanQosPolicy&
  lifespanQosPolicy::operator= (lifespanQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.duration_)
        duration (*(s.duration_));
      else
        duration_.release ();
    }

    return *this;
  }


  // lifespanQosPolicy
  bool lifespanQosPolicy::
  duration_p () const
  {
    return !!duration_;
  }

  ::dds::duration const& lifespanQosPolicy::
  duration () const
  {
    return *duration_;
  }

  void lifespanQosPolicy::
  duration (::dds::duration const& e)
  {
    if (duration_)
    {
      *duration_ = e;
    }

    else
    {
      duration_ = std::make_unique<::dds::duration> (e);
    }
  }


  // livelinessQosPolicy

  livelinessQosPolicy::livelinessQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  livelinessQosPolicy::livelinessQosPolicy (livelinessQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::livelinessKind> (*s.kind_) : nullptr)
  , lease_duration_ (s.lease_duration_ ? std::make_unique<::dds::duration> (*s.lease_duration_) : nullptr)
  {
  }

  livelinessQosPolicy&
  livelinessQosPolicy::operator= (livelinessQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();

      if (s.lease_duration_)
        lease_duration (*(s.lease_duration_));
      else
        lease_duration_.release ();
    }

    return *this;
  }


  // livelinessQosPolicy
  bool livelinessQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::livelinessKind const& livelinessQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void livelinessQosPolicy::
  kind (::dds::livelinessKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::livelinessKind> (e);
    }
  }

  // livelinessQosPolicy
  bool livelinessQosPolicy::
  lease_duration_p () const
  {
    return !!lease_duration_;
  }

  ::dds::duration const& livelinessQosPolicy::
  lease_duration () const
  {
    return *lease_duration_;
  }

  void livelinessQosPolicy::
  lease_duration (::dds::duration const& e)
  {
    if (lease_duration_)
    {
      *lease_duration_ = e;
    }

    else
    {
      lease_duration_ = std::make_unique<::dds::duration> (e);
    }
  }


  // ownershipQosPolicy

  ownershipQosPolicy::ownershipQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  ownershipQosPolicy::ownershipQosPolicy (ownershipQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::ownershipKind> (*s.kind_) : nullptr)
  {
  }

  ownershipQosPolicy&
  ownershipQosPolicy::operator= (ownershipQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();
    }

    return *this;
  }


  // ownershipQosPolicy
  bool ownershipQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::ownershipKind const& ownershipQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void ownershipQosPolicy::
  kind (::dds::ownershipKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::ownershipKind> (e);
    }
  }


  // ownershipStrengthQosPolicy

  ownershipStrengthQosPolicy::ownershipStrengthQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  ownershipStrengthQosPolicy::ownershipStrengthQosPolicy (ownershipStrengthQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::XMLSchema::nonNegativeInteger> (*s.value_) : nullptr)
  {
  }

  ownershipStrengthQosPolicy&
  ownershipStrengthQosPolicy::operator= (ownershipStrengthQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // ownershipStrengthQosPolicy
  bool ownershipStrengthQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::XMLSchema::nonNegativeInteger const& ownershipStrengthQosPolicy::
  value () const
  {
    return *value_;
  }

  void ownershipStrengthQosPolicy::
  value (::XMLSchema::nonNegativeInteger const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::XMLSchema::nonNegativeInteger> (e);
    }
  }


  // partitionQosPolicy

  partitionQosPolicy::partitionQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  partitionQosPolicy::partitionQosPolicy (partitionQosPolicy const& s) :
  ::XSCRT::Type (s)
  , name_ (s.name_ ? std::make_unique<::dds::stringSeq> (*s.name_) : nullptr)
  {
  }

  partitionQosPolicy&
  partitionQosPolicy::operator= (partitionQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.name_)
        name (*(s.name_));
      else
        name_.release ();
    }

    return *this;
  }


  // partitionQosPolicy
  bool partitionQosPolicy::
  name_p () const
  {
    return !!name_;
  }

  ::dds::stringSeq const& partitionQosPolicy::
  name () const
  {
    return *name_;
  }

  void partitionQosPolicy::
  name (::dds::stringSeq const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::dds::stringSeq> (e);
    }
  }


  // presentationQosPolicy

  presentationQosPolicy::presentationQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  presentationQosPolicy::presentationQosPolicy (presentationQosPolicy const& s) :
  ::XSCRT::Type (s)
  , access_scope_ (s.access_scope_ ? std::make_unique<::dds::presentationAccessScopeKind> (*s.access_scope_) : nullptr)
  , coherent_access_ (s.coherent_access_ ? std::make_unique<::XMLSchema::boolean> (*s.coherent_access_) : nullptr)
  , ordered_access_ (s.ordered_access_ ? std::make_unique<::XMLSchema::boolean> (*s.ordered_access_) : nullptr)
  {
  }

  presentationQosPolicy&
  presentationQosPolicy::operator= (presentationQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.access_scope_)
        access_scope (*(s.access_scope_));
      else
        access_scope_.release ();

      if (s.coherent_access_)
        coherent_access (*(s.coherent_access_));
      else
        coherent_access_.release ();

      if (s.ordered_access_)
        ordered_access (*(s.ordered_access_));
      else
        ordered_access_.release ();
    }

    return *this;
  }


  // presentationQosPolicy
  bool presentationQosPolicy::
  access_scope_p () const
  {
    return !!access_scope_;
  }

  ::dds::presentationAccessScopeKind const& presentationQosPolicy::
  access_scope () const
  {
    return *access_scope_;
  }

  void presentationQosPolicy::
  access_scope (::dds::presentationAccessScopeKind const& e)
  {
    if (access_scope_)
    {
      *access_scope_ = e;
    }

    else
    {
      access_scope_ = std::make_unique<::dds::presentationAccessScopeKind> (e);
    }
  }

  // presentationQosPolicy
  bool presentationQosPolicy::
  coherent_access_p () const
  {
    return !!coherent_access_;
  }

  ::XMLSchema::boolean const& presentationQosPolicy::
  coherent_access () const
  {
    return *coherent_access_;
  }

  void presentationQosPolicy::
  coherent_access (::XMLSchema::boolean const& e)
  {
    if (coherent_access_)
    {
      *coherent_access_ = e;
    }

    else
    {
      coherent_access_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }

  // presentationQosPolicy
  bool presentationQosPolicy::
  ordered_access_p () const
  {
    return !!ordered_access_;
  }

  ::XMLSchema::boolean const& presentationQosPolicy::
  ordered_access () const
  {
    return *ordered_access_;
  }

  void presentationQosPolicy::
  ordered_access (::XMLSchema::boolean const& e)
  {
    if (ordered_access_)
    {
      *ordered_access_ = e;
    }

    else
    {
      ordered_access_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }


  // readerDataLifecycleQosPolicy

  readerDataLifecycleQosPolicy::readerDataLifecycleQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  readerDataLifecycleQosPolicy::readerDataLifecycleQosPolicy (readerDataLifecycleQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autopurge_nowriter_samples_delay_ (s.autopurge_nowriter_samples_delay_ ? std::make_unique<::dds::duration> (*s.autopurge_nowriter_samples_delay_) : nullptr)
  , autopurge_disposed_samples_delay_ (s.autopurge_disposed_samples_delay_ ? std::make_unique<::dds::duration> (*s.autopurge_disposed_samples_delay_) : nullptr)
  {
  }

  readerDataLifecycleQosPolicy&
  readerDataLifecycleQosPolicy::operator= (readerDataLifecycleQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.autopurge_nowriter_samples_delay_)
        autopurge_nowriter_samples_delay (*(s.autopurge_nowriter_samples_delay_));
      else
        autopurge_nowriter_samples_delay_.release ();

      if (s.autopurge_disposed_samples_delay_)
        autopurge_disposed_samples_delay (*(s.autopurge_disposed_samples_delay_));
      else
        autopurge_disposed_samples_delay_.release ();
    }

    return *this;
  }


  // readerDataLifecycleQosPolicy
  bool readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay_p () const
  {
    return !!autopurge_nowriter_samples_delay_;
  }

  ::dds::duration const& readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay () const
  {
    return *autopurge_nowriter_samples_delay_;
  }

  void readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay (::dds::duration const& e)
  {
    if (autopurge_nowriter_samples_delay_)
    {
      *autopurge_nowriter_samples_delay_ = e;
    }

    else
    {
      autopurge_nowriter_samples_delay_ = std::make_unique<::dds::duration> (e);
    }
  }

  // readerDataLifecycleQosPolicy
  bool readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay_p () const
  {
    return !!autopurge_disposed_samples_delay_;
  }

  ::dds::duration const& readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay () const
  {
    return *autopurge_disposed_samples_delay_;
  }

  void readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay (::dds::duration const& e)
  {
    if (autopurge_disposed_samples_delay_)
    {
      *autopurge_disposed_samples_delay_ = e;
    }

    else
    {
      autopurge_disposed_samples_delay_ = std::make_unique<::dds::duration> (e);
    }
  }


  // reliabilityQosPolicy

  reliabilityQosPolicy::reliabilityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  reliabilityQosPolicy::reliabilityQosPolicy (reliabilityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::reliabilityKind> (*s.kind_) : nullptr)
  , max_blocking_time_ (s.max_blocking_time_ ? std::make_unique<::dds::duration> (*s.max_blocking_time_) : nullptr)
  {
  }

  reliabilityQosPolicy&
  reliabilityQosPolicy::operator= (reliabilityQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();

      if (s.max_blocking_time_)
        max_blocking_time (*(s.max_blocking_time_));
      else
        max_blocking_time_.release ();
    }

    return *this;
  }


  // reliabilityQosPolicy
  bool reliabilityQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::reliabilityKind const& reliabilityQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void reliabilityQosPolicy::
  kind (::dds::reliabilityKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::reliabilityKind> (e);
    }
  }

  // reliabilityQosPolicy
  bool reliabilityQosPolicy::
  max_blocking_time_p () const
  {
    return !!max_blocking_time_;
  }

  ::dds::duration const& reliabilityQosPolicy::
  max_blocking_time () const
  {
    return *max_blocking_time_;
  }

  void reliabilityQosPolicy::
  max_blocking_time (::dds::duration const& e)
  {
    if (max_blocking_time_)
    {
      *max_blocking_time_ = e;
    }

    else
    {
      max_blocking_time_ = std::make_unique<::dds::duration> (e);
    }
  }


  // resourceLimitsQosPolicy

  resourceLimitsQosPolicy::resourceLimitsQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  resourceLimitsQosPolicy::resourceLimitsQosPolicy (resourceLimitsQosPolicy const& s) :
  ::XSCRT::Type (s)
  , max_samples_ (s.max_samples_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_samples_) : nullptr)
  , max_instances_ (s.max_instances_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_instances_) : nullptr)
  , max_samples_per_instance_ (s.max_samples_per_instance_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.max_samples_per_instance_) : nullptr)
  , initial_samples_ (s.initial_samples_ ? std::make_unique<::XMLSchema::positiveInteger> (*s.initial_samples_) : nullptr)
  , initial_instances_ (s.initial_instances_ ? std::make_unique<::XMLSchema::positiveInteger> (*s.initial_instances_) : nullptr)
  {
  }

  resourceLimitsQosPolicy&
  resourceLimitsQosPolicy::operator= (resourceLimitsQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.max_samples_)
        max_samples (*(s.max_samples_));
      else
        max_samples_.release ();

      if (s.max_instances_)
        max_instances (*(s.max_instances_));
      else
        max_instances_.release ();

      if (s.max_samples_per_instance_)
        max_samples_per_instance (*(s.max_samples_per_instance_));
      else
        max_samples_per_instance_.release ();

      if (s.initial_samples_)
        initial_samples (*(s.initial_samples_));
      else
        initial_samples_.release ();

      if (s.initial_instances_)
        initial_instances (*(s.initial_instances_));
      else
        initial_instances_.release ();
    }

    return *this;
  }


  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_samples_p () const
  {
    return !!max_samples_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_samples () const
  {
    return *max_samples_;
  }

  void resourceLimitsQosPolicy::
  max_samples (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_)
    {
      *max_samples_ = e;
    }

    else
    {
      max_samples_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_instances_p () const
  {
    return !!max_instances_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_instances () const
  {
    return *max_instances_;
  }

  void resourceLimitsQosPolicy::
  max_instances (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_instances_)
    {
      *max_instances_ = e;
    }

    else
    {
      max_instances_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_samples_per_instance_p () const
  {
    return !!max_samples_per_instance_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_samples_per_instance () const
  {
    return *max_samples_per_instance_;
  }

  void resourceLimitsQosPolicy::
  max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_per_instance_)
    {
      *max_samples_per_instance_ = e;
    }

    else
    {
      max_samples_per_instance_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  initial_samples_p () const
  {
    return !!initial_samples_;
  }

  ::XMLSchema::positiveInteger const& resourceLimitsQosPolicy::
  initial_samples () const
  {
    return *initial_samples_;
  }

  void resourceLimitsQosPolicy::
  initial_samples (::XMLSchema::positiveInteger const& e)
  {
    if (initial_samples_)
    {
      *initial_samples_ = e;
    }

    else
    {
      initial_samples_ = std::make_unique<::XMLSchema::positiveInteger> (e);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  initial_instances_p () const
  {
    return !!initial_instances_;
  }

  ::XMLSchema::positiveInteger const& resourceLimitsQosPolicy::
  initial_instances () const
  {
    return *initial_instances_;
  }

  void resourceLimitsQosPolicy::
  initial_instances (::XMLSchema::positiveInteger const& e)
  {
    if (initial_instances_)
    {
      *initial_instances_ = e;
    }

    else
    {
      initial_instances_ = std::make_unique<::XMLSchema::positiveInteger> (e);
    }
  }


  // timeBasedFilterQosPolicy

  timeBasedFilterQosPolicy::timeBasedFilterQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  timeBasedFilterQosPolicy::timeBasedFilterQosPolicy (timeBasedFilterQosPolicy const& s) :
  ::XSCRT::Type (s)
  , minimum_separation_ (s.minimum_separation_ ? std::make_unique<::dds::duration> (*s.minimum_separation_) : nullptr)
  {
  }

  timeBasedFilterQosPolicy&
  timeBasedFilterQosPolicy::operator= (timeBasedFilterQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.minimum_separation_)
        minimum_separation (*(s.minimum_separation_));
      else
        minimum_separation_.release ();
    }

    return *this;
  }


  // timeBasedFilterQosPolicy
  bool timeBasedFilterQosPolicy::
  minimum_separation_p () const
  {
    return !!minimum_separation_;
  }

  ::dds::duration const& timeBasedFilterQosPolicy::
  minimum_separation () const
  {
    return *minimum_separation_;
  }

  void timeBasedFilterQosPolicy::
  minimum_separation (::dds::duration const& e)
  {
    if (minimum_separation_)
    {
      *minimum_separation_ = e;
    }

    else
    {
      minimum_separation_ = std::make_unique<::dds::duration> (e);
    }
  }


  // topicDataQosPolicy

  topicDataQosPolicy::topicDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  topicDataQosPolicy::topicDataQosPolicy (topicDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.value_) : nullptr)
  {
  }

  topicDataQosPolicy&
  topicDataQosPolicy::operator= (topicDataQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // topicDataQosPolicy
  bool topicDataQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void topicDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // transportPriorityQosPolicy

  transportPriorityQosPolicy::transportPriorityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  transportPriorityQosPolicy::transportPriorityQosPolicy (transportPriorityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::XMLSchema::nonNegativeInteger> (*s.value_) : nullptr)
  {
  }

  transportPriorityQosPolicy&
  transportPriorityQosPolicy::operator= (transportPriorityQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // transportPriorityQosPolicy
  bool transportPriorityQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::XMLSchema::nonNegativeInteger const& transportPriorityQosPolicy::
  value () const
  {
    return *value_;
  }

  void transportPriorityQosPolicy::
  value (::XMLSchema::nonNegativeInteger const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::XMLSchema::nonNegativeInteger> (e);
    }
  }


  // userDataQosPolicy

  userDataQosPolicy::userDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  userDataQosPolicy::userDataQosPolicy (userDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.value_) : nullptr)
  {
  }

  userDataQosPolicy&
  userDataQosPolicy::operator= (userDataQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // userDataQosPolicy
  bool userDataQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& userDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void userDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // writerDataLifecycleQosPolicy

  writerDataLifecycleQosPolicy::writerDataLifecycleQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  writerDataLifecycleQosPolicy::writerDataLifecycleQosPolicy (writerDataLifecycleQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autodispose_unregistered_instances_ (s.autodispose_unregistered_instances_ ? std::make_unique<::XMLSchema::boolean> (*s.autodispose_unregistered_instances_) : nullptr)
  {
  }

  writerDataLifecycleQosPolicy&
  writerDataLifecycleQosPolicy::operator= (writerDataLifecycleQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.autodispose_unregistered_instances_)
        autodispose_unregistered_instances (*(s.autodispose_unregistered_instances_));
      else
        autodispose_unregistered_instances_.release ();
    }

    return *this;
  }


  // writerDataLifecycleQosPolicy
  bool writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances_p () const
  {
    return !!autodispose_unregistered_instances_;
  }

  ::XMLSchema::boolean const& writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances () const
  {
    return *autodispose_unregistered_instances_;
  }

  void writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances (::XMLSchema::boolean const& e)
  {
    if (autodispose_unregistered_instances_)
    {
      *autodispose_unregistered_instances_ = e;
    }

    else
    {
      autodispose_unregistered_instances_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }


  // dataRepresentationQosPolicy

  dataRepresentationQosPolicy::dataRepresentationQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  dataRepresentationQosPolicy::dataRepresentationQosPolicy (dataRepresentationQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_ ? std::make_unique<::dds::dataRepresentationIdSeq> (*s.value_) : nullptr)
  {
  }

  dataRepresentationQosPolicy&
  dataRepresentationQosPolicy::operator= (dataRepresentationQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.value_)
        value (*(s.value_));
      else
        value_.release ();
    }

    return *this;
  }


  // dataRepresentationQosPolicy
  bool dataRepresentationQosPolicy::
  value_p () const
  {
    return !!value_;
  }

  ::dds::dataRepresentationIdSeq const& dataRepresentationQosPolicy::
  value () const
  {
    return *value_;
  }

  void dataRepresentationQosPolicy::
  value (::dds::dataRepresentationIdSeq const& e)
  {
    if (value_)
    {
      *value_ = e;
    }

    else
    {
      value_ = std::make_unique<::dds::dataRepresentationIdSeq> (e);
    }
  }


  // typeConsistencyEnforcementQosPolicy

  typeConsistencyEnforcementQosPolicy::typeConsistencyEnforcementQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  typeConsistencyEnforcementQosPolicy::typeConsistencyEnforcementQosPolicy (typeConsistencyEnforcementQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_ ? std::make_unique<::dds::typeConsistencyKind> (*s.kind_) : nullptr)
  , ignore_sequence_bounds_ (s.ignore_sequence_bounds_ ? std::make_unique<::XMLSchema::boolean> (*s.ignore_sequence_bounds_) : nullptr)
  , ignore_string_bounds_ (s.ignore_string_bounds_ ? std::make_unique<::XMLSchema::boolean> (*s.ignore_string_bounds_) : nullptr)
  , ignore_member_names_ (s.ignore_member_names_ ? std::make_unique<::XMLSchema::boolean> (*s.ignore_member_names_) : nullptr)
  , prevent_type_widening_ (s.prevent_type_widening_ ? std::make_unique<::XMLSchema::boolean> (*s.prevent_type_widening_) : nullptr)
  , force_type_validation_ (s.force_type_validation_ ? std::make_unique<::XMLSchema::boolean> (*s.force_type_validation_) : nullptr)
  {
  }

  typeConsistencyEnforcementQosPolicy&
  typeConsistencyEnforcementQosPolicy::operator= (typeConsistencyEnforcementQosPolicy const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.kind_)
        kind (*(s.kind_));
      else
        kind_.release ();

      if (s.ignore_sequence_bounds_)
        ignore_sequence_bounds (*(s.ignore_sequence_bounds_));
      else
        ignore_sequence_bounds_.release ();

      if (s.ignore_string_bounds_)
        ignore_string_bounds (*(s.ignore_string_bounds_));
      else
        ignore_string_bounds_.release ();

      if (s.ignore_member_names_)
        ignore_member_names (*(s.ignore_member_names_));
      else
        ignore_member_names_.release ();

      if (s.prevent_type_widening_)
        prevent_type_widening (*(s.prevent_type_widening_));
      else
        prevent_type_widening_.release ();

      if (s.force_type_validation_)
        force_type_validation (*(s.force_type_validation_));
      else
        force_type_validation_.release ();
    }

    return *this;
  }


  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  kind_p () const
  {
    return !!kind_;
  }

  ::dds::typeConsistencyKind const& typeConsistencyEnforcementQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void typeConsistencyEnforcementQosPolicy::
  kind (::dds::typeConsistencyKind const& e)
  {
    if (kind_)
    {
      *kind_ = e;
    }

    else
    {
      kind_ = std::make_unique<::dds::typeConsistencyKind> (e);
    }
  }

  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  ignore_sequence_bounds_p () const
  {
    return !!ignore_sequence_bounds_;
  }

  ::XMLSchema::boolean const& typeConsistencyEnforcementQosPolicy::
  ignore_sequence_bounds () const
  {
    return *ignore_sequence_bounds_;
  }

  void typeConsistencyEnforcementQosPolicy::
  ignore_sequence_bounds (::XMLSchema::boolean const& e)
  {
    if (ignore_sequence_bounds_)
    {
      *ignore_sequence_bounds_ = e;
    }

    else
    {
      ignore_sequence_bounds_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }

  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  ignore_string_bounds_p () const
  {
    return !!ignore_string_bounds_;
  }

  ::XMLSchema::boolean const& typeConsistencyEnforcementQosPolicy::
  ignore_string_bounds () const
  {
    return *ignore_string_bounds_;
  }

  void typeConsistencyEnforcementQosPolicy::
  ignore_string_bounds (::XMLSchema::boolean const& e)
  {
    if (ignore_string_bounds_)
    {
      *ignore_string_bounds_ = e;
    }

    else
    {
      ignore_string_bounds_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }

  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  ignore_member_names_p () const
  {
    return !!ignore_member_names_;
  }

  ::XMLSchema::boolean const& typeConsistencyEnforcementQosPolicy::
  ignore_member_names () const
  {
    return *ignore_member_names_;
  }

  void typeConsistencyEnforcementQosPolicy::
  ignore_member_names (::XMLSchema::boolean const& e)
  {
    if (ignore_member_names_)
    {
      *ignore_member_names_ = e;
    }

    else
    {
      ignore_member_names_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }

  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  prevent_type_widening_p () const
  {
    return !!prevent_type_widening_;
  }

  ::XMLSchema::boolean const& typeConsistencyEnforcementQosPolicy::
  prevent_type_widening () const
  {
    return *prevent_type_widening_;
  }

  void typeConsistencyEnforcementQosPolicy::
  prevent_type_widening (::XMLSchema::boolean const& e)
  {
    if (prevent_type_widening_)
    {
      *prevent_type_widening_ = e;
    }

    else
    {
      prevent_type_widening_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }

  // typeConsistencyEnforcementQosPolicy
  bool typeConsistencyEnforcementQosPolicy::
  force_type_validation_p () const
  {
    return !!force_type_validation_;
  }

  ::XMLSchema::boolean const& typeConsistencyEnforcementQosPolicy::
  force_type_validation () const
  {
    return *force_type_validation_;
  }

  void typeConsistencyEnforcementQosPolicy::
  force_type_validation (::XMLSchema::boolean const& e)
  {
    if (force_type_validation_)
    {
      *force_type_validation_ = e;
    }

    else
    {
      force_type_validation_ = std::make_unique<::XMLSchema::boolean> (e);
    }
  }


  // domainparticipantQos

  domainparticipantQos::domainparticipantQos ()
  : ::XSCRT::Type ()
  {
  }

  domainparticipantQos::domainparticipantQos (domainparticipantQos const& s) :
  ::XSCRT::Type (s)
  , user_data_ (s.user_data_ ? std::make_unique<::dds::userDataQosPolicy> (*s.user_data_) : nullptr)
  , entity_factory_ (s.entity_factory_ ? std::make_unique<::dds::entityFactoryQosPolicy> (*s.entity_factory_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  {
  }

  domainparticipantQos&
  domainparticipantQos::operator= (domainparticipantQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.user_data_)
        user_data (*(s.user_data_));
      else
        user_data_.release ();

      if (s.entity_factory_)
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();
    }

    return *this;
  }


  // domainparticipantQos
  bool domainparticipantQos::
  user_data_p () const
  {
    return !!user_data_;
  }

  ::dds::userDataQosPolicy const& domainparticipantQos::
  user_data () const
  {
    return *user_data_;
  }

  void domainparticipantQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_)
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = std::make_unique<::dds::userDataQosPolicy> (e);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  entity_factory_p () const
  {
    return !!entity_factory_;
  }

  ::dds::entityFactoryQosPolicy const& domainparticipantQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void domainparticipantQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_)
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = std::make_unique<::dds::entityFactoryQosPolicy> (e);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& domainparticipantQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& domainparticipantQos::
  name ()
  {
    return *name_;
  }

  void domainparticipantQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& domainparticipantQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& domainparticipantQos::
  base_name ()
  {
    return *base_name_;
  }

  void domainparticipantQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // publisherQos

  publisherQos::publisherQos ()
  : ::XSCRT::Type ()
  {
  }

  publisherQos::publisherQos (publisherQos const& s) :
  ::XSCRT::Type (s)
  , presentation_ (s.presentation_ ? std::make_unique<::dds::presentationQosPolicy> (*s.presentation_) : nullptr)
  , partition_ (s.partition_ ? std::make_unique<::dds::partitionQosPolicy> (*s.partition_) : nullptr)
  , group_data_ (s.group_data_ ? std::make_unique<::dds::groupDataQosPolicy> (*s.group_data_) : nullptr)
  , entity_factory_ (s.entity_factory_ ? std::make_unique<::dds::entityFactoryQosPolicy> (*s.entity_factory_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  {
  }

  publisherQos&
  publisherQos::operator= (publisherQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.presentation_)
        presentation (*(s.presentation_));
      else
        presentation_.release ();

      if (s.partition_)
        partition (*(s.partition_));
      else
        partition_.release ();

      if (s.group_data_)
        group_data (*(s.group_data_));
      else
        group_data_.release ();

      if (s.entity_factory_)
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();
    }

    return *this;
  }


  // publisherQos
  bool publisherQos::
  presentation_p () const
  {
    return !!presentation_;
  }

  ::dds::presentationQosPolicy const& publisherQos::
  presentation () const
  {
    return *presentation_;
  }

  void publisherQos::
  presentation (::dds::presentationQosPolicy const& e)
  {
    if (presentation_)
    {
      *presentation_ = e;
    }

    else
    {
      presentation_ = std::make_unique<::dds::presentationQosPolicy> (e);
    }
  }

  // publisherQos
  bool publisherQos::
  partition_p () const
  {
    return !!partition_;
  }

  ::dds::partitionQosPolicy const& publisherQos::
  partition () const
  {
    return *partition_;
  }

  void publisherQos::
  partition (::dds::partitionQosPolicy const& e)
  {
    if (partition_)
    {
      *partition_ = e;
    }

    else
    {
      partition_ = std::make_unique<::dds::partitionQosPolicy> (e);
    }
  }

  // publisherQos
  bool publisherQos::
  group_data_p () const
  {
    return !!group_data_;
  }

  ::dds::groupDataQosPolicy const& publisherQos::
  group_data () const
  {
    return *group_data_;
  }

  void publisherQos::
  group_data (::dds::groupDataQosPolicy const& e)
  {
    if (group_data_)
    {
      *group_data_ = e;
    }

    else
    {
      group_data_ = std::make_unique<::dds::groupDataQosPolicy> (e);
    }
  }

  // publisherQos
  bool publisherQos::
  entity_factory_p () const
  {
    return !!entity_factory_;
  }

  ::dds::entityFactoryQosPolicy const& publisherQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void publisherQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_)
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = std::make_unique<::dds::entityFactoryQosPolicy> (e);
    }
  }

  // publisherQos
  bool publisherQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& publisherQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& publisherQos::
  name ()
  {
    return *name_;
  }

  void publisherQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // publisherQos
  bool publisherQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& publisherQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& publisherQos::
  base_name ()
  {
    return *base_name_;
  }

  void publisherQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // subscriberQos

  subscriberQos::subscriberQos ()
  : ::XSCRT::Type ()
  {
  }

  subscriberQos::subscriberQos (subscriberQos const& s) :
  ::XSCRT::Type (s)
  , presentation_ (s.presentation_ ? std::make_unique<::dds::presentationQosPolicy> (*s.presentation_) : nullptr)
  , partition_ (s.partition_ ? std::make_unique<::dds::partitionQosPolicy> (*s.partition_) : nullptr)
  , group_data_ (s.group_data_ ? std::make_unique<::dds::groupDataQosPolicy> (*s.group_data_) : nullptr)
  , entity_factory_ (s.entity_factory_ ? std::make_unique<::dds::entityFactoryQosPolicy> (*s.entity_factory_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  {
  }

  subscriberQos&
  subscriberQos::operator= (subscriberQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.presentation_)
        presentation (*(s.presentation_));
      else
        presentation_.release ();

      if (s.partition_)
        partition (*(s.partition_));
      else
        partition_.release ();

      if (s.group_data_)
        group_data (*(s.group_data_));
      else
        group_data_.release ();

      if (s.entity_factory_)
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();
    }

    return *this;
  }


  // subscriberQos
  bool subscriberQos::
  presentation_p () const
  {
    return !!presentation_;
  }

  ::dds::presentationQosPolicy const& subscriberQos::
  presentation () const
  {
    return *presentation_;
  }

  void subscriberQos::
  presentation (::dds::presentationQosPolicy const& e)
  {
    if (presentation_)
    {
      *presentation_ = e;
    }

    else
    {
      presentation_ = std::make_unique<::dds::presentationQosPolicy> (e);
    }
  }

  // subscriberQos
  bool subscriberQos::
  partition_p () const
  {
    return !!partition_;
  }

  ::dds::partitionQosPolicy const& subscriberQos::
  partition () const
  {
    return *partition_;
  }

  void subscriberQos::
  partition (::dds::partitionQosPolicy const& e)
  {
    if (partition_)
    {
      *partition_ = e;
    }

    else
    {
      partition_ = std::make_unique<::dds::partitionQosPolicy> (e);
    }
  }

  // subscriberQos
  bool subscriberQos::
  group_data_p () const
  {
    return !!group_data_;
  }

  ::dds::groupDataQosPolicy const& subscriberQos::
  group_data () const
  {
    return *group_data_;
  }

  void subscriberQos::
  group_data (::dds::groupDataQosPolicy const& e)
  {
    if (group_data_)
    {
      *group_data_ = e;
    }

    else
    {
      group_data_ = std::make_unique<::dds::groupDataQosPolicy> (e);
    }
  }

  // subscriberQos
  bool subscriberQos::
  entity_factory_p () const
  {
    return !!entity_factory_;
  }

  ::dds::entityFactoryQosPolicy const& subscriberQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void subscriberQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_)
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = std::make_unique<::dds::entityFactoryQosPolicy> (e);
    }
  }

  // subscriberQos
  bool subscriberQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& subscriberQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& subscriberQos::
  name ()
  {
    return *name_;
  }

  void subscriberQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // subscriberQos
  bool subscriberQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& subscriberQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& subscriberQos::
  base_name ()
  {
    return *base_name_;
  }

  void subscriberQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // topicQos

  topicQos::topicQos ()
  : ::XSCRT::Type ()
  {
  }

  topicQos::topicQos (topicQos const& s) :
  ::XSCRT::Type (s)
  , topic_data_ (s.topic_data_ ? std::make_unique<::dds::topicDataQosPolicy> (*s.topic_data_) : nullptr)
  , durability_ (s.durability_ ? std::make_unique<::dds::durabilityQosPolicy> (*s.durability_) : nullptr)
  , durability_service_ (s.durability_service_ ? std::make_unique<::dds::durabilityServiceQosPolicy> (*s.durability_service_) : nullptr)
  , deadline_ (s.deadline_ ? std::make_unique<::dds::deadlineQosPolicy> (*s.deadline_) : nullptr)
  , latency_budget_ (s.latency_budget_ ? std::make_unique<::dds::latencyBudgetQosPolicy> (*s.latency_budget_) : nullptr)
  , liveliness_ (s.liveliness_ ? std::make_unique<::dds::livelinessQosPolicy> (*s.liveliness_) : nullptr)
  , reliability_ (s.reliability_ ? std::make_unique<::dds::reliabilityQosPolicy> (*s.reliability_) : nullptr)
  , destination_order_ (s.destination_order_ ? std::make_unique<::dds::destinationOrderQosPolicy> (*s.destination_order_) : nullptr)
  , history_ (s.history_ ? std::make_unique<::dds::historyQosPolicy> (*s.history_) : nullptr)
  , resource_limits_ (s.resource_limits_ ? std::make_unique<::dds::resourceLimitsQosPolicy> (*s.resource_limits_) : nullptr)
  , transport_priority_ (s.transport_priority_ ? std::make_unique<::dds::transportPriorityQosPolicy> (*s.transport_priority_) : nullptr)
  , lifespan_ (s.lifespan_ ? std::make_unique<::dds::lifespanQosPolicy> (*s.lifespan_) : nullptr)
  , ownership_ (s.ownership_ ? std::make_unique<::dds::ownershipQosPolicy> (*s.ownership_) : nullptr)
  , representation_ (s.representation_ ? std::make_unique<::dds::dataRepresentationQosPolicy> (*s.representation_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  , topic_filter_ (s.topic_filter_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.topic_filter_) : nullptr)
  {
  }

  topicQos&
  topicQos::operator= (topicQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.topic_data_)
        topic_data (*(s.topic_data_));
      else
        topic_data_.release ();

      if (s.durability_)
        durability (*(s.durability_));
      else
        durability_.release ();

      if (s.durability_service_)
        durability_service (*(s.durability_service_));
      else
        durability_service_.release ();

      if (s.deadline_)
        deadline (*(s.deadline_));
      else
        deadline_.release ();

      if (s.latency_budget_)
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.release ();

      if (s.liveliness_)
        liveliness (*(s.liveliness_));
      else
        liveliness_.release ();

      if (s.reliability_)
        reliability (*(s.reliability_));
      else
        reliability_.release ();

      if (s.destination_order_)
        destination_order (*(s.destination_order_));
      else
        destination_order_.release ();

      if (s.history_)
        history (*(s.history_));
      else
        history_.release ();

      if (s.resource_limits_)
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.release ();

      if (s.transport_priority_)
        transport_priority (*(s.transport_priority_));
      else
        transport_priority_.release ();

      if (s.lifespan_)
        lifespan (*(s.lifespan_));
      else
        lifespan_.release ();

      if (s.ownership_)
        ownership (*(s.ownership_));
      else
        ownership_.release ();

      if (s.representation_)
        representation (*(s.representation_));
      else
        representation_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();

      if (s.topic_filter_) topic_filter (*(s.topic_filter_));
      else topic_filter_.release ();
    }

    return *this;
  }


  // topicQos
  bool topicQos::
  topic_data_p () const
  {
    return !!topic_data_;
  }

  ::dds::topicDataQosPolicy const& topicQos::
  topic_data () const
  {
    return *topic_data_;
  }

  void topicQos::
  topic_data (::dds::topicDataQosPolicy const& e)
  {
    if (topic_data_)
    {
      *topic_data_ = e;
    }

    else
    {
      topic_data_ = std::make_unique<::dds::topicDataQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  durability_p () const
  {
    return !!durability_;
  }

  ::dds::durabilityQosPolicy const& topicQos::
  durability () const
  {
    return *durability_;
  }

  void topicQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_)
    {
      *durability_ = e;
    }

    else
    {
      durability_ = std::make_unique<::dds::durabilityQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  durability_service_p () const
  {
    return !!durability_service_;
  }

  ::dds::durabilityServiceQosPolicy const& topicQos::
  durability_service () const
  {
    return *durability_service_;
  }

  void topicQos::
  durability_service (::dds::durabilityServiceQosPolicy const& e)
  {
    if (durability_service_)
    {
      *durability_service_ = e;
    }

    else
    {
      durability_service_ = std::make_unique<::dds::durabilityServiceQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  deadline_p () const
  {
    return !!deadline_;
  }

  ::dds::deadlineQosPolicy const& topicQos::
  deadline () const
  {
    return *deadline_;
  }

  void topicQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_)
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = std::make_unique<::dds::deadlineQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  latency_budget_p () const
  {
    return !!latency_budget_;
  }

  ::dds::latencyBudgetQosPolicy const& topicQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void topicQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_)
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = std::make_unique<::dds::latencyBudgetQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  liveliness_p () const
  {
    return !!liveliness_;
  }

  ::dds::livelinessQosPolicy const& topicQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void topicQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_)
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = std::make_unique<::dds::livelinessQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  reliability_p () const
  {
    return !!reliability_;
  }

  ::dds::reliabilityQosPolicy const& topicQos::
  reliability () const
  {
    return *reliability_;
  }

  void topicQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_)
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = std::make_unique<::dds::reliabilityQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  destination_order_p () const
  {
    return !!destination_order_;
  }

  ::dds::destinationOrderQosPolicy const& topicQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void topicQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_)
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = std::make_unique<::dds::destinationOrderQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  history_p () const
  {
    return !!history_;
  }

  ::dds::historyQosPolicy const& topicQos::
  history () const
  {
    return *history_;
  }

  void topicQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_)
    {
      *history_ = e;
    }

    else
    {
      history_ = std::make_unique<::dds::historyQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  resource_limits_p () const
  {
    return !!resource_limits_;
  }

  ::dds::resourceLimitsQosPolicy const& topicQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void topicQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_)
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = std::make_unique<::dds::resourceLimitsQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  transport_priority_p () const
  {
    return !!transport_priority_;
  }

  ::dds::transportPriorityQosPolicy const& topicQos::
  transport_priority () const
  {
    return *transport_priority_;
  }

  void topicQos::
  transport_priority (::dds::transportPriorityQosPolicy const& e)
  {
    if (transport_priority_)
    {
      *transport_priority_ = e;
    }

    else
    {
      transport_priority_ = std::make_unique<::dds::transportPriorityQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  lifespan_p () const
  {
    return !!lifespan_;
  }

  ::dds::lifespanQosPolicy const& topicQos::
  lifespan () const
  {
    return *lifespan_;
  }

  void topicQos::
  lifespan (::dds::lifespanQosPolicy const& e)
  {
    if (lifespan_)
    {
      *lifespan_ = e;
    }

    else
    {
      lifespan_ = std::make_unique<::dds::lifespanQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  ownership_p () const
  {
    return !!ownership_;
  }

  ::dds::ownershipQosPolicy const& topicQos::
  ownership () const
  {
    return *ownership_;
  }

  void topicQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_)
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = std::make_unique<::dds::ownershipQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  representation_p () const
  {
    return !!representation_;
  }

  ::dds::dataRepresentationQosPolicy const& topicQos::
  representation () const
  {
    return *representation_;
  }

  void topicQos::
  representation (::dds::dataRepresentationQosPolicy const& e)
  {
    if (representation_)
    {
      *representation_ = e;
    }

    else
    {
      representation_ = std::make_unique<::dds::dataRepresentationQosPolicy> (e);
    }
  }

  // topicQos
  bool topicQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  name ()
  {
    return *name_;
  }

  void topicQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // topicQos
  bool topicQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  base_name ()
  {
    return *base_name_;
  }

  void topicQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // topicQos
  bool topicQos::
  topic_filter_p () const
  {
    return !!topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void topicQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_)
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // datareaderQos

  datareaderQos::datareaderQos ()
  : ::XSCRT::Type ()
  {
  }

  datareaderQos::datareaderQos (datareaderQos const& s) :
  ::XSCRT::Type (s)
  , durability_ (s.durability_ ? std::make_unique<::dds::durabilityQosPolicy> (*s.durability_) : nullptr)
  , deadline_ (s.deadline_ ? std::make_unique<::dds::deadlineQosPolicy> (*s.deadline_) : nullptr)
  , latency_budget_ (s.latency_budget_ ? std::make_unique<::dds::latencyBudgetQosPolicy> (*s.latency_budget_) : nullptr)
  , liveliness_ (s.liveliness_ ? std::make_unique<::dds::livelinessQosPolicy> (*s.liveliness_) : nullptr)
  , reliability_ (s.reliability_ ? std::make_unique<::dds::reliabilityQosPolicy> (*s.reliability_) : nullptr)
  , destination_order_ (s.destination_order_ ? std::make_unique<::dds::destinationOrderQosPolicy> (*s.destination_order_) : nullptr)
  , history_ (s.history_ ? std::make_unique<::dds::historyQosPolicy> (*s.history_) : nullptr)
  , resource_limits_ (s.resource_limits_ ? std::make_unique<::dds::resourceLimitsQosPolicy> (*s.resource_limits_) : nullptr)
  , user_data_ (s.user_data_ ? std::make_unique<::dds::userDataQosPolicy> (*s.user_data_) : nullptr)
  , ownership_ (s.ownership_ ? std::make_unique<::dds::ownershipQosPolicy> (*s.ownership_) : nullptr)
  , time_based_filter_ (s.time_based_filter_ ? std::make_unique<::dds::timeBasedFilterQosPolicy> (*s.time_based_filter_) : nullptr)
  , reader_data_lifecycle_ (s.reader_data_lifecycle_ ? std::make_unique<::dds::readerDataLifecycleQosPolicy> (*s.reader_data_lifecycle_) : nullptr)
  , representation_ (s.representation_ ? std::make_unique<::dds::dataRepresentationQosPolicy> (*s.representation_) : nullptr)
  , type_consistency_ (s.type_consistency_ ? std::make_unique<::dds::typeConsistencyEnforcementQosPolicy> (*s.type_consistency_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  , topic_filter_ (s.topic_filter_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.topic_filter_) : nullptr)
  {
  }

  datareaderQos&
  datareaderQos::operator= (datareaderQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.durability_)
        durability (*(s.durability_));
      else
        durability_.release ();

      if (s.deadline_)
        deadline (*(s.deadline_));
      else
        deadline_.release ();

      if (s.latency_budget_)
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.release ();

      if (s.liveliness_)
        liveliness (*(s.liveliness_));
      else
        liveliness_.release ();

      if (s.reliability_)
        reliability (*(s.reliability_));
      else
        reliability_.release ();

      if (s.destination_order_)
        destination_order (*(s.destination_order_));
      else
        destination_order_.release ();

      if (s.history_)
        history (*(s.history_));
      else
        history_.release ();

      if (s.resource_limits_)
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.release ();

      if (s.user_data_)
        user_data (*(s.user_data_));
      else
        user_data_.release ();

      if (s.ownership_)
        ownership (*(s.ownership_));
      else
        ownership_.release ();

      if (s.time_based_filter_)
        time_based_filter (*(s.time_based_filter_));
      else
        time_based_filter_.release ();

      if (s.reader_data_lifecycle_)
        reader_data_lifecycle (*(s.reader_data_lifecycle_));
      else
        reader_data_lifecycle_.release ();

      if (s.representation_)
        representation (*(s.representation_));
      else
        representation_.release ();

      if (s.type_consistency_)
        type_consistency (*(s.type_consistency_));
      else
        type_consistency_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();

      if (s.topic_filter_) topic_filter (*(s.topic_filter_));
      else topic_filter_.release ();
    }

    return *this;
  }


  // datareaderQos
  bool datareaderQos::
  durability_p () const
  {
    return !!durability_;
  }

  ::dds::durabilityQosPolicy const& datareaderQos::
  durability () const
  {
    return *durability_;
  }

  void datareaderQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_)
    {
      *durability_ = e;
    }

    else
    {
      durability_ = std::make_unique<::dds::durabilityQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  deadline_p () const
  {
    return !!deadline_;
  }

  ::dds::deadlineQosPolicy const& datareaderQos::
  deadline () const
  {
    return *deadline_;
  }

  void datareaderQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_)
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = std::make_unique<::dds::deadlineQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  latency_budget_p () const
  {
    return !!latency_budget_;
  }

  ::dds::latencyBudgetQosPolicy const& datareaderQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void datareaderQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_)
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = std::make_unique<::dds::latencyBudgetQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  liveliness_p () const
  {
    return !!liveliness_;
  }

  ::dds::livelinessQosPolicy const& datareaderQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void datareaderQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_)
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = std::make_unique<::dds::livelinessQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  reliability_p () const
  {
    return !!reliability_;
  }

  ::dds::reliabilityQosPolicy const& datareaderQos::
  reliability () const
  {
    return *reliability_;
  }

  void datareaderQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_)
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = std::make_unique<::dds::reliabilityQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  destination_order_p () const
  {
    return !!destination_order_;
  }

  ::dds::destinationOrderQosPolicy const& datareaderQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void datareaderQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_)
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = std::make_unique<::dds::destinationOrderQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  history_p () const
  {
    return !!history_;
  }

  ::dds::historyQosPolicy const& datareaderQos::
  history () const
  {
    return *history_;
  }

  void datareaderQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_)
    {
      *history_ = e;
    }

    else
    {
      history_ = std::make_unique<::dds::historyQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  resource_limits_p () const
  {
    return !!resource_limits_;
  }

  ::dds::resourceLimitsQosPolicy const& datareaderQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void datareaderQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_)
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = std::make_unique<::dds::resourceLimitsQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  user_data_p () const
  {
    return !!user_data_;
  }

  ::dds::userDataQosPolicy const& datareaderQos::
  user_data () const
  {
    return *user_data_;
  }

  void datareaderQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_)
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = std::make_unique<::dds::userDataQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  ownership_p () const
  {
    return !!ownership_;
  }

  ::dds::ownershipQosPolicy const& datareaderQos::
  ownership () const
  {
    return *ownership_;
  }

  void datareaderQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_)
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = std::make_unique<::dds::ownershipQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  time_based_filter_p () const
  {
    return !!time_based_filter_;
  }

  ::dds::timeBasedFilterQosPolicy const& datareaderQos::
  time_based_filter () const
  {
    return *time_based_filter_;
  }

  void datareaderQos::
  time_based_filter (::dds::timeBasedFilterQosPolicy const& e)
  {
    if (time_based_filter_)
    {
      *time_based_filter_ = e;
    }

    else
    {
      time_based_filter_ = std::make_unique<::dds::timeBasedFilterQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  reader_data_lifecycle_p () const
  {
    return !!reader_data_lifecycle_;
  }

  ::dds::readerDataLifecycleQosPolicy const& datareaderQos::
  reader_data_lifecycle () const
  {
    return *reader_data_lifecycle_;
  }

  void datareaderQos::
  reader_data_lifecycle (::dds::readerDataLifecycleQosPolicy const& e)
  {
    if (reader_data_lifecycle_)
    {
      *reader_data_lifecycle_ = e;
    }

    else
    {
      reader_data_lifecycle_ = std::make_unique<::dds::readerDataLifecycleQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  representation_p () const
  {
    return !!representation_;
  }

  ::dds::dataRepresentationQosPolicy const& datareaderQos::
  representation () const
  {
    return *representation_;
  }

  void datareaderQos::
  representation (::dds::dataRepresentationQosPolicy const& e)
  {
    if (representation_)
    {
      *representation_ = e;
    }

    else
    {
      representation_ = std::make_unique<::dds::dataRepresentationQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  type_consistency_p () const
  {
    return !!type_consistency_;
  }

  ::dds::typeConsistencyEnforcementQosPolicy const& datareaderQos::
  type_consistency () const
  {
    return *type_consistency_;
  }

  void datareaderQos::
  type_consistency (::dds::typeConsistencyEnforcementQosPolicy const& e)
  {
    if (type_consistency_)
    {
      *type_consistency_ = e;
    }

    else
    {
      type_consistency_ = std::make_unique<::dds::typeConsistencyEnforcementQosPolicy> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  name ()
  {
    return *name_;
  }

  void datareaderQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  base_name ()
  {
    return *base_name_;
  }

  void datareaderQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // datareaderQos
  bool datareaderQos::
  topic_filter_p () const
  {
    return !!topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void datareaderQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_)
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // datawriterQos

  datawriterQos::datawriterQos ()
  : ::XSCRT::Type ()
  {
  }

  datawriterQos::datawriterQos (datawriterQos const& s) :
  ::XSCRT::Type (s)
  , durability_ (s.durability_ ? std::make_unique<::dds::durabilityQosPolicy> (*s.durability_) : nullptr)
  , durability_service_ (s.durability_service_ ? std::make_unique<::dds::durabilityServiceQosPolicy> (*s.durability_service_) : nullptr)
  , deadline_ (s.deadline_ ? std::make_unique<::dds::deadlineQosPolicy> (*s.deadline_) : nullptr)
  , latency_budget_ (s.latency_budget_ ? std::make_unique<::dds::latencyBudgetQosPolicy> (*s.latency_budget_) : nullptr)
  , liveliness_ (s.liveliness_ ? std::make_unique<::dds::livelinessQosPolicy> (*s.liveliness_) : nullptr)
  , reliability_ (s.reliability_ ? std::make_unique<::dds::reliabilityQosPolicy> (*s.reliability_) : nullptr)
  , destination_order_ (s.destination_order_ ? std::make_unique<::dds::destinationOrderQosPolicy> (*s.destination_order_) : nullptr)
  , history_ (s.history_ ? std::make_unique<::dds::historyQosPolicy> (*s.history_) : nullptr)
  , resource_limits_ (s.resource_limits_ ? std::make_unique<::dds::resourceLimitsQosPolicy> (*s.resource_limits_) : nullptr)
  , transport_priority_ (s.transport_priority_ ? std::make_unique<::dds::transportPriorityQosPolicy> (*s.transport_priority_) : nullptr)
  , lifespan_ (s.lifespan_ ? std::make_unique<::dds::lifespanQosPolicy> (*s.lifespan_) : nullptr)
  , user_data_ (s.user_data_ ? std::make_unique<::dds::userDataQosPolicy> (*s.user_data_) : nullptr)
  , ownership_ (s.ownership_ ? std::make_unique<::dds::ownershipQosPolicy> (*s.ownership_) : nullptr)
  , ownership_strength_ (s.ownership_strength_ ? std::make_unique<::dds::ownershipStrengthQosPolicy> (*s.ownership_strength_) : nullptr)
  , writer_data_lifecycle_ (s.writer_data_lifecycle_ ? std::make_unique<::dds::writerDataLifecycleQosPolicy> (*s.writer_data_lifecycle_) : nullptr)
  , representation_ (s.representation_ ? std::make_unique<::dds::dataRepresentationQosPolicy> (*s.representation_) : nullptr)
  , name_ (s.name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_) : nullptr)
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  , topic_filter_ (s.topic_filter_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.topic_filter_) : nullptr)
  {
  }

  datawriterQos&
  datawriterQos::operator= (datawriterQos const& s)
  {
    if (std::addressof(s) != this)
    {
      if (s.durability_)
        durability (*(s.durability_));
      else
        durability_.release ();

      if (s.durability_service_)
        durability_service (*(s.durability_service_));
      else
        durability_service_.release ();

      if (s.deadline_)
        deadline (*(s.deadline_));
      else
        deadline_.release ();

      if (s.latency_budget_)
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.release ();

      if (s.liveliness_)
        liveliness (*(s.liveliness_));
      else
        liveliness_.release ();

      if (s.reliability_)
        reliability (*(s.reliability_));
      else
        reliability_.release ();

      if (s.destination_order_)
        destination_order (*(s.destination_order_));
      else
        destination_order_.release ();

      if (s.history_)
        history (*(s.history_));
      else
        history_.release ();

      if (s.resource_limits_)
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.release ();

      if (s.transport_priority_)
        transport_priority (*(s.transport_priority_));
      else
        transport_priority_.release ();

      if (s.lifespan_)
        lifespan (*(s.lifespan_));
      else
        lifespan_.release ();

      if (s.user_data_)
        user_data (*(s.user_data_));
      else
        user_data_.release ();

      if (s.ownership_)
        ownership (*(s.ownership_));
      else
        ownership_.release ();

      if (s.ownership_strength_)
        ownership_strength (*(s.ownership_strength_));
      else
        ownership_strength_.release ();

      if (s.writer_data_lifecycle_)
        writer_data_lifecycle (*(s.writer_data_lifecycle_));
      else
        writer_data_lifecycle_.release ();

      if (s.representation_)
        representation (*(s.representation_));
      else
        representation_.release ();

      if (s.name_) name (*(s.name_));
      else name_.release ();

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();

      if (s.topic_filter_) topic_filter (*(s.topic_filter_));
      else topic_filter_.release ();
    }

    return *this;
  }


  // datawriterQos
  bool datawriterQos::
  durability_p () const
  {
    return !!durability_;
  }

  ::dds::durabilityQosPolicy const& datawriterQos::
  durability () const
  {
    return *durability_;
  }

  void datawriterQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_)
    {
      *durability_ = e;
    }

    else
    {
      durability_ = std::make_unique<::dds::durabilityQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  durability_service_p () const
  {
    return !!durability_service_;
  }

  ::dds::durabilityServiceQosPolicy const& datawriterQos::
  durability_service () const
  {
    return *durability_service_;
  }

  void datawriterQos::
  durability_service (::dds::durabilityServiceQosPolicy const& e)
  {
    if (durability_service_)
    {
      *durability_service_ = e;
    }

    else
    {
      durability_service_ = std::make_unique<::dds::durabilityServiceQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  deadline_p () const
  {
    return !!deadline_;
  }

  ::dds::deadlineQosPolicy const& datawriterQos::
  deadline () const
  {
    return *deadline_;
  }

  void datawriterQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_)
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = std::make_unique<::dds::deadlineQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  latency_budget_p () const
  {
    return !!latency_budget_;
  }

  ::dds::latencyBudgetQosPolicy const& datawriterQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void datawriterQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_)
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = std::make_unique<::dds::latencyBudgetQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  liveliness_p () const
  {
    return !!liveliness_;
  }

  ::dds::livelinessQosPolicy const& datawriterQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void datawriterQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_)
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = std::make_unique<::dds::livelinessQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  reliability_p () const
  {
    return !!reliability_;
  }

  ::dds::reliabilityQosPolicy const& datawriterQos::
  reliability () const
  {
    return *reliability_;
  }

  void datawriterQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_)
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = std::make_unique<::dds::reliabilityQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  destination_order_p () const
  {
    return !!destination_order_;
  }

  ::dds::destinationOrderQosPolicy const& datawriterQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void datawriterQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_)
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = std::make_unique<::dds::destinationOrderQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  history_p () const
  {
    return !!history_;
  }

  ::dds::historyQosPolicy const& datawriterQos::
  history () const
  {
    return *history_;
  }

  void datawriterQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_)
    {
      *history_ = e;
    }

    else
    {
      history_ = std::make_unique<::dds::historyQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  resource_limits_p () const
  {
    return !!resource_limits_;
  }

  ::dds::resourceLimitsQosPolicy const& datawriterQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void datawriterQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_)
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = std::make_unique<::dds::resourceLimitsQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  transport_priority_p () const
  {
    return !!transport_priority_;
  }

  ::dds::transportPriorityQosPolicy const& datawriterQos::
  transport_priority () const
  {
    return *transport_priority_;
  }

  void datawriterQos::
  transport_priority (::dds::transportPriorityQosPolicy const& e)
  {
    if (transport_priority_)
    {
      *transport_priority_ = e;
    }

    else
    {
      transport_priority_ = std::make_unique<::dds::transportPriorityQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  lifespan_p () const
  {
    return !!lifespan_;
  }

  ::dds::lifespanQosPolicy const& datawriterQos::
  lifespan () const
  {
    return *lifespan_;
  }

  void datawriterQos::
  lifespan (::dds::lifespanQosPolicy const& e)
  {
    if (lifespan_)
    {
      *lifespan_ = e;
    }

    else
    {
      lifespan_ = std::make_unique<::dds::lifespanQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  user_data_p () const
  {
    return !!user_data_;
  }

  ::dds::userDataQosPolicy const& datawriterQos::
  user_data () const
  {
    return *user_data_;
  }

  void datawriterQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_)
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = std::make_unique<::dds::userDataQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  ownership_p () const
  {
    return !!ownership_;
  }

  ::dds::ownershipQosPolicy const& datawriterQos::
  ownership () const
  {
    return *ownership_;
  }

  void datawriterQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_)
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = std::make_unique<::dds::ownershipQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  ownership_strength_p () const
  {
    return !!ownership_strength_;
  }

  ::dds::ownershipStrengthQosPolicy const& datawriterQos::
  ownership_strength () const
  {
    return *ownership_strength_;
  }

  void datawriterQos::
  ownership_strength (::dds::ownershipStrengthQosPolicy const& e)
  {
    if (ownership_strength_)
    {
      *ownership_strength_ = e;
    }

    else
    {
      ownership_strength_ = std::make_unique<::dds::ownershipStrengthQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  writer_data_lifecycle_p () const
  {
    return !!writer_data_lifecycle_;
  }

  ::dds::writerDataLifecycleQosPolicy const& datawriterQos::
  writer_data_lifecycle () const
  {
    return *writer_data_lifecycle_;
  }

  void datawriterQos::
  writer_data_lifecycle (::dds::writerDataLifecycleQosPolicy const& e)
  {
    if (writer_data_lifecycle_)
    {
      *writer_data_lifecycle_ = e;
    }

    else
    {
      writer_data_lifecycle_ = std::make_unique<::dds::writerDataLifecycleQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  representation_p () const
  {
    return !!representation_;
  }

  ::dds::dataRepresentationQosPolicy const& datawriterQos::
  representation () const
  {
    return *representation_;
  }

  void datawriterQos::
  representation (::dds::dataRepresentationQosPolicy const& e)
  {
    if (representation_)
    {
      *representation_ = e;
    }

    else
    {
      representation_ = std::make_unique<::dds::dataRepresentationQosPolicy> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  name_p () const
  {
    return !!name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  name ()
  {
    return *name_;
  }

  void datawriterQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_)
    {
      *name_ = e;
    }

    else
    {
      name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  base_name ()
  {
    return *base_name_;
  }

  void datawriterQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }

  // datawriterQos
  bool datawriterQos::
  topic_filter_p () const
  {
    return !!topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void datawriterQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_)
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // qosProfile

  qosProfile::qosProfile (::XMLSchema::string<ACE_TCHAR> const& name__)
  : ::XSCRT::Type ()
  , name_ (std::make_unique<::XMLSchema::string<ACE_TCHAR>> (name__))
  {
  }

  qosProfile::qosProfile (qosProfile const& s) :
  ::XSCRT::Type (s)
  , datareader_qos_ (s.datareader_qos_)
  , datawriter_qos_ (s.datawriter_qos_)
  , topic_qos_ (s.topic_qos_)
  , domainparticipant_qos_ (s.domainparticipant_qos_)
  , publisher_qos_ (s.publisher_qos_)
  , subscriber_qos_ (s.subscriber_qos_)
  , name_ (std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.name_))
  , base_name_ (s.base_name_ ? std::make_unique<::XMLSchema::string<ACE_TCHAR>> (*s.base_name_) : nullptr)
  {
  }

  qosProfile&
  qosProfile::operator= (qosProfile const& s)
  {
    if (std::addressof(s) != this)
    {
      datareader_qos_ = s.datareader_qos_;

      datawriter_qos_ = s.datawriter_qos_;

      topic_qos_ = s.topic_qos_;

      domainparticipant_qos_ = s.domainparticipant_qos_;

      publisher_qos_ = s.publisher_qos_;

      subscriber_qos_ = s.subscriber_qos_;

      name (s.name ());

      if (s.base_name_) base_name (*(s.base_name_));
      else base_name_.release ();
    }

    return *this;
  }


  // qosProfile
  qosProfile::datareader_qos_const_iterator qosProfile::
  begin_datareader_qos () const
  {
    return datareader_qos_.cbegin ();
  }

  qosProfile::datareader_qos_const_iterator qosProfile::
  end_datareader_qos () const
  {
    return datareader_qos_.cend ();
  }

  size_t qosProfile::
  count_datareader_qos() const
  {
    return datareader_qos_.size ();
  }

  // qosProfile
  qosProfile::datawriter_qos_const_iterator qosProfile::
  begin_datawriter_qos () const
  {
    return datawriter_qos_.cbegin ();
  }

  qosProfile::datawriter_qos_const_iterator qosProfile::
  end_datawriter_qos () const
  {
    return datawriter_qos_.cend ();
  }

  size_t qosProfile::
  count_datawriter_qos() const
  {
    return datawriter_qos_.size ();
  }

  // qosProfile
  qosProfile::topic_qos_const_iterator qosProfile::
  begin_topic_qos () const
  {
    return topic_qos_.cbegin ();
  }

  qosProfile::topic_qos_const_iterator qosProfile::
  end_topic_qos () const
  {
    return topic_qos_.cend ();
  }

  size_t qosProfile::
  count_topic_qos() const
  {
    return topic_qos_.size ();
  }

  // qosProfile
  qosProfile::domainparticipant_qos_const_iterator qosProfile::
  begin_domainparticipant_qos () const
  {
    return domainparticipant_qos_.cbegin ();
  }

  qosProfile::domainparticipant_qos_const_iterator qosProfile::
  end_domainparticipant_qos () const
  {
    return domainparticipant_qos_.cend ();
  }

  size_t qosProfile::
  count_domainparticipant_qos() const
  {
    return domainparticipant_qos_.size ();
  }

  // qosProfile
  qosProfile::publisher_qos_const_iterator qosProfile::
  begin_publisher_qos () const
  {
    return publisher_qos_.cbegin ();
  }

  qosProfile::publisher_qos_const_iterator qosProfile::
  end_publisher_qos () const
  {
    return publisher_qos_.cend ();
  }

  size_t qosProfile::
  count_publisher_qos() const
  {
    return publisher_qos_.size ();
  }

  // qosProfile
  qosProfile::subscriber_qos_const_iterator qosProfile::
  begin_subscriber_qos () const
  {
    return subscriber_qos_.cbegin ();
  }

  qosProfile::subscriber_qos_const_iterator qosProfile::
  end_subscriber_qos () const
  {
    return subscriber_qos_.cend ();
  }

  size_t qosProfile::
  count_subscriber_qos() const
  {
    return subscriber_qos_.size ();
  }

  // qosProfile
  ::XMLSchema::string<ACE_TCHAR> const& qosProfile::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& qosProfile::
  name ()
  {
    return *name_;
  }

  void qosProfile::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    *name_ = e;
  }

  // qosProfile
  bool qosProfile::
  base_name_p () const
  {
    return !!base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR> const& qosProfile::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& qosProfile::
  base_name ()
  {
    return *base_name_;
  }

  void qosProfile::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_)
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (e);
    }
  }


  // qosProfile_seq

  qosProfile_seq::qosProfile_seq ()
  : ::XSCRT::Type ()
  {
  }

  qosProfile_seq::qosProfile_seq (qosProfile_seq const& s) :
  ::XSCRT::Type (s)
  , qos_profile_ (s.qos_profile_)
  {
  }

  qosProfile_seq&
  qosProfile_seq::operator= (qosProfile_seq const& s)
  {
    if (std::addressof(s) != this)
    {
      qos_profile_ = s.qos_profile_;
    }

    return *this;
  }


  // qosProfile_seq
  qosProfile_seq::qos_profile_const_iterator qosProfile_seq::
  begin_qos_profile () const
  {
    return qos_profile_.cbegin ();
  }

  qosProfile_seq::qos_profile_const_iterator qosProfile_seq::
  end_qos_profile () const
  {
    return qos_profile_.cend ();
  }

  size_t qosProfile_seq::
  count_qos_profile() const
  {
    return qos_profile_.size ();
  }
}

namespace dds
{
  // destinationOrderKind

  destinationOrderKind::
  destinationOrderKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else if (v == ACE_TEXT ("BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else
    {
    }
  }

  destinationOrderKind::
  destinationOrderKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else if (v == ACE_TEXT ("BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else
    {
    }
  }

  destinationOrderKind const destinationOrderKind::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS (destinationOrderKind::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l);
  destinationOrderKind const destinationOrderKind::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS (destinationOrderKind::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l);

  // durabilityKind

  durabilityKind::
  durabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("VOLATILE_DURABILITY_QOS")) v_ = VOLATILE_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_LOCAL_DURABILITY_QOS")) v_ = TRANSIENT_LOCAL_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_DURABILITY_QOS")) v_ = TRANSIENT_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("PERSISTENT_DURABILITY_QOS")) v_ = PERSISTENT_DURABILITY_QOS_l;
    else
    {
    }
  }

  durabilityKind::
  durabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("VOLATILE_DURABILITY_QOS")) v_ = VOLATILE_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_LOCAL_DURABILITY_QOS")) v_ = TRANSIENT_LOCAL_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_DURABILITY_QOS")) v_ = TRANSIENT_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("PERSISTENT_DURABILITY_QOS")) v_ = PERSISTENT_DURABILITY_QOS_l;
    else
    {
    }
  }

  durabilityKind const durabilityKind::VOLATILE_DURABILITY_QOS (durabilityKind::VOLATILE_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::TRANSIENT_LOCAL_DURABILITY_QOS (durabilityKind::TRANSIENT_LOCAL_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::TRANSIENT_DURABILITY_QOS (durabilityKind::TRANSIENT_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::PERSISTENT_DURABILITY_QOS (durabilityKind::PERSISTENT_DURABILITY_QOS_l);

  // historyKind

  historyKind::
  historyKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("KEEP_LAST_HISTORY_QOS")) v_ = KEEP_LAST_HISTORY_QOS_l;
    else if (v == ACE_TEXT ("KEEP_ALL_HISTORY_QOS")) v_ = KEEP_ALL_HISTORY_QOS_l;
    else
    {
    }
  }

  historyKind::
  historyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("KEEP_LAST_HISTORY_QOS")) v_ = KEEP_LAST_HISTORY_QOS_l;
    else if (v == ACE_TEXT ("KEEP_ALL_HISTORY_QOS")) v_ = KEEP_ALL_HISTORY_QOS_l;
    else
    {
    }
  }

  historyKind const historyKind::KEEP_LAST_HISTORY_QOS (historyKind::KEEP_LAST_HISTORY_QOS_l);
  historyKind const historyKind::KEEP_ALL_HISTORY_QOS (historyKind::KEEP_ALL_HISTORY_QOS_l);

  // livelinessKind

  livelinessKind::
  livelinessKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("AUTOMATIC_LIVELINESS_QOS")) v_ = AUTOMATIC_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_PARTICIPANT_LIVELINESS_QOS")) v_ = MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_TOPIC_LIVELINESS_QOS")) v_ = MANUAL_BY_TOPIC_LIVELINESS_QOS_l;
    else
    {
    }
  }

  livelinessKind::
  livelinessKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("AUTOMATIC_LIVELINESS_QOS")) v_ = AUTOMATIC_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_PARTICIPANT_LIVELINESS_QOS")) v_ = MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_TOPIC_LIVELINESS_QOS")) v_ = MANUAL_BY_TOPIC_LIVELINESS_QOS_l;
    else
    {
    }
  }

  livelinessKind const livelinessKind::AUTOMATIC_LIVELINESS_QOS (livelinessKind::AUTOMATIC_LIVELINESS_QOS_l);
  livelinessKind const livelinessKind::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS (livelinessKind::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l);
  livelinessKind const livelinessKind::MANUAL_BY_TOPIC_LIVELINESS_QOS (livelinessKind::MANUAL_BY_TOPIC_LIVELINESS_QOS_l);

  // presentationAccessScopeKind

  presentationAccessScopeKind::
  presentationAccessScopeKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("INSTANCE_PRESENTATION_QOS")) v_ = INSTANCE_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("TOPIC_PRESENTATION_QOS")) v_ = TOPIC_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("GROUP_PRESENTATION_QOS")) v_ = GROUP_PRESENTATION_QOS_l;
    else
    {
    }
  }

  presentationAccessScopeKind::
  presentationAccessScopeKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("INSTANCE_PRESENTATION_QOS")) v_ = INSTANCE_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("TOPIC_PRESENTATION_QOS")) v_ = TOPIC_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("GROUP_PRESENTATION_QOS")) v_ = GROUP_PRESENTATION_QOS_l;
    else
    {
    }
  }

  presentationAccessScopeKind const presentationAccessScopeKind::INSTANCE_PRESENTATION_QOS (presentationAccessScopeKind::INSTANCE_PRESENTATION_QOS_l);
  presentationAccessScopeKind const presentationAccessScopeKind::TOPIC_PRESENTATION_QOS (presentationAccessScopeKind::TOPIC_PRESENTATION_QOS_l);
  presentationAccessScopeKind const presentationAccessScopeKind::GROUP_PRESENTATION_QOS (presentationAccessScopeKind::GROUP_PRESENTATION_QOS_l);

  // reliabilityKind

  reliabilityKind::
  reliabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("BEST_EFFORT_RELIABILITY_QOS")) v_ = BEST_EFFORT_RELIABILITY_QOS_l;
    else if (v == ACE_TEXT ("RELIABLE_RELIABILITY_QOS")) v_ = RELIABLE_RELIABILITY_QOS_l;
    else
    {
    }
  }

  reliabilityKind::
  reliabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("BEST_EFFORT_RELIABILITY_QOS")) v_ = BEST_EFFORT_RELIABILITY_QOS_l;
    else if (v == ACE_TEXT ("RELIABLE_RELIABILITY_QOS")) v_ = RELIABLE_RELIABILITY_QOS_l;
    else
    {
    }
  }

  reliabilityKind const reliabilityKind::BEST_EFFORT_RELIABILITY_QOS (reliabilityKind::BEST_EFFORT_RELIABILITY_QOS_l);
  reliabilityKind const reliabilityKind::RELIABLE_RELIABILITY_QOS (reliabilityKind::RELIABLE_RELIABILITY_QOS_l);

  // ownershipKind

  ownershipKind::
  ownershipKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("SHARED_OWNERSHIP_QOS")) v_ = SHARED_OWNERSHIP_QOS_l;
    else if (v == ACE_TEXT ("EXCLUSIVE_OWNERSHIP_QOS")) v_ = EXCLUSIVE_OWNERSHIP_QOS_l;
    else
    {
    }
  }

  ownershipKind::
  ownershipKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("SHARED_OWNERSHIP_QOS")) v_ = SHARED_OWNERSHIP_QOS_l;
    else if (v == ACE_TEXT ("EXCLUSIVE_OWNERSHIP_QOS")) v_ = EXCLUSIVE_OWNERSHIP_QOS_l;
    else
    {
    }
  }

  ownershipKind const ownershipKind::SHARED_OWNERSHIP_QOS (ownershipKind::SHARED_OWNERSHIP_QOS_l);
  ownershipKind const ownershipKind::EXCLUSIVE_OWNERSHIP_QOS (ownershipKind::EXCLUSIVE_OWNERSHIP_QOS_l);

  // dataRepresentationIdKind

  dataRepresentationIdKind::
  dataRepresentationIdKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("XCDR_DATA_REPRESENTATION")) v_ = XCDR_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("XML_DATA_REPRESENTATION")) v_ = XML_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("XCDR2_DATA_REPRESENTATION")) v_ = XCDR2_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("UNALIGNED_CDR_DATA_REPRESENTATION")) v_ = UNALIGNED_CDR_DATA_REPRESENTATION_l;
    else
    {
    }
  }

  dataRepresentationIdKind::
  dataRepresentationIdKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("XCDR_DATA_REPRESENTATION")) v_ = XCDR_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("XML_DATA_REPRESENTATION")) v_ = XML_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("XCDR2_DATA_REPRESENTATION")) v_ = XCDR2_DATA_REPRESENTATION_l;
    else if (v == ACE_TEXT ("UNALIGNED_CDR_DATA_REPRESENTATION")) v_ = UNALIGNED_CDR_DATA_REPRESENTATION_l;
    else
    {
    }
  }

  dataRepresentationIdKind const dataRepresentationIdKind::XCDR_DATA_REPRESENTATION (dataRepresentationIdKind::XCDR_DATA_REPRESENTATION_l);
  dataRepresentationIdKind const dataRepresentationIdKind::XML_DATA_REPRESENTATION (dataRepresentationIdKind::XML_DATA_REPRESENTATION_l);
  dataRepresentationIdKind const dataRepresentationIdKind::XCDR2_DATA_REPRESENTATION (dataRepresentationIdKind::XCDR2_DATA_REPRESENTATION_l);
  dataRepresentationIdKind const dataRepresentationIdKind::UNALIGNED_CDR_DATA_REPRESENTATION (dataRepresentationIdKind::UNALIGNED_CDR_DATA_REPRESENTATION_l);

  // typeConsistencyKind

  typeConsistencyKind::
  typeConsistencyKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("DISALLOW_TYPE_COERCION")) v_ = DISALLOW_TYPE_COERCION_l;
    else if (v == ACE_TEXT ("ALLOW_TYPE_COERCION")) v_ = ALLOW_TYPE_COERCION_l;
    else
    {
    }
  }

  typeConsistencyKind::
  typeConsistencyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("DISALLOW_TYPE_COERCION")) v_ = DISALLOW_TYPE_COERCION_l;
    else if (v == ACE_TEXT ("ALLOW_TYPE_COERCION")) v_ = ALLOW_TYPE_COERCION_l;
    else
    {
    }
  }

  typeConsistencyKind const typeConsistencyKind::DISALLOW_TYPE_COERCION (typeConsistencyKind::DISALLOW_TYPE_COERCION_l);
  typeConsistencyKind const typeConsistencyKind::ALLOW_TYPE_COERCION (typeConsistencyKind::ALLOW_TYPE_COERCION_l);

  // duration

  duration::
  duration (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("sec"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        sec (t);
      }

      else if (n == ACE_TEXT("nanosec"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        nanosec (t);
      }

      else
      {
      }
    }
  }

  // stringSeq

  stringSeq::
  stringSeq (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("element"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        element_.push_back (t);
      }

      else
      {
      }
    }
  }

  // dataRepresentationIdSeq

  dataRepresentationIdSeq::
  dataRepresentationIdSeq (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("element"))
      {
        ::dds::dataRepresentationIdKind t (e);
        element_.push_back (t);
      }

      else
      {
      }
    }
  }

  // deadlineQosPolicy

  deadlineQosPolicy::
  deadlineQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("period"))
      {
        ::dds::duration t (e);
        period (t);
      }

      else
      {
      }
    }
  }

  // destinationOrderQosPolicy

  destinationOrderQosPolicy::
  destinationOrderQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::destinationOrderKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // durabilityQosPolicy

  durabilityQosPolicy::
  durabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::durabilityKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // durabilityServiceQosPolicy

  durabilityServiceQosPolicy::
  durabilityServiceQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("service_cleanup_delay"))
      {
        ::dds::duration t (e);
        service_cleanup_delay (t);
      }

      else if (n == ACE_TEXT("history_kind"))
      {
        ::dds::historyKind t (e);
        history_kind (t);
      }

      else if (n == ACE_TEXT("history_depth"))
      {
        ::XMLSchema::positiveInteger t (e);
        history_depth (t);
      }

      else if (n == ACE_TEXT("max_samples"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples (t);
      }

      else if (n == ACE_TEXT("max_instances"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_instances (t);
      }

      else if (n == ACE_TEXT("max_samples_per_instance"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples_per_instance (t);
      }

      else
      {
      }
    }
  }

  // entityFactoryQosPolicy

  entityFactoryQosPolicy::
  entityFactoryQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autoenable_created_entities"))
      {
        ::XMLSchema::boolean t (e);
        autoenable_created_entities (t);
      }

      else
      {
      }
    }
  }

  // groupDataQosPolicy

  groupDataQosPolicy::
  groupDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // historyQosPolicy

  historyQosPolicy::
  historyQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::historyKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("depth"))
      {
        ::XMLSchema::positiveInteger t (e);
        depth (t);
      }

      else
      {
      }
    }
  }

  // latencyBudgetQosPolicy

  latencyBudgetQosPolicy::
  latencyBudgetQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("duration"))
      {
        ::dds::duration t (e);
        duration (t);
      }

      else
      {
      }
    }
  }

  // lifespanQosPolicy

  lifespanQosPolicy::
  lifespanQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("duration"))
      {
        ::dds::duration t (e);
        duration (t);
      }

      else
      {
      }
    }
  }

  // livelinessQosPolicy

  livelinessQosPolicy::
  livelinessQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::livelinessKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("lease_duration"))
      {
        ::dds::duration t (e);
        lease_duration (t);
      }

      else
      {
      }
    }
  }

  // ownershipQosPolicy

  ownershipQosPolicy::
  ownershipQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::ownershipKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // ownershipStrengthQosPolicy

  ownershipStrengthQosPolicy::
  ownershipStrengthQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::nonNegativeInteger t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // partitionQosPolicy

  partitionQosPolicy::
  partitionQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("name"))
      {
        ::dds::stringSeq t (e);
        name (t);
      }

      else
      {
      }
    }
  }

  // presentationQosPolicy

  presentationQosPolicy::
  presentationQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("access_scope"))
      {
        ::dds::presentationAccessScopeKind t (e);
        access_scope (t);
      }

      else if (n == ACE_TEXT("coherent_access"))
      {
        ::XMLSchema::boolean t (e);
        coherent_access (t);
      }

      else if (n == ACE_TEXT("ordered_access"))
      {
        ::XMLSchema::boolean t (e);
        ordered_access (t);
      }

      else
      {
      }
    }
  }

  // readerDataLifecycleQosPolicy

  readerDataLifecycleQosPolicy::
  readerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autopurge_nowriter_samples_delay"))
      {
        ::dds::duration t (e);
        autopurge_nowriter_samples_delay (t);
      }

      else if (n == ACE_TEXT("autopurge_disposed_samples_delay"))
      {
        ::dds::duration t (e);
        autopurge_disposed_samples_delay (t);
      }

      else
      {
      }
    }
  }

  // reliabilityQosPolicy

  reliabilityQosPolicy::
  reliabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::reliabilityKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("max_blocking_time"))
      {
        ::dds::duration t (e);
        max_blocking_time (t);
      }

      else
      {
      }
    }
  }

  // resourceLimitsQosPolicy

  resourceLimitsQosPolicy::
  resourceLimitsQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("max_samples"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples (t);
      }

      else if (n == ACE_TEXT("max_instances"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_instances (t);
      }

      else if (n == ACE_TEXT("max_samples_per_instance"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples_per_instance (t);
      }

      else if (n == ACE_TEXT("initial_samples"))
      {
        ::XMLSchema::positiveInteger t (e);
        initial_samples (t);
      }

      else if (n == ACE_TEXT("initial_instances"))
      {
        ::XMLSchema::positiveInteger t (e);
        initial_instances (t);
      }

      else
      {
      }
    }
  }

  // timeBasedFilterQosPolicy

  timeBasedFilterQosPolicy::
  timeBasedFilterQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("minimum_separation"))
      {
        ::dds::duration t (e);
        minimum_separation (t);
      }

      else
      {
      }
    }
  }

  // topicDataQosPolicy

  topicDataQosPolicy::
  topicDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // transportPriorityQosPolicy

  transportPriorityQosPolicy::
  transportPriorityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::nonNegativeInteger t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // userDataQosPolicy

  userDataQosPolicy::
  userDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // writerDataLifecycleQosPolicy

  writerDataLifecycleQosPolicy::
  writerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autodispose_unregistered_instances"))
      {
        ::XMLSchema::boolean t (e);
        autodispose_unregistered_instances (t);
      }

      else
      {
      }
    }
  }

  // dataRepresentationQosPolicy

  dataRepresentationQosPolicy::
  dataRepresentationQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::dds::dataRepresentationIdSeq t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // typeConsistencyEnforcementQosPolicy

  typeConsistencyEnforcementQosPolicy::
  typeConsistencyEnforcementQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::typeConsistencyKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("ignore_sequence_bounds"))
      {
        ::XMLSchema::boolean t (e);
        ignore_sequence_bounds (t);
      }

      else if (n == ACE_TEXT("ignore_string_bounds"))
      {
        ::XMLSchema::boolean t (e);
        ignore_string_bounds (t);
      }

      else if (n == ACE_TEXT("ignore_member_names"))
      {
        ::XMLSchema::boolean t (e);
        ignore_member_names (t);
      }

      else if (n == ACE_TEXT("prevent_type_widening"))
      {
        ::XMLSchema::boolean t (e);
        prevent_type_widening (t);
      }

      else if (n == ACE_TEXT("force_type_validation"))
      {
        ::XMLSchema::boolean t (e);
        force_type_validation (t);
      }

      else
      {
      }
    }
  }

  // domainparticipantQos

  domainparticipantQos::
  domainparticipantQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // publisherQos

  publisherQos::
  publisherQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("presentation"))
      {
        ::dds::presentationQosPolicy t (e);
        presentation (t);
      }

      else if (n == ACE_TEXT("partition"))
      {
        ::dds::partitionQosPolicy t (e);
        partition (t);
      }

      else if (n == ACE_TEXT("group_data"))
      {
        ::dds::groupDataQosPolicy t (e);
        group_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // subscriberQos

  subscriberQos::
  subscriberQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("presentation"))
      {
        ::dds::presentationQosPolicy t (e);
        presentation (t);
      }

      else if (n == ACE_TEXT("partition"))
      {
        ::dds::partitionQosPolicy t (e);
        partition (t);
      }

      else if (n == ACE_TEXT("group_data"))
      {
        ::dds::groupDataQosPolicy t (e);
        group_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // topicQos

  topicQos::
  topicQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("topic_data"))
      {
        ::dds::topicDataQosPolicy t (e);
        topic_data (t);
      }

      else if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("durability_service"))
      {
        ::dds::durabilityServiceQosPolicy t (e);
        durability_service (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("transport_priority"))
      {
        ::dds::transportPriorityQosPolicy t (e);
        transport_priority (t);
      }

      else if (n == ACE_TEXT("lifespan"))
      {
        ::dds::lifespanQosPolicy t (e);
        lifespan (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else if (n == ACE_TEXT("representation"))
      {
        ::dds::dataRepresentationQosPolicy t (e);
        representation (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // datareaderQos

  datareaderQos::
  datareaderQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else if (n == ACE_TEXT("time_based_filter"))
      {
        ::dds::timeBasedFilterQosPolicy t (e);
        time_based_filter (t);
      }

      else if (n == ACE_TEXT("reader_data_lifecycle"))
      {
        ::dds::readerDataLifecycleQosPolicy t (e);
        reader_data_lifecycle (t);
      }

      else if (n == ACE_TEXT("representation"))
      {
        ::dds::dataRepresentationQosPolicy t (e);
        representation (t);
      }

      else if (n == ACE_TEXT("type_consistency"))
      {
        ::dds::typeConsistencyEnforcementQosPolicy t (e);
        type_consistency (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // datawriterQos

  datawriterQos::
  datawriterQos (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("durability_service"))
      {
        ::dds::durabilityServiceQosPolicy t (e);
        durability_service (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("transport_priority"))
      {
        ::dds::transportPriorityQosPolicy t (e);
        transport_priority (t);
      }

      else if (n == ACE_TEXT("lifespan"))
      {
        ::dds::lifespanQosPolicy t (e);
        lifespan (t);
      }

      else if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else if (n == ACE_TEXT("ownership_strength"))
      {
        ::dds::ownershipStrengthQosPolicy t (e);
        ownership_strength (t);
      }

      else if (n == ACE_TEXT("writer_data_lifecycle"))
      {
        ::dds::writerDataLifecycleQosPolicy t (e);
        writer_data_lifecycle (t);
      }

      else if (n == ACE_TEXT("representation"))
      {
        ::dds::dataRepresentationQosPolicy t (e);
        representation (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // qosProfile

  qosProfile::
  qosProfile (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("datareader_qos"))
      {
        ::dds::datareaderQos t (e);
        datareader_qos_.push_back (t);
      }

      else if (n == ACE_TEXT("datawriter_qos"))
      {
        ::dds::datawriterQos t (e);
        datawriter_qos_.push_back (t);
      }

      else if (n == ACE_TEXT("topic_qos"))
      {
        ::dds::topicQos t (e);
        topic_qos_.push_back (t);
      }

      else if (n == ACE_TEXT("domainparticipant_qos"))
      {
        ::dds::domainparticipantQos t (e);
        domainparticipant_qos_.push_back (t);
      }

      else if (n == ACE_TEXT("publisher_qos"))
      {
        ::dds::publisherQos t (e);
        publisher_qos_.push_back (t);
      }

      else if (n == ACE_TEXT("subscriber_qos"))
      {
        ::dds::subscriberQos t (e);
        subscriber_qos_.push_back (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        name_ = std::make_unique<::XMLSchema::string<ACE_TCHAR>> (a);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // qosProfile_seq

  qosProfile_seq::
  qosProfile_seq (::XSCRT::XML::Element<ACE_TCHAR> const& element)
  :Base (element)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (element);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("qos_profile"))
      {
        ::dds::qosProfile t (e);
        qos_profile_.push_back (t);
      }

      else
      {
      }
    }
  }
}

namespace dds
{
  namespace reader
  {
    ::dds::qosProfile_seq
    dds (xercesc::DOMDocument const* d)
    {
      xercesc::DOMElement* dom_element = d->getDocumentElement ();
      if (!dom_element)
      {
        throw 1;
      }

      ::XSCRT::XML::Element<ACE_TCHAR> e (dom_element);
      if (e.name () == ACE_TEXT("dds"))
      {
        ::dds::qosProfile_seq r (e);

        return r;
      }

      else
      {
        throw 1;
      }
    }
  }
}

