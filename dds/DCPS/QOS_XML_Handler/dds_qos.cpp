/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "dds_qos.hpp"

#include "ace/ace_wchar.h"
#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/Singleton.h"

namespace dds
{
  // destinationOrderKind

  destinationOrderKind::Value destinationOrderKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::destinationOrderKind const& a, ::dds::destinationOrderKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::destinationOrderKind const& a, ::dds::destinationOrderKind const& b)
  {
    return a.v_ != b.v_;
  }

  destinationOrderKind::
  destinationOrderKind (destinationOrderKind::Value v)
  : v_ (v)
  {
  }

  // durabilityKind

  durabilityKind::Value durabilityKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::durabilityKind const& a, ::dds::durabilityKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::durabilityKind const& a, ::dds::durabilityKind const& b)
  {
    return a.v_ != b.v_;
  }

  durabilityKind::
  durabilityKind (durabilityKind::Value v)
  : v_ (v)
  {
  }

  // historyKind

  historyKind::Value historyKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::historyKind const& a, ::dds::historyKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::historyKind const& a, ::dds::historyKind const& b)
  {
    return a.v_ != b.v_;
  }

  historyKind::
  historyKind (historyKind::Value v)
  : v_ (v)
  {
  }

  // livelinessKind

  livelinessKind::Value livelinessKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::livelinessKind const& a, ::dds::livelinessKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::livelinessKind const& a, ::dds::livelinessKind const& b)
  {
    return a.v_ != b.v_;
  }

  livelinessKind::
  livelinessKind (livelinessKind::Value v)
  : v_ (v)
  {
  }

  // presentationAccessScopeKind

  presentationAccessScopeKind::Value presentationAccessScopeKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::presentationAccessScopeKind const& a, ::dds::presentationAccessScopeKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::presentationAccessScopeKind const& a, ::dds::presentationAccessScopeKind const& b)
  {
    return a.v_ != b.v_;
  }

  presentationAccessScopeKind::
  presentationAccessScopeKind (presentationAccessScopeKind::Value v)
  : v_ (v)
  {
  }

  // reliabilityKind

  reliabilityKind::Value reliabilityKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::reliabilityKind const& a, ::dds::reliabilityKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::reliabilityKind const& a, ::dds::reliabilityKind const& b)
  {
    return a.v_ != b.v_;
  }

  reliabilityKind::
  reliabilityKind (reliabilityKind::Value v)
  : v_ (v)
  {
  }

  // ownershipKind

  ownershipKind::Value ownershipKind::
  integral () const
  {
    return v_;
  }

  bool
  operator== (::dds::ownershipKind const& a, ::dds::ownershipKind const& b)
  {
    return a.v_ == b.v_;
  }

  bool
  operator!= (::dds::ownershipKind const& a, ::dds::ownershipKind const& b)
  {
    return a.v_ != b.v_;
  }

  ownershipKind::
  ownershipKind (ownershipKind::Value v)
  : v_ (v)
  {
  }

  // duration

  duration::duration ()
  : ::XSCRT::Type ()
  {
  }

  duration::duration (duration const& s) :
  ::XSCRT::Type (s)
  , sec_ (s.sec_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.sec_) : 0)
  , nanosec_ (s.nanosec_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.nanosec_) : 0)
  {
    if (sec_.get ()) sec_->container (this);
    if (nanosec_.get ()) nanosec_->container (this);
  }

  duration&
  duration::operator= (duration const& s)
  {
    if (&s != this)
    {
      if (s.sec_.get ())
        sec (*(s.sec_));
      else
        sec_.reset (0);

      if (s.nanosec_.get ())
        nanosec (*(s.nanosec_));
      else
        nanosec_.reset (0);
    }

    return *this;
  }


  // duration
  bool duration::
  sec_p () const
  {
    return sec_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& duration::
  sec () const
  {
    return *sec_;
  }

  void duration::
  sec (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (sec_.get ())
    {
      *sec_ = e;
    }

    else
    {
      sec_ = duration::sec_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      sec_->container (this);
    }
  }

  // duration
  bool duration::
  nanosec_p () const
  {
    return nanosec_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& duration::
  nanosec () const
  {
    return *nanosec_;
  }

  void duration::
  nanosec (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (nanosec_.get ())
    {
      *nanosec_ = e;
    }

    else
    {
      nanosec_ = duration::nanosec_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      nanosec_->container (this);
    }
  }


  // stringSeq

  stringSeq::stringSeq ()
  : ::XSCRT::Type ()
  {
  }

  stringSeq::stringSeq (stringSeq const& s) :
  ::XSCRT::Type (s)
  , element_ (s.element_)
  {
  }

  stringSeq&
  stringSeq::operator= (stringSeq const& s)
  {
    if (&s != this)
    {
      element_ = s.element_;
    }

    return *this;
  }


  // stringSeq
  stringSeq::element_iterator stringSeq::
  begin_element ()
  {
    return element_.begin ();
  }

  stringSeq::element_iterator stringSeq::
  end_element ()
  {
    return element_.end ();
  }

  stringSeq::element_const_iterator stringSeq::
  begin_element () const
  {
    return element_.begin ();
  }

  stringSeq::element_const_iterator stringSeq::
  end_element () const
  {
    return element_.end ();
  }

  void stringSeq::
  add_element (stringSeq::element_value_type const& e)
  {
    element_.push_back (e);
  }

  size_t stringSeq::
  count_element(void) const
  {
    return element_.size ();
  }


  // deadlineQosPolicy

  deadlineQosPolicy::deadlineQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  deadlineQosPolicy::deadlineQosPolicy (deadlineQosPolicy const& s) :
  ::XSCRT::Type (s)
  , period_ (s.period_.get () ? new ::dds::duration (*s.period_) : 0)
  {
    if (period_.get ()) period_->container (this);
  }

  deadlineQosPolicy&
  deadlineQosPolicy::operator= (deadlineQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.period_.get ())
        period (*(s.period_));
      else
        period_.reset (0);
    }

    return *this;
  }


  // deadlineQosPolicy
  bool deadlineQosPolicy::
  period_p () const
  {
    return period_.get () != 0;
  }

  ::dds::duration const& deadlineQosPolicy::
  period () const
  {
    return *period_;
  }

  void deadlineQosPolicy::
  period (::dds::duration const& e)
  {
    if (period_.get ())
    {
      *period_ = e;
    }

    else
    {
      period_ = deadlineQosPolicy::period_auto_ptr_type (new ::dds::duration (e));
      period_->container (this);
    }
  }


  // destinationOrderQosPolicy

  destinationOrderQosPolicy::destinationOrderQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  destinationOrderQosPolicy::destinationOrderQosPolicy (destinationOrderQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::destinationOrderKind (*s.kind_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
  }

  destinationOrderQosPolicy&
  destinationOrderQosPolicy::operator= (destinationOrderQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);
    }

    return *this;
  }


  // destinationOrderQosPolicy
  bool destinationOrderQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::destinationOrderKind const& destinationOrderQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void destinationOrderQosPolicy::
  kind (::dds::destinationOrderKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = destinationOrderQosPolicy::kind_auto_ptr_type (new ::dds::destinationOrderKind (e));
      kind_->container (this);
    }
  }


  // durabilityQosPolicy

  durabilityQosPolicy::durabilityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  durabilityQosPolicy::durabilityQosPolicy (durabilityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::durabilityKind (*s.kind_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
  }

  durabilityQosPolicy&
  durabilityQosPolicy::operator= (durabilityQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);
    }

    return *this;
  }


  // durabilityQosPolicy
  bool durabilityQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::durabilityKind const& durabilityQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void durabilityQosPolicy::
  kind (::dds::durabilityKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = durabilityQosPolicy::kind_auto_ptr_type (new ::dds::durabilityKind (e));
      kind_->container (this);
    }
  }


  // durabilityServiceQosPolicy

  durabilityServiceQosPolicy::durabilityServiceQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  durabilityServiceQosPolicy::durabilityServiceQosPolicy (durabilityServiceQosPolicy const& s) :
  ::XSCRT::Type (s)
  , service_cleanup_delay_ (s.service_cleanup_delay_.get () ? new ::dds::duration (*s.service_cleanup_delay_) : 0)
  , history_kind_ (s.history_kind_.get () ? new ::dds::historyKind (*s.history_kind_) : 0)
  , history_depth_ (s.history_depth_.get () ? new ::XMLSchema::positiveInteger (*s.history_depth_) : 0)
  , max_samples_ (s.max_samples_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_samples_) : 0)
  , max_instances_ (s.max_instances_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_instances_) : 0)
  , max_samples_per_instance_ (s.max_samples_per_instance_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_samples_per_instance_) : 0)
  {
    if (service_cleanup_delay_.get ()) service_cleanup_delay_->container (this);
    if (history_kind_.get ()) history_kind_->container (this);
    if (history_depth_.get ()) history_depth_->container (this);
    if (max_samples_.get ()) max_samples_->container (this);
    if (max_instances_.get ()) max_instances_->container (this);
    if (max_samples_per_instance_.get ()) max_samples_per_instance_->container (this);
  }

  durabilityServiceQosPolicy&
  durabilityServiceQosPolicy::operator= (durabilityServiceQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.service_cleanup_delay_.get ())
        service_cleanup_delay (*(s.service_cleanup_delay_));
      else
        service_cleanup_delay_.reset (0);

      if (s.history_kind_.get ())
        history_kind (*(s.history_kind_));
      else
        history_kind_.reset (0);

      if (s.history_depth_.get ())
        history_depth (*(s.history_depth_));
      else
        history_depth_.reset (0);

      if (s.max_samples_.get ())
        max_samples (*(s.max_samples_));
      else
        max_samples_.reset (0);

      if (s.max_instances_.get ())
        max_instances (*(s.max_instances_));
      else
        max_instances_.reset (0);

      if (s.max_samples_per_instance_.get ())
        max_samples_per_instance (*(s.max_samples_per_instance_));
      else
        max_samples_per_instance_.reset (0);
    }

    return *this;
  }


  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  service_cleanup_delay_p () const
  {
    return service_cleanup_delay_.get () != 0;
  }

  ::dds::duration const& durabilityServiceQosPolicy::
  service_cleanup_delay () const
  {
    return *service_cleanup_delay_;
  }

  void durabilityServiceQosPolicy::
  service_cleanup_delay (::dds::duration const& e)
  {
    if (service_cleanup_delay_.get ())
    {
      *service_cleanup_delay_ = e;
    }

    else
    {
      service_cleanup_delay_ = durabilityServiceQosPolicy::service_cleanup_delay_auto_ptr_type (new ::dds::duration (e));
      service_cleanup_delay_->container (this);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  history_kind_p () const
  {
    return history_kind_.get () != 0;
  }

  ::dds::historyKind const& durabilityServiceQosPolicy::
  history_kind () const
  {
    return *history_kind_;
  }

  void durabilityServiceQosPolicy::
  history_kind (::dds::historyKind const& e)
  {
    if (history_kind_.get ())
    {
      *history_kind_ = e;
    }

    else
    {
      history_kind_ = durabilityServiceQosPolicy::history_kind_auto_ptr_type (new ::dds::historyKind (e));
      history_kind_->container (this);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  history_depth_p () const
  {
    return history_depth_.get () != 0;
  }

  ::XMLSchema::positiveInteger const& durabilityServiceQosPolicy::
  history_depth () const
  {
    return *history_depth_;
  }

  void durabilityServiceQosPolicy::
  history_depth (::XMLSchema::positiveInteger const& e)
  {
    if (history_depth_.get ())
    {
      *history_depth_ = e;
    }

    else
    {
      history_depth_ = durabilityServiceQosPolicy::history_depth_auto_ptr_type (new ::XMLSchema::positiveInteger (e));
      history_depth_->container (this);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_samples_p () const
  {
    return max_samples_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_samples () const
  {
    return *max_samples_;
  }

  void durabilityServiceQosPolicy::
  max_samples (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_.get ())
    {
      *max_samples_ = e;
    }

    else
    {
      max_samples_ = durabilityServiceQosPolicy::max_samples_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_samples_->container (this);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_instances_p () const
  {
    return max_instances_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_instances () const
  {
    return *max_instances_;
  }

  void durabilityServiceQosPolicy::
  max_instances (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_instances_.get ())
    {
      *max_instances_ = e;
    }

    else
    {
      max_instances_ = durabilityServiceQosPolicy::max_instances_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_instances_->container (this);
    }
  }

  // durabilityServiceQosPolicy
  bool durabilityServiceQosPolicy::
  max_samples_per_instance_p () const
  {
    return max_samples_per_instance_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& durabilityServiceQosPolicy::
  max_samples_per_instance () const
  {
    return *max_samples_per_instance_;
  }

  void durabilityServiceQosPolicy::
  max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_per_instance_.get ())
    {
      *max_samples_per_instance_ = e;
    }

    else
    {
      max_samples_per_instance_ = durabilityServiceQosPolicy::max_samples_per_instance_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_samples_per_instance_->container (this);
    }
  }


  // entityFactoryQosPolicy

  entityFactoryQosPolicy::entityFactoryQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  entityFactoryQosPolicy::entityFactoryQosPolicy (entityFactoryQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autoenable_created_entities_ (s.autoenable_created_entities_.get () ? new ::XMLSchema::boolean (*s.autoenable_created_entities_) : 0)
  {
    if (autoenable_created_entities_.get ()) autoenable_created_entities_->container (this);
  }

  entityFactoryQosPolicy&
  entityFactoryQosPolicy::operator= (entityFactoryQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.autoenable_created_entities_.get ())
        autoenable_created_entities (*(s.autoenable_created_entities_));
      else
        autoenable_created_entities_.reset (0);
    }

    return *this;
  }


  // entityFactoryQosPolicy
  bool entityFactoryQosPolicy::
  autoenable_created_entities_p () const
  {
    return autoenable_created_entities_.get () != 0;
  }

  ::XMLSchema::boolean const& entityFactoryQosPolicy::
  autoenable_created_entities () const
  {
    return *autoenable_created_entities_;
  }

  void entityFactoryQosPolicy::
  autoenable_created_entities (::XMLSchema::boolean const& e)
  {
    if (autoenable_created_entities_.get ())
    {
      *autoenable_created_entities_ = e;
    }

    else
    {
      autoenable_created_entities_ = entityFactoryQosPolicy::autoenable_created_entities_auto_ptr_type (new ::XMLSchema::boolean (e));
      autoenable_created_entities_->container (this);
    }
  }


  // groupDataQosPolicy

  groupDataQosPolicy::groupDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  groupDataQosPolicy::groupDataQosPolicy (groupDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.value_) : 0)
  {
    if (value_.get ()) value_->container (this);
  }

  groupDataQosPolicy&
  groupDataQosPolicy::operator= (groupDataQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);
    }

    return *this;
  }


  // groupDataQosPolicy
  bool groupDataQosPolicy::
  value_p () const
  {
    return value_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& groupDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void groupDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_.get ())
    {
      *value_ = e;
    }

    else
    {
      value_ = groupDataQosPolicy::value_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      value_->container (this);
    }
  }


  // historyQosPolicy

  historyQosPolicy::historyQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  historyQosPolicy::historyQosPolicy (historyQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::historyKind (*s.kind_) : 0)
  , depth_ (s.depth_.get () ? new ::XMLSchema::positiveInteger (*s.depth_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
    if (depth_.get ()) depth_->container (this);
  }

  historyQosPolicy&
  historyQosPolicy::operator= (historyQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);

      if (s.depth_.get ())
        depth (*(s.depth_));
      else
        depth_.reset (0);
    }

    return *this;
  }


  // historyQosPolicy
  bool historyQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::historyKind const& historyQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void historyQosPolicy::
  kind (::dds::historyKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = historyQosPolicy::kind_auto_ptr_type (new ::dds::historyKind (e));
      kind_->container (this);
    }
  }

  // historyQosPolicy
  bool historyQosPolicy::
  depth_p () const
  {
    return depth_.get () != 0;
  }

  ::XMLSchema::positiveInteger const& historyQosPolicy::
  depth () const
  {
    return *depth_;
  }

  void historyQosPolicy::
  depth (::XMLSchema::positiveInteger const& e)
  {
    if (depth_.get ())
    {
      *depth_ = e;
    }

    else
    {
      depth_ = historyQosPolicy::depth_auto_ptr_type (new ::XMLSchema::positiveInteger (e));
      depth_->container (this);
    }
  }


  // latencyBudgetQosPolicy

  latencyBudgetQosPolicy::latencyBudgetQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  latencyBudgetQosPolicy::latencyBudgetQosPolicy (latencyBudgetQosPolicy const& s) :
  ::XSCRT::Type (s)
  , duration_ (s.duration_.get () ? new ::dds::duration (*s.duration_) : 0)
  {
    if (duration_.get ()) duration_->container (this);
  }

  latencyBudgetQosPolicy&
  latencyBudgetQosPolicy::operator= (latencyBudgetQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.duration_.get ())
        duration (*(s.duration_));
      else
        duration_.reset (0);
    }

    return *this;
  }


  // latencyBudgetQosPolicy
  bool latencyBudgetQosPolicy::
  duration_p () const
  {
    return duration_.get () != 0;
  }

  ::dds::duration const& latencyBudgetQosPolicy::
  duration () const
  {
    return *duration_;
  }

  void latencyBudgetQosPolicy::
  duration (::dds::duration const& e)
  {
    if (duration_.get ())
    {
      *duration_ = e;
    }

    else
    {
      duration_ = latencyBudgetQosPolicy::duration_auto_ptr_type (new ::dds::duration (e));
      duration_->container (this);
    }
  }


  // lifespanQosPolicy

  lifespanQosPolicy::lifespanQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  lifespanQosPolicy::lifespanQosPolicy (lifespanQosPolicy const& s) :
  ::XSCRT::Type (s)
  , duration_ (s.duration_.get () ? new ::dds::duration (*s.duration_) : 0)
  {
    if (duration_.get ()) duration_->container (this);
  }

  lifespanQosPolicy&
  lifespanQosPolicy::operator= (lifespanQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.duration_.get ())
        duration (*(s.duration_));
      else
        duration_.reset (0);
    }

    return *this;
  }


  // lifespanQosPolicy
  bool lifespanQosPolicy::
  duration_p () const
  {
    return duration_.get () != 0;
  }

  ::dds::duration const& lifespanQosPolicy::
  duration () const
  {
    return *duration_;
  }

  void lifespanQosPolicy::
  duration (::dds::duration const& e)
  {
    if (duration_.get ())
    {
      *duration_ = e;
    }

    else
    {
      duration_ = lifespanQosPolicy::duration_auto_ptr_type (new ::dds::duration (e));
      duration_->container (this);
    }
  }


  // livelinessQosPolicy

  livelinessQosPolicy::livelinessQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  livelinessQosPolicy::livelinessQosPolicy (livelinessQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::livelinessKind (*s.kind_) : 0)
  , lease_duration_ (s.lease_duration_.get () ? new ::dds::duration (*s.lease_duration_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
    if (lease_duration_.get ()) lease_duration_->container (this);
  }

  livelinessQosPolicy&
  livelinessQosPolicy::operator= (livelinessQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);

      if (s.lease_duration_.get ())
        lease_duration (*(s.lease_duration_));
      else
        lease_duration_.reset (0);
    }

    return *this;
  }


  // livelinessQosPolicy
  bool livelinessQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::livelinessKind const& livelinessQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void livelinessQosPolicy::
  kind (::dds::livelinessKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = livelinessQosPolicy::kind_auto_ptr_type (new ::dds::livelinessKind (e));
      kind_->container (this);
    }
  }

  // livelinessQosPolicy
  bool livelinessQosPolicy::
  lease_duration_p () const
  {
    return lease_duration_.get () != 0;
  }

  ::dds::duration const& livelinessQosPolicy::
  lease_duration () const
  {
    return *lease_duration_;
  }

  void livelinessQosPolicy::
  lease_duration (::dds::duration const& e)
  {
    if (lease_duration_.get ())
    {
      *lease_duration_ = e;
    }

    else
    {
      lease_duration_ = livelinessQosPolicy::lease_duration_auto_ptr_type (new ::dds::duration (e));
      lease_duration_->container (this);
    }
  }


  // ownershipQosPolicy

  ownershipQosPolicy::ownershipQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  ownershipQosPolicy::ownershipQosPolicy (ownershipQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::ownershipKind (*s.kind_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
  }

  ownershipQosPolicy&
  ownershipQosPolicy::operator= (ownershipQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);
    }

    return *this;
  }


  // ownershipQosPolicy
  bool ownershipQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::ownershipKind const& ownershipQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void ownershipQosPolicy::
  kind (::dds::ownershipKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = ownershipQosPolicy::kind_auto_ptr_type (new ::dds::ownershipKind (e));
      kind_->container (this);
    }
  }


  // ownershipStrengthQosPolicy

  ownershipStrengthQosPolicy::ownershipStrengthQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  ownershipStrengthQosPolicy::ownershipStrengthQosPolicy (ownershipStrengthQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_.get () ? new ::XMLSchema::nonNegativeInteger (*s.value_) : 0)
  {
    if (value_.get ()) value_->container (this);
  }

  ownershipStrengthQosPolicy&
  ownershipStrengthQosPolicy::operator= (ownershipStrengthQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);
    }

    return *this;
  }


  // ownershipStrengthQosPolicy
  bool ownershipStrengthQosPolicy::
  value_p () const
  {
    return value_.get () != 0;
  }

  ::XMLSchema::nonNegativeInteger const& ownershipStrengthQosPolicy::
  value () const
  {
    return *value_;
  }

  void ownershipStrengthQosPolicy::
  value (::XMLSchema::nonNegativeInteger const& e)
  {
    if (value_.get ())
    {
      *value_ = e;
    }

    else
    {
      value_ = ownershipStrengthQosPolicy::value_auto_ptr_type (new ::XMLSchema::nonNegativeInteger (e));
      value_->container (this);
    }
  }


  // partitionQosPolicy

  partitionQosPolicy::partitionQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  partitionQosPolicy::partitionQosPolicy (partitionQosPolicy const& s) :
  ::XSCRT::Type (s)
  , name_ (s.name_.get () ? new ::dds::stringSeq (*s.name_) : 0)
  {
    if (name_.get ()) name_->container (this);
  }

  partitionQosPolicy&
  partitionQosPolicy::operator= (partitionQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.name_.get ())
        name (*(s.name_));
      else
        name_.reset (0);
    }

    return *this;
  }


  // partitionQosPolicy
  bool partitionQosPolicy::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::dds::stringSeq const& partitionQosPolicy::
  name () const
  {
    return *name_;
  }

  void partitionQosPolicy::
  name (::dds::stringSeq const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = partitionQosPolicy::name_auto_ptr_type (new ::dds::stringSeq (e));
      name_->container (this);
    }
  }


  // presentationQosPolicy

  presentationQosPolicy::presentationQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  presentationQosPolicy::presentationQosPolicy (presentationQosPolicy const& s) :
  ::XSCRT::Type (s)
  , access_scope_ (s.access_scope_.get () ? new ::dds::presentationAccessScopeKind (*s.access_scope_) : 0)
  , coherent_access_ (s.coherent_access_.get () ? new ::XMLSchema::boolean (*s.coherent_access_) : 0)
  , ordered_access_ (s.ordered_access_.get () ? new ::XMLSchema::boolean (*s.ordered_access_) : 0)
  {
    if (access_scope_.get ()) access_scope_->container (this);
    if (coherent_access_.get ()) coherent_access_->container (this);
    if (ordered_access_.get ()) ordered_access_->container (this);
  }

  presentationQosPolicy&
  presentationQosPolicy::operator= (presentationQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.access_scope_.get ())
        access_scope (*(s.access_scope_));
      else
        access_scope_.reset (0);

      if (s.coherent_access_.get ())
        coherent_access (*(s.coherent_access_));
      else
        coherent_access_.reset (0);

      if (s.ordered_access_.get ())
        ordered_access (*(s.ordered_access_));
      else
        ordered_access_.reset (0);
    }

    return *this;
  }


  // presentationQosPolicy
  bool presentationQosPolicy::
  access_scope_p () const
  {
    return access_scope_.get () != 0;
  }

  ::dds::presentationAccessScopeKind const& presentationQosPolicy::
  access_scope () const
  {
    return *access_scope_;
  }

  void presentationQosPolicy::
  access_scope (::dds::presentationAccessScopeKind const& e)
  {
    if (access_scope_.get ())
    {
      *access_scope_ = e;
    }

    else
    {
      access_scope_ = presentationQosPolicy::access_scope_auto_ptr_type (new ::dds::presentationAccessScopeKind (e));
      access_scope_->container (this);
    }
  }

  // presentationQosPolicy
  bool presentationQosPolicy::
  coherent_access_p () const
  {
    return coherent_access_.get () != 0;
  }

  ::XMLSchema::boolean const& presentationQosPolicy::
  coherent_access () const
  {
    return *coherent_access_;
  }

  void presentationQosPolicy::
  coherent_access (::XMLSchema::boolean const& e)
  {
    if (coherent_access_.get ())
    {
      *coherent_access_ = e;
    }

    else
    {
      coherent_access_ = presentationQosPolicy::coherent_access_auto_ptr_type (new ::XMLSchema::boolean (e));
      coherent_access_->container (this);
    }
  }

  // presentationQosPolicy
  bool presentationQosPolicy::
  ordered_access_p () const
  {
    return ordered_access_.get () != 0;
  }

  ::XMLSchema::boolean const& presentationQosPolicy::
  ordered_access () const
  {
    return *ordered_access_;
  }

  void presentationQosPolicy::
  ordered_access (::XMLSchema::boolean const& e)
  {
    if (ordered_access_.get ())
    {
      *ordered_access_ = e;
    }

    else
    {
      ordered_access_ = presentationQosPolicy::ordered_access_auto_ptr_type (new ::XMLSchema::boolean (e));
      ordered_access_->container (this);
    }
  }


  // readerDataLifecycleQosPolicy

  readerDataLifecycleQosPolicy::readerDataLifecycleQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  readerDataLifecycleQosPolicy::readerDataLifecycleQosPolicy (readerDataLifecycleQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autopurge_nowriter_samples_delay_ (s.autopurge_nowriter_samples_delay_.get () ? new ::dds::duration (*s.autopurge_nowriter_samples_delay_) : 0)
  , autopurge_disposed_samples_delay_ (s.autopurge_disposed_samples_delay_.get () ? new ::dds::duration (*s.autopurge_disposed_samples_delay_) : 0)
  {
    if (autopurge_nowriter_samples_delay_.get ()) autopurge_nowriter_samples_delay_->container (this);
    if (autopurge_disposed_samples_delay_.get ()) autopurge_disposed_samples_delay_->container (this);
  }

  readerDataLifecycleQosPolicy&
  readerDataLifecycleQosPolicy::operator= (readerDataLifecycleQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.autopurge_nowriter_samples_delay_.get ())
        autopurge_nowriter_samples_delay (*(s.autopurge_nowriter_samples_delay_));
      else
        autopurge_nowriter_samples_delay_.reset (0);

      if (s.autopurge_disposed_samples_delay_.get ())
        autopurge_disposed_samples_delay (*(s.autopurge_disposed_samples_delay_));
      else
        autopurge_disposed_samples_delay_.reset (0);
    }

    return *this;
  }


  // readerDataLifecycleQosPolicy
  bool readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay_p () const
  {
    return autopurge_nowriter_samples_delay_.get () != 0;
  }

  ::dds::duration const& readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay () const
  {
    return *autopurge_nowriter_samples_delay_;
  }

  void readerDataLifecycleQosPolicy::
  autopurge_nowriter_samples_delay (::dds::duration const& e)
  {
    if (autopurge_nowriter_samples_delay_.get ())
    {
      *autopurge_nowriter_samples_delay_ = e;
    }

    else
    {
      autopurge_nowriter_samples_delay_ = readerDataLifecycleQosPolicy::autopurge_nowriter_samples_delay_auto_ptr_type (new ::dds::duration (e));
      autopurge_nowriter_samples_delay_->container (this);
    }
  }

  // readerDataLifecycleQosPolicy
  bool readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay_p () const
  {
    return autopurge_disposed_samples_delay_.get () != 0;
  }

  ::dds::duration const& readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay () const
  {
    return *autopurge_disposed_samples_delay_;
  }

  void readerDataLifecycleQosPolicy::
  autopurge_disposed_samples_delay (::dds::duration const& e)
  {
    if (autopurge_disposed_samples_delay_.get ())
    {
      *autopurge_disposed_samples_delay_ = e;
    }

    else
    {
      autopurge_disposed_samples_delay_ = readerDataLifecycleQosPolicy::autopurge_disposed_samples_delay_auto_ptr_type (new ::dds::duration (e));
      autopurge_disposed_samples_delay_->container (this);
    }
  }


  // reliabilityQosPolicy

  reliabilityQosPolicy::reliabilityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  reliabilityQosPolicy::reliabilityQosPolicy (reliabilityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , kind_ (s.kind_.get () ? new ::dds::reliabilityKind (*s.kind_) : 0)
  , max_blocking_time_ (s.max_blocking_time_.get () ? new ::dds::duration (*s.max_blocking_time_) : 0)
  {
    if (kind_.get ()) kind_->container (this);
    if (max_blocking_time_.get ()) max_blocking_time_->container (this);
  }

  reliabilityQosPolicy&
  reliabilityQosPolicy::operator= (reliabilityQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.kind_.get ())
        kind (*(s.kind_));
      else
        kind_.reset (0);

      if (s.max_blocking_time_.get ())
        max_blocking_time (*(s.max_blocking_time_));
      else
        max_blocking_time_.reset (0);
    }

    return *this;
  }


  // reliabilityQosPolicy
  bool reliabilityQosPolicy::
  kind_p () const
  {
    return kind_.get () != 0;
  }

  ::dds::reliabilityKind const& reliabilityQosPolicy::
  kind () const
  {
    return *kind_;
  }

  void reliabilityQosPolicy::
  kind (::dds::reliabilityKind const& e)
  {
    if (kind_.get ())
    {
      *kind_ = e;
    }

    else
    {
      kind_ = reliabilityQosPolicy::kind_auto_ptr_type (new ::dds::reliabilityKind (e));
      kind_->container (this);
    }
  }

  // reliabilityQosPolicy
  bool reliabilityQosPolicy::
  max_blocking_time_p () const
  {
    return max_blocking_time_.get () != 0;
  }

  ::dds::duration const& reliabilityQosPolicy::
  max_blocking_time () const
  {
    return *max_blocking_time_;
  }

  void reliabilityQosPolicy::
  max_blocking_time (::dds::duration const& e)
  {
    if (max_blocking_time_.get ())
    {
      *max_blocking_time_ = e;
    }

    else
    {
      max_blocking_time_ = reliabilityQosPolicy::max_blocking_time_auto_ptr_type (new ::dds::duration (e));
      max_blocking_time_->container (this);
    }
  }


  // resourceLimitsQosPolicy

  resourceLimitsQosPolicy::resourceLimitsQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  resourceLimitsQosPolicy::resourceLimitsQosPolicy (resourceLimitsQosPolicy const& s) :
  ::XSCRT::Type (s)
  , max_samples_ (s.max_samples_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_samples_) : 0)
  , max_instances_ (s.max_instances_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_instances_) : 0)
  , max_samples_per_instance_ (s.max_samples_per_instance_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.max_samples_per_instance_) : 0)
  , initial_samples_ (s.initial_samples_.get () ? new ::XMLSchema::positiveInteger (*s.initial_samples_) : 0)
  , initial_instances_ (s.initial_instances_.get () ? new ::XMLSchema::positiveInteger (*s.initial_instances_) : 0)
  {
    if (max_samples_.get ()) max_samples_->container (this);
    if (max_instances_.get ()) max_instances_->container (this);
    if (max_samples_per_instance_.get ()) max_samples_per_instance_->container (this);
    if (initial_samples_.get ()) initial_samples_->container (this);
    if (initial_instances_.get ()) initial_instances_->container (this);
  }

  resourceLimitsQosPolicy&
  resourceLimitsQosPolicy::operator= (resourceLimitsQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.max_samples_.get ())
        max_samples (*(s.max_samples_));
      else
        max_samples_.reset (0);

      if (s.max_instances_.get ())
        max_instances (*(s.max_instances_));
      else
        max_instances_.reset (0);

      if (s.max_samples_per_instance_.get ())
        max_samples_per_instance (*(s.max_samples_per_instance_));
      else
        max_samples_per_instance_.reset (0);

      if (s.initial_samples_.get ())
        initial_samples (*(s.initial_samples_));
      else
        initial_samples_.reset (0);

      if (s.initial_instances_.get ())
        initial_instances (*(s.initial_instances_));
      else
        initial_instances_.reset (0);
    }

    return *this;
  }


  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_samples_p () const
  {
    return max_samples_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_samples () const
  {
    return *max_samples_;
  }

  void resourceLimitsQosPolicy::
  max_samples (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_.get ())
    {
      *max_samples_ = e;
    }

    else
    {
      max_samples_ = resourceLimitsQosPolicy::max_samples_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_samples_->container (this);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_instances_p () const
  {
    return max_instances_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_instances () const
  {
    return *max_instances_;
  }

  void resourceLimitsQosPolicy::
  max_instances (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_instances_.get ())
    {
      *max_instances_ = e;
    }

    else
    {
      max_instances_ = resourceLimitsQosPolicy::max_instances_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_instances_->container (this);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  max_samples_per_instance_p () const
  {
    return max_samples_per_instance_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& resourceLimitsQosPolicy::
  max_samples_per_instance () const
  {
    return *max_samples_per_instance_;
  }

  void resourceLimitsQosPolicy::
  max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (max_samples_per_instance_.get ())
    {
      *max_samples_per_instance_ = e;
    }

    else
    {
      max_samples_per_instance_ = resourceLimitsQosPolicy::max_samples_per_instance_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      max_samples_per_instance_->container (this);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  initial_samples_p () const
  {
    return initial_samples_.get () != 0;
  }

  ::XMLSchema::positiveInteger const& resourceLimitsQosPolicy::
  initial_samples () const
  {
    return *initial_samples_;
  }

  void resourceLimitsQosPolicy::
  initial_samples (::XMLSchema::positiveInteger const& e)
  {
    if (initial_samples_.get ())
    {
      *initial_samples_ = e;
    }

    else
    {
      initial_samples_ = resourceLimitsQosPolicy::initial_samples_auto_ptr_type (new ::XMLSchema::positiveInteger (e));
      initial_samples_->container (this);
    }
  }

  // resourceLimitsQosPolicy
  bool resourceLimitsQosPolicy::
  initial_instances_p () const
  {
    return initial_instances_.get () != 0;
  }

  ::XMLSchema::positiveInteger const& resourceLimitsQosPolicy::
  initial_instances () const
  {
    return *initial_instances_;
  }

  void resourceLimitsQosPolicy::
  initial_instances (::XMLSchema::positiveInteger const& e)
  {
    if (initial_instances_.get ())
    {
      *initial_instances_ = e;
    }

    else
    {
      initial_instances_ = resourceLimitsQosPolicy::initial_instances_auto_ptr_type (new ::XMLSchema::positiveInteger (e));
      initial_instances_->container (this);
    }
  }


  // timeBasedFilterQosPolicy

  timeBasedFilterQosPolicy::timeBasedFilterQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  timeBasedFilterQosPolicy::timeBasedFilterQosPolicy (timeBasedFilterQosPolicy const& s) :
  ::XSCRT::Type (s)
  , minimum_separation_ (s.minimum_separation_.get () ? new ::dds::duration (*s.minimum_separation_) : 0)
  {
    if (minimum_separation_.get ()) minimum_separation_->container (this);
  }

  timeBasedFilterQosPolicy&
  timeBasedFilterQosPolicy::operator= (timeBasedFilterQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.minimum_separation_.get ())
        minimum_separation (*(s.minimum_separation_));
      else
        minimum_separation_.reset (0);
    }

    return *this;
  }


  // timeBasedFilterQosPolicy
  bool timeBasedFilterQosPolicy::
  minimum_separation_p () const
  {
    return minimum_separation_.get () != 0;
  }

  ::dds::duration const& timeBasedFilterQosPolicy::
  minimum_separation () const
  {
    return *minimum_separation_;
  }

  void timeBasedFilterQosPolicy::
  minimum_separation (::dds::duration const& e)
  {
    if (minimum_separation_.get ())
    {
      *minimum_separation_ = e;
    }

    else
    {
      minimum_separation_ = timeBasedFilterQosPolicy::minimum_separation_auto_ptr_type (new ::dds::duration (e));
      minimum_separation_->container (this);
    }
  }


  // topicDataQosPolicy

  topicDataQosPolicy::topicDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  topicDataQosPolicy::topicDataQosPolicy (topicDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.value_) : 0)
  {
    if (value_.get ()) value_->container (this);
  }

  topicDataQosPolicy&
  topicDataQosPolicy::operator= (topicDataQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);
    }

    return *this;
  }


  // topicDataQosPolicy
  bool topicDataQosPolicy::
  value_p () const
  {
    return value_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void topicDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_.get ())
    {
      *value_ = e;
    }

    else
    {
      value_ = topicDataQosPolicy::value_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      value_->container (this);
    }
  }


  // transportPriorityQosPolicy

  transportPriorityQosPolicy::transportPriorityQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  transportPriorityQosPolicy::transportPriorityQosPolicy (transportPriorityQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_.get () ? new ::XMLSchema::nonNegativeInteger (*s.value_) : 0)
  {
    if (value_.get ()) value_->container (this);
  }

  transportPriorityQosPolicy&
  transportPriorityQosPolicy::operator= (transportPriorityQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);
    }

    return *this;
  }


  // transportPriorityQosPolicy
  bool transportPriorityQosPolicy::
  value_p () const
  {
    return value_.get () != 0;
  }

  ::XMLSchema::nonNegativeInteger const& transportPriorityQosPolicy::
  value () const
  {
    return *value_;
  }

  void transportPriorityQosPolicy::
  value (::XMLSchema::nonNegativeInteger const& e)
  {
    if (value_.get ())
    {
      *value_ = e;
    }

    else
    {
      value_ = transportPriorityQosPolicy::value_auto_ptr_type (new ::XMLSchema::nonNegativeInteger (e));
      value_->container (this);
    }
  }


  // userDataQosPolicy

  userDataQosPolicy::userDataQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  userDataQosPolicy::userDataQosPolicy (userDataQosPolicy const& s) :
  ::XSCRT::Type (s)
  , value_ (s.value_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.value_) : 0)
  {
    if (value_.get ()) value_->container (this);
  }

  userDataQosPolicy&
  userDataQosPolicy::operator= (userDataQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);
    }

    return *this;
  }


  // userDataQosPolicy
  bool userDataQosPolicy::
  value_p () const
  {
    return value_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& userDataQosPolicy::
  value () const
  {
    return *value_;
  }

  void userDataQosPolicy::
  value (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (value_.get ())
    {
      *value_ = e;
    }

    else
    {
      value_ = userDataQosPolicy::value_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      value_->container (this);
    }
  }


  // writerDataLifecycleQosPolicy

  writerDataLifecycleQosPolicy::writerDataLifecycleQosPolicy ()
  : ::XSCRT::Type ()
  {
  }

  writerDataLifecycleQosPolicy::writerDataLifecycleQosPolicy (writerDataLifecycleQosPolicy const& s) :
  ::XSCRT::Type (s)
  , autodispose_unregistered_instances_ (s.autodispose_unregistered_instances_.get () ? new ::XMLSchema::boolean (*s.autodispose_unregistered_instances_) : 0)
  {
    if (autodispose_unregistered_instances_.get ()) autodispose_unregistered_instances_->container (this);
  }

  writerDataLifecycleQosPolicy&
  writerDataLifecycleQosPolicy::operator= (writerDataLifecycleQosPolicy const& s)
  {
    if (&s != this)
    {
      if (s.autodispose_unregistered_instances_.get ())
        autodispose_unregistered_instances (*(s.autodispose_unregistered_instances_));
      else
        autodispose_unregistered_instances_.reset (0);
    }

    return *this;
  }


  // writerDataLifecycleQosPolicy
  bool writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances_p () const
  {
    return autodispose_unregistered_instances_.get () != 0;
  }

  ::XMLSchema::boolean const& writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances () const
  {
    return *autodispose_unregistered_instances_;
  }

  void writerDataLifecycleQosPolicy::
  autodispose_unregistered_instances (::XMLSchema::boolean const& e)
  {
    if (autodispose_unregistered_instances_.get ())
    {
      *autodispose_unregistered_instances_ = e;
    }

    else
    {
      autodispose_unregistered_instances_ = writerDataLifecycleQosPolicy::autodispose_unregistered_instances_auto_ptr_type (new ::XMLSchema::boolean (e));
      autodispose_unregistered_instances_->container (this);
    }
  }


  // domainparticipantQos

  domainparticipantQos::domainparticipantQos ()
  : ::XSCRT::Type ()
  {
  }

  domainparticipantQos::domainparticipantQos (domainparticipantQos const& s) :
  ::XSCRT::Type (s)
  , user_data_ (s.user_data_.get () ? new ::dds::userDataQosPolicy (*s.user_data_) : 0)
  , entity_factory_ (s.entity_factory_.get () ? new ::dds::entityFactoryQosPolicy (*s.entity_factory_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  {
    if (user_data_.get ()) user_data_->container (this);
    if (entity_factory_.get ()) entity_factory_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
  }

  domainparticipantQos&
  domainparticipantQos::operator= (domainparticipantQos const& s)
  {
    if (&s != this)
    {
      if (s.user_data_.get ())
        user_data (*(s.user_data_));
      else
        user_data_.reset (0);

      if (s.entity_factory_.get ())
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);
    }

    return *this;
  }


  // domainparticipantQos
  bool domainparticipantQos::
  user_data_p () const
  {
    return user_data_.get () != 0;
  }

  ::dds::userDataQosPolicy const& domainparticipantQos::
  user_data () const
  {
    return *user_data_;
  }

  void domainparticipantQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_.get ())
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = domainparticipantQos::user_data_auto_ptr_type (new ::dds::userDataQosPolicy (e));
      user_data_->container (this);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  entity_factory_p () const
  {
    return entity_factory_.get () != 0;
  }

  ::dds::entityFactoryQosPolicy const& domainparticipantQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void domainparticipantQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_.get ())
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = domainparticipantQos::entity_factory_auto_ptr_type (new ::dds::entityFactoryQosPolicy (e));
      entity_factory_->container (this);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& domainparticipantQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& domainparticipantQos::
  name ()
  {
    return *name_;
  }

  void domainparticipantQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = domainparticipantQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // domainparticipantQos
  bool domainparticipantQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& domainparticipantQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& domainparticipantQos::
  base_name ()
  {
    return *base_name_;
  }

  void domainparticipantQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = domainparticipantQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }


  // publisherQos

  publisherQos::publisherQos ()
  : ::XSCRT::Type ()
  {
  }

  publisherQos::publisherQos (publisherQos const& s) :
  ::XSCRT::Type (s)
  , presentation_ (s.presentation_.get () ? new ::dds::presentationQosPolicy (*s.presentation_) : 0)
  , partition_ (s.partition_.get () ? new ::dds::partitionQosPolicy (*s.partition_) : 0)
  , group_data_ (s.group_data_.get () ? new ::dds::groupDataQosPolicy (*s.group_data_) : 0)
  , entity_factory_ (s.entity_factory_.get () ? new ::dds::entityFactoryQosPolicy (*s.entity_factory_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  {
    if (presentation_.get ()) presentation_->container (this);
    if (partition_.get ()) partition_->container (this);
    if (group_data_.get ()) group_data_->container (this);
    if (entity_factory_.get ()) entity_factory_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
  }

  publisherQos&
  publisherQos::operator= (publisherQos const& s)
  {
    if (&s != this)
    {
      if (s.presentation_.get ())
        presentation (*(s.presentation_));
      else
        presentation_.reset (0);

      if (s.partition_.get ())
        partition (*(s.partition_));
      else
        partition_.reset (0);

      if (s.group_data_.get ())
        group_data (*(s.group_data_));
      else
        group_data_.reset (0);

      if (s.entity_factory_.get ())
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);
    }

    return *this;
  }


  // publisherQos
  bool publisherQos::
  presentation_p () const
  {
    return presentation_.get () != 0;
  }

  ::dds::presentationQosPolicy const& publisherQos::
  presentation () const
  {
    return *presentation_;
  }

  void publisherQos::
  presentation (::dds::presentationQosPolicy const& e)
  {
    if (presentation_.get ())
    {
      *presentation_ = e;
    }

    else
    {
      presentation_ = publisherQos::presentation_auto_ptr_type (new ::dds::presentationQosPolicy (e));
      presentation_->container (this);
    }
  }

  // publisherQos
  bool publisherQos::
  partition_p () const
  {
    return partition_.get () != 0;
  }

  ::dds::partitionQosPolicy const& publisherQos::
  partition () const
  {
    return *partition_;
  }

  void publisherQos::
  partition (::dds::partitionQosPolicy const& e)
  {
    if (partition_.get ())
    {
      *partition_ = e;
    }

    else
    {
      partition_ = publisherQos::partition_auto_ptr_type (new ::dds::partitionQosPolicy (e));
      partition_->container (this);
    }
  }

  // publisherQos
  bool publisherQos::
  group_data_p () const
  {
    return group_data_.get () != 0;
  }

  ::dds::groupDataQosPolicy const& publisherQos::
  group_data () const
  {
    return *group_data_;
  }

  void publisherQos::
  group_data (::dds::groupDataQosPolicy const& e)
  {
    if (group_data_.get ())
    {
      *group_data_ = e;
    }

    else
    {
      group_data_ = publisherQos::group_data_auto_ptr_type (new ::dds::groupDataQosPolicy (e));
      group_data_->container (this);
    }
  }

  // publisherQos
  bool publisherQos::
  entity_factory_p () const
  {
    return entity_factory_.get () != 0;
  }

  ::dds::entityFactoryQosPolicy const& publisherQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void publisherQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_.get ())
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = publisherQos::entity_factory_auto_ptr_type (new ::dds::entityFactoryQosPolicy (e));
      entity_factory_->container (this);
    }
  }

  // publisherQos
  bool publisherQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& publisherQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& publisherQos::
  name ()
  {
    return *name_;
  }

  void publisherQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = publisherQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // publisherQos
  bool publisherQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& publisherQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& publisherQos::
  base_name ()
  {
    return *base_name_;
  }

  void publisherQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = publisherQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }


  // subscriberQos

  subscriberQos::subscriberQos ()
  : ::XSCRT::Type ()
  {
  }

  subscriberQos::subscriberQos (subscriberQos const& s) :
  ::XSCRT::Type (s)
  , presentation_ (s.presentation_.get () ? new ::dds::presentationQosPolicy (*s.presentation_) : 0)
  , partition_ (s.partition_.get () ? new ::dds::partitionQosPolicy (*s.partition_) : 0)
  , group_data_ (s.group_data_.get () ? new ::dds::groupDataQosPolicy (*s.group_data_) : 0)
  , entity_factory_ (s.entity_factory_.get () ? new ::dds::entityFactoryQosPolicy (*s.entity_factory_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  {
    if (presentation_.get ()) presentation_->container (this);
    if (partition_.get ()) partition_->container (this);
    if (group_data_.get ()) group_data_->container (this);
    if (entity_factory_.get ()) entity_factory_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
  }

  subscriberQos&
  subscriberQos::operator= (subscriberQos const& s)
  {
    if (&s != this)
    {
      if (s.presentation_.get ())
        presentation (*(s.presentation_));
      else
        presentation_.reset (0);

      if (s.partition_.get ())
        partition (*(s.partition_));
      else
        partition_.reset (0);

      if (s.group_data_.get ())
        group_data (*(s.group_data_));
      else
        group_data_.reset (0);

      if (s.entity_factory_.get ())
        entity_factory (*(s.entity_factory_));
      else
        entity_factory_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);
    }

    return *this;
  }


  // subscriberQos
  bool subscriberQos::
  presentation_p () const
  {
    return presentation_.get () != 0;
  }

  ::dds::presentationQosPolicy const& subscriberQos::
  presentation () const
  {
    return *presentation_;
  }

  void subscriberQos::
  presentation (::dds::presentationQosPolicy const& e)
  {
    if (presentation_.get ())
    {
      *presentation_ = e;
    }

    else
    {
      presentation_ = subscriberQos::presentation_auto_ptr_type (new ::dds::presentationQosPolicy (e));
      presentation_->container (this);
    }
  }

  // subscriberQos
  bool subscriberQos::
  partition_p () const
  {
    return partition_.get () != 0;
  }

  ::dds::partitionQosPolicy const& subscriberQos::
  partition () const
  {
    return *partition_;
  }

  void subscriberQos::
  partition (::dds::partitionQosPolicy const& e)
  {
    if (partition_.get ())
    {
      *partition_ = e;
    }

    else
    {
      partition_ = subscriberQos::partition_auto_ptr_type (new ::dds::partitionQosPolicy (e));
      partition_->container (this);
    }
  }

  // subscriberQos
  bool subscriberQos::
  group_data_p () const
  {
    return group_data_.get () != 0;
  }

  ::dds::groupDataQosPolicy const& subscriberQos::
  group_data () const
  {
    return *group_data_;
  }

  void subscriberQos::
  group_data (::dds::groupDataQosPolicy const& e)
  {
    if (group_data_.get ())
    {
      *group_data_ = e;
    }

    else
    {
      group_data_ = subscriberQos::group_data_auto_ptr_type (new ::dds::groupDataQosPolicy (e));
      group_data_->container (this);
    }
  }

  // subscriberQos
  bool subscriberQos::
  entity_factory_p () const
  {
    return entity_factory_.get () != 0;
  }

  ::dds::entityFactoryQosPolicy const& subscriberQos::
  entity_factory () const
  {
    return *entity_factory_;
  }

  void subscriberQos::
  entity_factory (::dds::entityFactoryQosPolicy const& e)
  {
    if (entity_factory_.get ())
    {
      *entity_factory_ = e;
    }

    else
    {
      entity_factory_ = subscriberQos::entity_factory_auto_ptr_type (new ::dds::entityFactoryQosPolicy (e));
      entity_factory_->container (this);
    }
  }

  // subscriberQos
  bool subscriberQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& subscriberQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& subscriberQos::
  name ()
  {
    return *name_;
  }

  void subscriberQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = subscriberQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // subscriberQos
  bool subscriberQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& subscriberQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& subscriberQos::
  base_name ()
  {
    return *base_name_;
  }

  void subscriberQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = subscriberQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }


  // topicQos

  topicQos::topicQos ()
  : ::XSCRT::Type ()
  {
  }

  topicQos::topicQos (topicQos const& s) :
  ::XSCRT::Type (s)
  , topic_data_ (s.topic_data_.get () ? new ::dds::topicDataQosPolicy (*s.topic_data_) : 0)
  , durability_ (s.durability_.get () ? new ::dds::durabilityQosPolicy (*s.durability_) : 0)
  , durability_service_ (s.durability_service_.get () ? new ::dds::durabilityServiceQosPolicy (*s.durability_service_) : 0)
  , deadline_ (s.deadline_.get () ? new ::dds::deadlineQosPolicy (*s.deadline_) : 0)
  , latency_budget_ (s.latency_budget_.get () ? new ::dds::latencyBudgetQosPolicy (*s.latency_budget_) : 0)
  , liveliness_ (s.liveliness_.get () ? new ::dds::livelinessQosPolicy (*s.liveliness_) : 0)
  , reliability_ (s.reliability_.get () ? new ::dds::reliabilityQosPolicy (*s.reliability_) : 0)
  , destination_order_ (s.destination_order_.get () ? new ::dds::destinationOrderQosPolicy (*s.destination_order_) : 0)
  , history_ (s.history_.get () ? new ::dds::historyQosPolicy (*s.history_) : 0)
  , resource_limits_ (s.resource_limits_.get () ? new ::dds::resourceLimitsQosPolicy (*s.resource_limits_) : 0)
  , transport_priority_ (s.transport_priority_.get () ? new ::dds::transportPriorityQosPolicy (*s.transport_priority_) : 0)
  , lifespan_ (s.lifespan_.get () ? new ::dds::lifespanQosPolicy (*s.lifespan_) : 0)
  , ownership_ (s.ownership_.get () ? new ::dds::ownershipQosPolicy (*s.ownership_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  , topic_filter_ (s.topic_filter_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.topic_filter_) : 0)
  {
    if (topic_data_.get ()) topic_data_->container (this);
    if (durability_.get ()) durability_->container (this);
    if (durability_service_.get ()) durability_service_->container (this);
    if (deadline_.get ()) deadline_->container (this);
    if (latency_budget_.get ()) latency_budget_->container (this);
    if (liveliness_.get ()) liveliness_->container (this);
    if (reliability_.get ()) reliability_->container (this);
    if (destination_order_.get ()) destination_order_->container (this);
    if (history_.get ()) history_->container (this);
    if (resource_limits_.get ()) resource_limits_->container (this);
    if (transport_priority_.get ()) transport_priority_->container (this);
    if (lifespan_.get ()) lifespan_->container (this);
    if (ownership_.get ()) ownership_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
    if (topic_filter_.get ()) topic_filter_->container (this);
  }

  topicQos&
  topicQos::operator= (topicQos const& s)
  {
    if (&s != this)
    {
      if (s.topic_data_.get ())
        topic_data (*(s.topic_data_));
      else
        topic_data_.reset (0);

      if (s.durability_.get ())
        durability (*(s.durability_));
      else
        durability_.reset (0);

      if (s.durability_service_.get ())
        durability_service (*(s.durability_service_));
      else
        durability_service_.reset (0);

      if (s.deadline_.get ())
        deadline (*(s.deadline_));
      else
        deadline_.reset (0);

      if (s.latency_budget_.get ())
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.reset (0);

      if (s.liveliness_.get ())
        liveliness (*(s.liveliness_));
      else
        liveliness_.reset (0);

      if (s.reliability_.get ())
        reliability (*(s.reliability_));
      else
        reliability_.reset (0);

      if (s.destination_order_.get ())
        destination_order (*(s.destination_order_));
      else
        destination_order_.reset (0);

      if (s.history_.get ())
        history (*(s.history_));
      else
        history_.reset (0);

      if (s.resource_limits_.get ())
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.reset (0);

      if (s.transport_priority_.get ())
        transport_priority (*(s.transport_priority_));
      else
        transport_priority_.reset (0);

      if (s.lifespan_.get ())
        lifespan (*(s.lifespan_));
      else
        lifespan_.reset (0);

      if (s.ownership_.get ())
        ownership (*(s.ownership_));
      else
        ownership_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);

      if (s.topic_filter_.get ()) topic_filter (*(s.topic_filter_));
      else topic_filter_.reset (0);
    }

    return *this;
  }


  // topicQos
  bool topicQos::
  topic_data_p () const
  {
    return topic_data_.get () != 0;
  }

  ::dds::topicDataQosPolicy const& topicQos::
  topic_data () const
  {
    return *topic_data_;
  }

  void topicQos::
  topic_data (::dds::topicDataQosPolicy const& e)
  {
    if (topic_data_.get ())
    {
      *topic_data_ = e;
    }

    else
    {
      topic_data_ = topicQos::topic_data_auto_ptr_type (new ::dds::topicDataQosPolicy (e));
      topic_data_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  durability_p () const
  {
    return durability_.get () != 0;
  }

  ::dds::durabilityQosPolicy const& topicQos::
  durability () const
  {
    return *durability_;
  }

  void topicQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_.get ())
    {
      *durability_ = e;
    }

    else
    {
      durability_ = topicQos::durability_auto_ptr_type (new ::dds::durabilityQosPolicy (e));
      durability_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  durability_service_p () const
  {
    return durability_service_.get () != 0;
  }

  ::dds::durabilityServiceQosPolicy const& topicQos::
  durability_service () const
  {
    return *durability_service_;
  }

  void topicQos::
  durability_service (::dds::durabilityServiceQosPolicy const& e)
  {
    if (durability_service_.get ())
    {
      *durability_service_ = e;
    }

    else
    {
      durability_service_ = topicQos::durability_service_auto_ptr_type (new ::dds::durabilityServiceQosPolicy (e));
      durability_service_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  deadline_p () const
  {
    return deadline_.get () != 0;
  }

  ::dds::deadlineQosPolicy const& topicQos::
  deadline () const
  {
    return *deadline_;
  }

  void topicQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_.get ())
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = topicQos::deadline_auto_ptr_type (new ::dds::deadlineQosPolicy (e));
      deadline_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  latency_budget_p () const
  {
    return latency_budget_.get () != 0;
  }

  ::dds::latencyBudgetQosPolicy const& topicQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void topicQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_.get ())
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = topicQos::latency_budget_auto_ptr_type (new ::dds::latencyBudgetQosPolicy (e));
      latency_budget_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  liveliness_p () const
  {
    return liveliness_.get () != 0;
  }

  ::dds::livelinessQosPolicy const& topicQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void topicQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_.get ())
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = topicQos::liveliness_auto_ptr_type (new ::dds::livelinessQosPolicy (e));
      liveliness_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  reliability_p () const
  {
    return reliability_.get () != 0;
  }

  ::dds::reliabilityQosPolicy const& topicQos::
  reliability () const
  {
    return *reliability_;
  }

  void topicQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_.get ())
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = topicQos::reliability_auto_ptr_type (new ::dds::reliabilityQosPolicy (e));
      reliability_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  destination_order_p () const
  {
    return destination_order_.get () != 0;
  }

  ::dds::destinationOrderQosPolicy const& topicQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void topicQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_.get ())
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = topicQos::destination_order_auto_ptr_type (new ::dds::destinationOrderQosPolicy (e));
      destination_order_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  history_p () const
  {
    return history_.get () != 0;
  }

  ::dds::historyQosPolicy const& topicQos::
  history () const
  {
    return *history_;
  }

  void topicQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_.get ())
    {
      *history_ = e;
    }

    else
    {
      history_ = topicQos::history_auto_ptr_type (new ::dds::historyQosPolicy (e));
      history_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  resource_limits_p () const
  {
    return resource_limits_.get () != 0;
  }

  ::dds::resourceLimitsQosPolicy const& topicQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void topicQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_.get ())
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = topicQos::resource_limits_auto_ptr_type (new ::dds::resourceLimitsQosPolicy (e));
      resource_limits_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  transport_priority_p () const
  {
    return transport_priority_.get () != 0;
  }

  ::dds::transportPriorityQosPolicy const& topicQos::
  transport_priority () const
  {
    return *transport_priority_;
  }

  void topicQos::
  transport_priority (::dds::transportPriorityQosPolicy const& e)
  {
    if (transport_priority_.get ())
    {
      *transport_priority_ = e;
    }

    else
    {
      transport_priority_ = topicQos::transport_priority_auto_ptr_type (new ::dds::transportPriorityQosPolicy (e));
      transport_priority_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  lifespan_p () const
  {
    return lifespan_.get () != 0;
  }

  ::dds::lifespanQosPolicy const& topicQos::
  lifespan () const
  {
    return *lifespan_;
  }

  void topicQos::
  lifespan (::dds::lifespanQosPolicy const& e)
  {
    if (lifespan_.get ())
    {
      *lifespan_ = e;
    }

    else
    {
      lifespan_ = topicQos::lifespan_auto_ptr_type (new ::dds::lifespanQosPolicy (e));
      lifespan_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  ownership_p () const
  {
    return ownership_.get () != 0;
  }

  ::dds::ownershipQosPolicy const& topicQos::
  ownership () const
  {
    return *ownership_;
  }

  void topicQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_.get ())
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = topicQos::ownership_auto_ptr_type (new ::dds::ownershipQosPolicy (e));
      ownership_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  name ()
  {
    return *name_;
  }

  void topicQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = topicQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  base_name ()
  {
    return *base_name_;
  }

  void topicQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = topicQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }

  // topicQos
  bool topicQos::
  topic_filter_p () const
  {
    return topic_filter_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& topicQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& topicQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void topicQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_.get ())
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = topicQos::topic_filter_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      topic_filter_->container (this);
    }
  }


  // datareaderQos

  datareaderQos::datareaderQos ()
  : ::XSCRT::Type ()
  {
  }

  datareaderQos::datareaderQos (datareaderQos const& s) :
  ::XSCRT::Type (s)
  , durability_ (s.durability_.get () ? new ::dds::durabilityQosPolicy (*s.durability_) : 0)
  , deadline_ (s.deadline_.get () ? new ::dds::deadlineQosPolicy (*s.deadline_) : 0)
  , latency_budget_ (s.latency_budget_.get () ? new ::dds::latencyBudgetQosPolicy (*s.latency_budget_) : 0)
  , liveliness_ (s.liveliness_.get () ? new ::dds::livelinessQosPolicy (*s.liveliness_) : 0)
  , reliability_ (s.reliability_.get () ? new ::dds::reliabilityQosPolicy (*s.reliability_) : 0)
  , destination_order_ (s.destination_order_.get () ? new ::dds::destinationOrderQosPolicy (*s.destination_order_) : 0)
  , history_ (s.history_.get () ? new ::dds::historyQosPolicy (*s.history_) : 0)
  , resource_limits_ (s.resource_limits_.get () ? new ::dds::resourceLimitsQosPolicy (*s.resource_limits_) : 0)
  , user_data_ (s.user_data_.get () ? new ::dds::userDataQosPolicy (*s.user_data_) : 0)
  , ownership_ (s.ownership_.get () ? new ::dds::ownershipQosPolicy (*s.ownership_) : 0)
  , time_based_filter_ (s.time_based_filter_.get () ? new ::dds::timeBasedFilterQosPolicy (*s.time_based_filter_) : 0)
  , reader_data_lifecycle_ (s.reader_data_lifecycle_.get () ? new ::dds::readerDataLifecycleQosPolicy (*s.reader_data_lifecycle_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  , topic_filter_ (s.topic_filter_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.topic_filter_) : 0)
  {
    if (durability_.get ()) durability_->container (this);
    if (deadline_.get ()) deadline_->container (this);
    if (latency_budget_.get ()) latency_budget_->container (this);
    if (liveliness_.get ()) liveliness_->container (this);
    if (reliability_.get ()) reliability_->container (this);
    if (destination_order_.get ()) destination_order_->container (this);
    if (history_.get ()) history_->container (this);
    if (resource_limits_.get ()) resource_limits_->container (this);
    if (user_data_.get ()) user_data_->container (this);
    if (ownership_.get ()) ownership_->container (this);
    if (time_based_filter_.get ()) time_based_filter_->container (this);
    if (reader_data_lifecycle_.get ()) reader_data_lifecycle_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
    if (topic_filter_.get ()) topic_filter_->container (this);
  }

  datareaderQos&
  datareaderQos::operator= (datareaderQos const& s)
  {
    if (&s != this)
    {
      if (s.durability_.get ())
        durability (*(s.durability_));
      else
        durability_.reset (0);

      if (s.deadline_.get ())
        deadline (*(s.deadline_));
      else
        deadline_.reset (0);

      if (s.latency_budget_.get ())
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.reset (0);

      if (s.liveliness_.get ())
        liveliness (*(s.liveliness_));
      else
        liveliness_.reset (0);

      if (s.reliability_.get ())
        reliability (*(s.reliability_));
      else
        reliability_.reset (0);

      if (s.destination_order_.get ())
        destination_order (*(s.destination_order_));
      else
        destination_order_.reset (0);

      if (s.history_.get ())
        history (*(s.history_));
      else
        history_.reset (0);

      if (s.resource_limits_.get ())
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.reset (0);

      if (s.user_data_.get ())
        user_data (*(s.user_data_));
      else
        user_data_.reset (0);

      if (s.ownership_.get ())
        ownership (*(s.ownership_));
      else
        ownership_.reset (0);

      if (s.time_based_filter_.get ())
        time_based_filter (*(s.time_based_filter_));
      else
        time_based_filter_.reset (0);

      if (s.reader_data_lifecycle_.get ())
        reader_data_lifecycle (*(s.reader_data_lifecycle_));
      else
        reader_data_lifecycle_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);

      if (s.topic_filter_.get ()) topic_filter (*(s.topic_filter_));
      else topic_filter_.reset (0);
    }

    return *this;
  }


  // datareaderQos
  bool datareaderQos::
  durability_p () const
  {
    return durability_.get () != 0;
  }

  ::dds::durabilityQosPolicy const& datareaderQos::
  durability () const
  {
    return *durability_;
  }

  void datareaderQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_.get ())
    {
      *durability_ = e;
    }

    else
    {
      durability_ = datareaderQos::durability_auto_ptr_type (new ::dds::durabilityQosPolicy (e));
      durability_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  deadline_p () const
  {
    return deadline_.get () != 0;
  }

  ::dds::deadlineQosPolicy const& datareaderQos::
  deadline () const
  {
    return *deadline_;
  }

  void datareaderQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_.get ())
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = datareaderQos::deadline_auto_ptr_type (new ::dds::deadlineQosPolicy (e));
      deadline_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  latency_budget_p () const
  {
    return latency_budget_.get () != 0;
  }

  ::dds::latencyBudgetQosPolicy const& datareaderQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void datareaderQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_.get ())
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = datareaderQos::latency_budget_auto_ptr_type (new ::dds::latencyBudgetQosPolicy (e));
      latency_budget_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  liveliness_p () const
  {
    return liveliness_.get () != 0;
  }

  ::dds::livelinessQosPolicy const& datareaderQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void datareaderQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_.get ())
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = datareaderQos::liveliness_auto_ptr_type (new ::dds::livelinessQosPolicy (e));
      liveliness_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  reliability_p () const
  {
    return reliability_.get () != 0;
  }

  ::dds::reliabilityQosPolicy const& datareaderQos::
  reliability () const
  {
    return *reliability_;
  }

  void datareaderQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_.get ())
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = datareaderQos::reliability_auto_ptr_type (new ::dds::reliabilityQosPolicy (e));
      reliability_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  destination_order_p () const
  {
    return destination_order_.get () != 0;
  }

  ::dds::destinationOrderQosPolicy const& datareaderQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void datareaderQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_.get ())
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = datareaderQos::destination_order_auto_ptr_type (new ::dds::destinationOrderQosPolicy (e));
      destination_order_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  history_p () const
  {
    return history_.get () != 0;
  }

  ::dds::historyQosPolicy const& datareaderQos::
  history () const
  {
    return *history_;
  }

  void datareaderQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_.get ())
    {
      *history_ = e;
    }

    else
    {
      history_ = datareaderQos::history_auto_ptr_type (new ::dds::historyQosPolicy (e));
      history_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  resource_limits_p () const
  {
    return resource_limits_.get () != 0;
  }

  ::dds::resourceLimitsQosPolicy const& datareaderQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void datareaderQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_.get ())
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = datareaderQos::resource_limits_auto_ptr_type (new ::dds::resourceLimitsQosPolicy (e));
      resource_limits_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  user_data_p () const
  {
    return user_data_.get () != 0;
  }

  ::dds::userDataQosPolicy const& datareaderQos::
  user_data () const
  {
    return *user_data_;
  }

  void datareaderQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_.get ())
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = datareaderQos::user_data_auto_ptr_type (new ::dds::userDataQosPolicy (e));
      user_data_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  ownership_p () const
  {
    return ownership_.get () != 0;
  }

  ::dds::ownershipQosPolicy const& datareaderQos::
  ownership () const
  {
    return *ownership_;
  }

  void datareaderQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_.get ())
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = datareaderQos::ownership_auto_ptr_type (new ::dds::ownershipQosPolicy (e));
      ownership_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  time_based_filter_p () const
  {
    return time_based_filter_.get () != 0;
  }

  ::dds::timeBasedFilterQosPolicy const& datareaderQos::
  time_based_filter () const
  {
    return *time_based_filter_;
  }

  void datareaderQos::
  time_based_filter (::dds::timeBasedFilterQosPolicy const& e)
  {
    if (time_based_filter_.get ())
    {
      *time_based_filter_ = e;
    }

    else
    {
      time_based_filter_ = datareaderQos::time_based_filter_auto_ptr_type (new ::dds::timeBasedFilterQosPolicy (e));
      time_based_filter_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  reader_data_lifecycle_p () const
  {
    return reader_data_lifecycle_.get () != 0;
  }

  ::dds::readerDataLifecycleQosPolicy const& datareaderQos::
  reader_data_lifecycle () const
  {
    return *reader_data_lifecycle_;
  }

  void datareaderQos::
  reader_data_lifecycle (::dds::readerDataLifecycleQosPolicy const& e)
  {
    if (reader_data_lifecycle_.get ())
    {
      *reader_data_lifecycle_ = e;
    }

    else
    {
      reader_data_lifecycle_ = datareaderQos::reader_data_lifecycle_auto_ptr_type (new ::dds::readerDataLifecycleQosPolicy (e));
      reader_data_lifecycle_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  name ()
  {
    return *name_;
  }

  void datareaderQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = datareaderQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  base_name ()
  {
    return *base_name_;
  }

  void datareaderQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = datareaderQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }

  // datareaderQos
  bool datareaderQos::
  topic_filter_p () const
  {
    return topic_filter_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datareaderQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datareaderQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void datareaderQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_.get ())
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = datareaderQos::topic_filter_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      topic_filter_->container (this);
    }
  }


  // datawriterQos

  datawriterQos::datawriterQos ()
  : ::XSCRT::Type ()
  {
  }

  datawriterQos::datawriterQos (datawriterQos const& s) :
  ::XSCRT::Type (s)
  , durability_ (s.durability_.get () ? new ::dds::durabilityQosPolicy (*s.durability_) : 0)
  , durability_service_ (s.durability_service_.get () ? new ::dds::durabilityServiceQosPolicy (*s.durability_service_) : 0)
  , deadline_ (s.deadline_.get () ? new ::dds::deadlineQosPolicy (*s.deadline_) : 0)
  , latency_budget_ (s.latency_budget_.get () ? new ::dds::latencyBudgetQosPolicy (*s.latency_budget_) : 0)
  , liveliness_ (s.liveliness_.get () ? new ::dds::livelinessQosPolicy (*s.liveliness_) : 0)
  , reliability_ (s.reliability_.get () ? new ::dds::reliabilityQosPolicy (*s.reliability_) : 0)
  , destination_order_ (s.destination_order_.get () ? new ::dds::destinationOrderQosPolicy (*s.destination_order_) : 0)
  , history_ (s.history_.get () ? new ::dds::historyQosPolicy (*s.history_) : 0)
  , resource_limits_ (s.resource_limits_.get () ? new ::dds::resourceLimitsQosPolicy (*s.resource_limits_) : 0)
  , transport_priority_ (s.transport_priority_.get () ? new ::dds::transportPriorityQosPolicy (*s.transport_priority_) : 0)
  , lifespan_ (s.lifespan_.get () ? new ::dds::lifespanQosPolicy (*s.lifespan_) : 0)
  , user_data_ (s.user_data_.get () ? new ::dds::userDataQosPolicy (*s.user_data_) : 0)
  , ownership_ (s.ownership_.get () ? new ::dds::ownershipQosPolicy (*s.ownership_) : 0)
  , ownership_strength_ (s.ownership_strength_.get () ? new ::dds::ownershipStrengthQosPolicy (*s.ownership_strength_) : 0)
  , writer_data_lifecycle_ (s.writer_data_lifecycle_.get () ? new ::dds::writerDataLifecycleQosPolicy (*s.writer_data_lifecycle_) : 0)
  , name_ (s.name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.name_) : 0)
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  , topic_filter_ (s.topic_filter_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.topic_filter_) : 0)
  {
    if (durability_.get ()) durability_->container (this);
    if (durability_service_.get ()) durability_service_->container (this);
    if (deadline_.get ()) deadline_->container (this);
    if (latency_budget_.get ()) latency_budget_->container (this);
    if (liveliness_.get ()) liveliness_->container (this);
    if (reliability_.get ()) reliability_->container (this);
    if (destination_order_.get ()) destination_order_->container (this);
    if (history_.get ()) history_->container (this);
    if (resource_limits_.get ()) resource_limits_->container (this);
    if (transport_priority_.get ()) transport_priority_->container (this);
    if (lifespan_.get ()) lifespan_->container (this);
    if (user_data_.get ()) user_data_->container (this);
    if (ownership_.get ()) ownership_->container (this);
    if (ownership_strength_.get ()) ownership_strength_->container (this);
    if (writer_data_lifecycle_.get ()) writer_data_lifecycle_->container (this);
    if (name_.get ()) name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
    if (topic_filter_.get ()) topic_filter_->container (this);
  }

  datawriterQos&
  datawriterQos::operator= (datawriterQos const& s)
  {
    if (&s != this)
    {
      if (s.durability_.get ())
        durability (*(s.durability_));
      else
        durability_.reset (0);

      if (s.durability_service_.get ())
        durability_service (*(s.durability_service_));
      else
        durability_service_.reset (0);

      if (s.deadline_.get ())
        deadline (*(s.deadline_));
      else
        deadline_.reset (0);

      if (s.latency_budget_.get ())
        latency_budget (*(s.latency_budget_));
      else
        latency_budget_.reset (0);

      if (s.liveliness_.get ())
        liveliness (*(s.liveliness_));
      else
        liveliness_.reset (0);

      if (s.reliability_.get ())
        reliability (*(s.reliability_));
      else
        reliability_.reset (0);

      if (s.destination_order_.get ())
        destination_order (*(s.destination_order_));
      else
        destination_order_.reset (0);

      if (s.history_.get ())
        history (*(s.history_));
      else
        history_.reset (0);

      if (s.resource_limits_.get ())
        resource_limits (*(s.resource_limits_));
      else
        resource_limits_.reset (0);

      if (s.transport_priority_.get ())
        transport_priority (*(s.transport_priority_));
      else
        transport_priority_.reset (0);

      if (s.lifespan_.get ())
        lifespan (*(s.lifespan_));
      else
        lifespan_.reset (0);

      if (s.user_data_.get ())
        user_data (*(s.user_data_));
      else
        user_data_.reset (0);

      if (s.ownership_.get ())
        ownership (*(s.ownership_));
      else
        ownership_.reset (0);

      if (s.ownership_strength_.get ())
        ownership_strength (*(s.ownership_strength_));
      else
        ownership_strength_.reset (0);

      if (s.writer_data_lifecycle_.get ())
        writer_data_lifecycle (*(s.writer_data_lifecycle_));
      else
        writer_data_lifecycle_.reset (0);

      if (s.name_.get ()) name (*(s.name_));
      else name_.reset (0);

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);

      if (s.topic_filter_.get ()) topic_filter (*(s.topic_filter_));
      else topic_filter_.reset (0);
    }

    return *this;
  }


  // datawriterQos
  bool datawriterQos::
  durability_p () const
  {
    return durability_.get () != 0;
  }

  ::dds::durabilityQosPolicy const& datawriterQos::
  durability () const
  {
    return *durability_;
  }

  void datawriterQos::
  durability (::dds::durabilityQosPolicy const& e)
  {
    if (durability_.get ())
    {
      *durability_ = e;
    }

    else
    {
      durability_ = datawriterQos::durability_auto_ptr_type (new ::dds::durabilityQosPolicy (e));
      durability_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  durability_service_p () const
  {
    return durability_service_.get () != 0;
  }

  ::dds::durabilityServiceQosPolicy const& datawriterQos::
  durability_service () const
  {
    return *durability_service_;
  }

  void datawriterQos::
  durability_service (::dds::durabilityServiceQosPolicy const& e)
  {
    if (durability_service_.get ())
    {
      *durability_service_ = e;
    }

    else
    {
      durability_service_ = datawriterQos::durability_service_auto_ptr_type (new ::dds::durabilityServiceQosPolicy (e));
      durability_service_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  deadline_p () const
  {
    return deadline_.get () != 0;
  }

  ::dds::deadlineQosPolicy const& datawriterQos::
  deadline () const
  {
    return *deadline_;
  }

  void datawriterQos::
  deadline (::dds::deadlineQosPolicy const& e)
  {
    if (deadline_.get ())
    {
      *deadline_ = e;
    }

    else
    {
      deadline_ = datawriterQos::deadline_auto_ptr_type (new ::dds::deadlineQosPolicy (e));
      deadline_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  latency_budget_p () const
  {
    return latency_budget_.get () != 0;
  }

  ::dds::latencyBudgetQosPolicy const& datawriterQos::
  latency_budget () const
  {
    return *latency_budget_;
  }

  void datawriterQos::
  latency_budget (::dds::latencyBudgetQosPolicy const& e)
  {
    if (latency_budget_.get ())
    {
      *latency_budget_ = e;
    }

    else
    {
      latency_budget_ = datawriterQos::latency_budget_auto_ptr_type (new ::dds::latencyBudgetQosPolicy (e));
      latency_budget_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  liveliness_p () const
  {
    return liveliness_.get () != 0;
  }

  ::dds::livelinessQosPolicy const& datawriterQos::
  liveliness () const
  {
    return *liveliness_;
  }

  void datawriterQos::
  liveliness (::dds::livelinessQosPolicy const& e)
  {
    if (liveliness_.get ())
    {
      *liveliness_ = e;
    }

    else
    {
      liveliness_ = datawriterQos::liveliness_auto_ptr_type (new ::dds::livelinessQosPolicy (e));
      liveliness_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  reliability_p () const
  {
    return reliability_.get () != 0;
  }

  ::dds::reliabilityQosPolicy const& datawriterQos::
  reliability () const
  {
    return *reliability_;
  }

  void datawriterQos::
  reliability (::dds::reliabilityQosPolicy const& e)
  {
    if (reliability_.get ())
    {
      *reliability_ = e;
    }

    else
    {
      reliability_ = datawriterQos::reliability_auto_ptr_type (new ::dds::reliabilityQosPolicy (e));
      reliability_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  destination_order_p () const
  {
    return destination_order_.get () != 0;
  }

  ::dds::destinationOrderQosPolicy const& datawriterQos::
  destination_order () const
  {
    return *destination_order_;
  }

  void datawriterQos::
  destination_order (::dds::destinationOrderQosPolicy const& e)
  {
    if (destination_order_.get ())
    {
      *destination_order_ = e;
    }

    else
    {
      destination_order_ = datawriterQos::destination_order_auto_ptr_type (new ::dds::destinationOrderQosPolicy (e));
      destination_order_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  history_p () const
  {
    return history_.get () != 0;
  }

  ::dds::historyQosPolicy const& datawriterQos::
  history () const
  {
    return *history_;
  }

  void datawriterQos::
  history (::dds::historyQosPolicy const& e)
  {
    if (history_.get ())
    {
      *history_ = e;
    }

    else
    {
      history_ = datawriterQos::history_auto_ptr_type (new ::dds::historyQosPolicy (e));
      history_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  resource_limits_p () const
  {
    return resource_limits_.get () != 0;
  }

  ::dds::resourceLimitsQosPolicy const& datawriterQos::
  resource_limits () const
  {
    return *resource_limits_;
  }

  void datawriterQos::
  resource_limits (::dds::resourceLimitsQosPolicy const& e)
  {
    if (resource_limits_.get ())
    {
      *resource_limits_ = e;
    }

    else
    {
      resource_limits_ = datawriterQos::resource_limits_auto_ptr_type (new ::dds::resourceLimitsQosPolicy (e));
      resource_limits_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  transport_priority_p () const
  {
    return transport_priority_.get () != 0;
  }

  ::dds::transportPriorityQosPolicy const& datawriterQos::
  transport_priority () const
  {
    return *transport_priority_;
  }

  void datawriterQos::
  transport_priority (::dds::transportPriorityQosPolicy const& e)
  {
    if (transport_priority_.get ())
    {
      *transport_priority_ = e;
    }

    else
    {
      transport_priority_ = datawriterQos::transport_priority_auto_ptr_type (new ::dds::transportPriorityQosPolicy (e));
      transport_priority_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  lifespan_p () const
  {
    return lifespan_.get () != 0;
  }

  ::dds::lifespanQosPolicy const& datawriterQos::
  lifespan () const
  {
    return *lifespan_;
  }

  void datawriterQos::
  lifespan (::dds::lifespanQosPolicy const& e)
  {
    if (lifespan_.get ())
    {
      *lifespan_ = e;
    }

    else
    {
      lifespan_ = datawriterQos::lifespan_auto_ptr_type (new ::dds::lifespanQosPolicy (e));
      lifespan_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  user_data_p () const
  {
    return user_data_.get () != 0;
  }

  ::dds::userDataQosPolicy const& datawriterQos::
  user_data () const
  {
    return *user_data_;
  }

  void datawriterQos::
  user_data (::dds::userDataQosPolicy const& e)
  {
    if (user_data_.get ())
    {
      *user_data_ = e;
    }

    else
    {
      user_data_ = datawriterQos::user_data_auto_ptr_type (new ::dds::userDataQosPolicy (e));
      user_data_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  ownership_p () const
  {
    return ownership_.get () != 0;
  }

  ::dds::ownershipQosPolicy const& datawriterQos::
  ownership () const
  {
    return *ownership_;
  }

  void datawriterQos::
  ownership (::dds::ownershipQosPolicy const& e)
  {
    if (ownership_.get ())
    {
      *ownership_ = e;
    }

    else
    {
      ownership_ = datawriterQos::ownership_auto_ptr_type (new ::dds::ownershipQosPolicy (e));
      ownership_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  ownership_strength_p () const
  {
    return ownership_strength_.get () != 0;
  }

  ::dds::ownershipStrengthQosPolicy const& datawriterQos::
  ownership_strength () const
  {
    return *ownership_strength_;
  }

  void datawriterQos::
  ownership_strength (::dds::ownershipStrengthQosPolicy const& e)
  {
    if (ownership_strength_.get ())
    {
      *ownership_strength_ = e;
    }

    else
    {
      ownership_strength_ = datawriterQos::ownership_strength_auto_ptr_type (new ::dds::ownershipStrengthQosPolicy (e));
      ownership_strength_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  writer_data_lifecycle_p () const
  {
    return writer_data_lifecycle_.get () != 0;
  }

  ::dds::writerDataLifecycleQosPolicy const& datawriterQos::
  writer_data_lifecycle () const
  {
    return *writer_data_lifecycle_;
  }

  void datawriterQos::
  writer_data_lifecycle (::dds::writerDataLifecycleQosPolicy const& e)
  {
    if (writer_data_lifecycle_.get ())
    {
      *writer_data_lifecycle_ = e;
    }

    else
    {
      writer_data_lifecycle_ = datawriterQos::writer_data_lifecycle_auto_ptr_type (new ::dds::writerDataLifecycleQosPolicy (e));
      writer_data_lifecycle_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  name_p () const
  {
    return name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  name ()
  {
    return *name_;
  }

  void datawriterQos::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (name_.get ())
    {
      *name_ = e;
    }

    else
    {
      name_ = datawriterQos::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      name_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  base_name ()
  {
    return *base_name_;
  }

  void datawriterQos::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = datawriterQos::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }

  // datawriterQos
  bool datawriterQos::
  topic_filter_p () const
  {
    return topic_filter_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& datawriterQos::
  topic_filter () const
  {
    return *topic_filter_;
  }

  ::XMLSchema::string<ACE_TCHAR>& datawriterQos::
  topic_filter ()
  {
    return *topic_filter_;
  }

  void datawriterQos::
  topic_filter (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (topic_filter_.get ())
    {
      *topic_filter_ = e;
    }

    else
    {
      topic_filter_ = datawriterQos::topic_filter_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      topic_filter_->container (this);
    }
  }


  // qosProfile

  qosProfile::qosProfile (::XMLSchema::string<ACE_TCHAR> const& name__)
  : ::XSCRT::Type ()
  , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
  {
    name_->container (this);
  }

  qosProfile::qosProfile (qosProfile const& s) :
  ::XSCRT::Type (s)
  , datareader_qos_ (s.datareader_qos_)
  , datawriter_qos_ (s.datawriter_qos_)
  , topic_qos_ (s.topic_qos_)
  , domainparticipant_qos_ (s.domainparticipant_qos_)
  , publisher_qos_ (s.publisher_qos_)
  , subscriber_qos_ (s.subscriber_qos_)
  , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
  , base_name_ (s.base_name_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.base_name_) : 0)
  {
    name_->container (this);
    if (base_name_.get ()) base_name_->container (this);
  }

  qosProfile&
  qosProfile::operator= (qosProfile const& s)
  {
    if (&s != this)
    {
      datareader_qos_ = s.datareader_qos_;

      datawriter_qos_ = s.datawriter_qos_;

      topic_qos_ = s.topic_qos_;

      domainparticipant_qos_ = s.domainparticipant_qos_;

      publisher_qos_ = s.publisher_qos_;

      subscriber_qos_ = s.subscriber_qos_;

      name (s.name ());

      if (s.base_name_.get ()) base_name (*(s.base_name_));
      else base_name_.reset (0);
    }

    return *this;
  }


  // qosProfile
  qosProfile::datareader_qos_iterator qosProfile::
  begin_datareader_qos ()
  {
    return datareader_qos_.begin ();
  }

  qosProfile::datareader_qos_iterator qosProfile::
  end_datareader_qos ()
  {
    return datareader_qos_.end ();
  }

  qosProfile::datareader_qos_const_iterator qosProfile::
  begin_datareader_qos () const
  {
    return datareader_qos_.begin ();
  }

  qosProfile::datareader_qos_const_iterator qosProfile::
  end_datareader_qos () const
  {
    return datareader_qos_.end ();
  }

  void qosProfile::
  add_datareader_qos (qosProfile::datareader_qos_value_type const& e)
  {
    datareader_qos_.push_back (e);
  }

  size_t qosProfile::
  count_datareader_qos(void) const
  {
    return datareader_qos_.size ();
  }

  // qosProfile
  qosProfile::datawriter_qos_iterator qosProfile::
  begin_datawriter_qos ()
  {
    return datawriter_qos_.begin ();
  }

  qosProfile::datawriter_qos_iterator qosProfile::
  end_datawriter_qos ()
  {
    return datawriter_qos_.end ();
  }

  qosProfile::datawriter_qos_const_iterator qosProfile::
  begin_datawriter_qos () const
  {
    return datawriter_qos_.begin ();
  }

  qosProfile::datawriter_qos_const_iterator qosProfile::
  end_datawriter_qos () const
  {
    return datawriter_qos_.end ();
  }

  void qosProfile::
  add_datawriter_qos (qosProfile::datawriter_qos_value_type const& e)
  {
    datawriter_qos_.push_back (e);
  }

  size_t qosProfile::
  count_datawriter_qos(void) const
  {
    return datawriter_qos_.size ();
  }

  // qosProfile
  qosProfile::topic_qos_iterator qosProfile::
  begin_topic_qos ()
  {
    return topic_qos_.begin ();
  }

  qosProfile::topic_qos_iterator qosProfile::
  end_topic_qos ()
  {
    return topic_qos_.end ();
  }

  qosProfile::topic_qos_const_iterator qosProfile::
  begin_topic_qos () const
  {
    return topic_qos_.begin ();
  }

  qosProfile::topic_qos_const_iterator qosProfile::
  end_topic_qos () const
  {
    return topic_qos_.end ();
  }

  void qosProfile::
  add_topic_qos (qosProfile::topic_qos_value_type const& e)
  {
    topic_qos_.push_back (e);
  }

  size_t qosProfile::
  count_topic_qos(void) const
  {
    return topic_qos_.size ();
  }

  // qosProfile
  qosProfile::domainparticipant_qos_iterator qosProfile::
  begin_domainparticipant_qos ()
  {
    return domainparticipant_qos_.begin ();
  }

  qosProfile::domainparticipant_qos_iterator qosProfile::
  end_domainparticipant_qos ()
  {
    return domainparticipant_qos_.end ();
  }

  qosProfile::domainparticipant_qos_const_iterator qosProfile::
  begin_domainparticipant_qos () const
  {
    return domainparticipant_qos_.begin ();
  }

  qosProfile::domainparticipant_qos_const_iterator qosProfile::
  end_domainparticipant_qos () const
  {
    return domainparticipant_qos_.end ();
  }

  void qosProfile::
  add_domainparticipant_qos (qosProfile::domainparticipant_qos_value_type const& e)
  {
    domainparticipant_qos_.push_back (e);
  }

  size_t qosProfile::
  count_domainparticipant_qos(void) const
  {
    return domainparticipant_qos_.size ();
  }

  // qosProfile
  qosProfile::publisher_qos_iterator qosProfile::
  begin_publisher_qos ()
  {
    return publisher_qos_.begin ();
  }

  qosProfile::publisher_qos_iterator qosProfile::
  end_publisher_qos ()
  {
    return publisher_qos_.end ();
  }

  qosProfile::publisher_qos_const_iterator qosProfile::
  begin_publisher_qos () const
  {
    return publisher_qos_.begin ();
  }

  qosProfile::publisher_qos_const_iterator qosProfile::
  end_publisher_qos () const
  {
    return publisher_qos_.end ();
  }

  void qosProfile::
  add_publisher_qos (qosProfile::publisher_qos_value_type const& e)
  {
    publisher_qos_.push_back (e);
  }

  size_t qosProfile::
  count_publisher_qos(void) const
  {
    return publisher_qos_.size ();
  }

  // qosProfile
  qosProfile::subscriber_qos_iterator qosProfile::
  begin_subscriber_qos ()
  {
    return subscriber_qos_.begin ();
  }

  qosProfile::subscriber_qos_iterator qosProfile::
  end_subscriber_qos ()
  {
    return subscriber_qos_.end ();
  }

  qosProfile::subscriber_qos_const_iterator qosProfile::
  begin_subscriber_qos () const
  {
    return subscriber_qos_.begin ();
  }

  qosProfile::subscriber_qos_const_iterator qosProfile::
  end_subscriber_qos () const
  {
    return subscriber_qos_.end ();
  }

  void qosProfile::
  add_subscriber_qos (qosProfile::subscriber_qos_value_type const& e)
  {
    subscriber_qos_.push_back (e);
  }

  size_t qosProfile::
  count_subscriber_qos(void) const
  {
    return subscriber_qos_.size ();
  }

  // qosProfile
  ::XMLSchema::string<ACE_TCHAR> const& qosProfile::
  name () const
  {
    return *name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& qosProfile::
  name ()
  {
    return *name_;
  }

  void qosProfile::
  name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    *name_ = e;
  }

  // qosProfile
  bool qosProfile::
  base_name_p () const
  {
    return base_name_.get () != 0;
  }

  ::XMLSchema::string<ACE_TCHAR> const& qosProfile::
  base_name () const
  {
    return *base_name_;
  }

  ::XMLSchema::string<ACE_TCHAR>& qosProfile::
  base_name ()
  {
    return *base_name_;
  }

  void qosProfile::
  base_name (::XMLSchema::string<ACE_TCHAR> const& e)
  {
    if (base_name_.get ())
    {
      *base_name_ = e;
    }

    else
    {
      base_name_ = qosProfile::base_name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
      base_name_->container (this);
    }
  }


  // qosProfile_seq

  qosProfile_seq::qosProfile_seq ()
  : ::XSCRT::Type ()
  {
  }

  qosProfile_seq::qosProfile_seq (qosProfile_seq const& s) :
  ::XSCRT::Type (s)
  , qos_profile_ (s.qos_profile_)
  {
  }

  qosProfile_seq&
  qosProfile_seq::operator= (qosProfile_seq const& s)
  {
    if (&s != this)
    {
      qos_profile_ = s.qos_profile_;
    }

    return *this;
  }


  // qosProfile_seq
  qosProfile_seq::qos_profile_iterator qosProfile_seq::
  begin_qos_profile ()
  {
    return qos_profile_.begin ();
  }

  qosProfile_seq::qos_profile_iterator qosProfile_seq::
  end_qos_profile ()
  {
    return qos_profile_.end ();
  }

  qosProfile_seq::qos_profile_const_iterator qosProfile_seq::
  begin_qos_profile () const
  {
    return qos_profile_.begin ();
  }

  qosProfile_seq::qos_profile_const_iterator qosProfile_seq::
  end_qos_profile () const
  {
    return qos_profile_.end ();
  }

  void qosProfile_seq::
  add_qos_profile (qosProfile_seq::qos_profile_value_type const& e)
  {
    qos_profile_.push_back (e);
  }

  void qosProfile_seq::
  del_qos_profile(qosProfile_seq::qos_profile_value_type const& e)
  {
    qos_profile_.remove (e);
  }

  size_t qosProfile_seq::
  count_qos_profile(void) const
  {
    return qos_profile_.size ();
  }
}

namespace dds
{
  // destinationOrderKind

  destinationOrderKind::
  destinationOrderKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else if (v == ACE_TEXT ("BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else
    {
    }
  }

  destinationOrderKind::
  destinationOrderKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else if (v == ACE_TEXT ("BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS")) v_ = BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l;
    else
    {
    }
  }

  destinationOrderKind const destinationOrderKind::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS (destinationOrderKind::BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l);
  destinationOrderKind const destinationOrderKind::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS (destinationOrderKind::BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l);

  // durabilityKind

  durabilityKind::
  durabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("VOLATILE_DURABILITY_QOS")) v_ = VOLATILE_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_LOCAL_DURABILITY_QOS")) v_ = TRANSIENT_LOCAL_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_DURABILITY_QOS")) v_ = TRANSIENT_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("PERSISTENT_DURABILITY_QOS")) v_ = PERSISTENT_DURABILITY_QOS_l;
    else
    {
    }
  }

  durabilityKind::
  durabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("VOLATILE_DURABILITY_QOS")) v_ = VOLATILE_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_LOCAL_DURABILITY_QOS")) v_ = TRANSIENT_LOCAL_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("TRANSIENT_DURABILITY_QOS")) v_ = TRANSIENT_DURABILITY_QOS_l;
    else if (v == ACE_TEXT ("PERSISTENT_DURABILITY_QOS")) v_ = PERSISTENT_DURABILITY_QOS_l;
    else
    {
    }
  }

  durabilityKind const durabilityKind::VOLATILE_DURABILITY_QOS (durabilityKind::VOLATILE_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::TRANSIENT_LOCAL_DURABILITY_QOS (durabilityKind::TRANSIENT_LOCAL_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::TRANSIENT_DURABILITY_QOS (durabilityKind::TRANSIENT_DURABILITY_QOS_l);
  durabilityKind const durabilityKind::PERSISTENT_DURABILITY_QOS (durabilityKind::PERSISTENT_DURABILITY_QOS_l);

  // historyKind

  historyKind::
  historyKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("KEEP_LAST_HISTORY_QOS")) v_ = KEEP_LAST_HISTORY_QOS_l;
    else if (v == ACE_TEXT ("KEEP_ALL_HISTORY_QOS")) v_ = KEEP_ALL_HISTORY_QOS_l;
    else
    {
    }
  }

  historyKind::
  historyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("KEEP_LAST_HISTORY_QOS")) v_ = KEEP_LAST_HISTORY_QOS_l;
    else if (v == ACE_TEXT ("KEEP_ALL_HISTORY_QOS")) v_ = KEEP_ALL_HISTORY_QOS_l;
    else
    {
    }
  }

  historyKind const historyKind::KEEP_LAST_HISTORY_QOS (historyKind::KEEP_LAST_HISTORY_QOS_l);
  historyKind const historyKind::KEEP_ALL_HISTORY_QOS (historyKind::KEEP_ALL_HISTORY_QOS_l);

  // livelinessKind

  livelinessKind::
  livelinessKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("AUTOMATIC_LIVELINESS_QOS")) v_ = AUTOMATIC_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_PARTICIPANT_LIVELINESS_QOS")) v_ = MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_TOPIC_LIVELINESS_QOS")) v_ = MANUAL_BY_TOPIC_LIVELINESS_QOS_l;
    else
    {
    }
  }

  livelinessKind::
  livelinessKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("AUTOMATIC_LIVELINESS_QOS")) v_ = AUTOMATIC_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_PARTICIPANT_LIVELINESS_QOS")) v_ = MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l;
    else if (v == ACE_TEXT ("MANUAL_BY_TOPIC_LIVELINESS_QOS")) v_ = MANUAL_BY_TOPIC_LIVELINESS_QOS_l;
    else
    {
    }
  }

  livelinessKind const livelinessKind::AUTOMATIC_LIVELINESS_QOS (livelinessKind::AUTOMATIC_LIVELINESS_QOS_l);
  livelinessKind const livelinessKind::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS (livelinessKind::MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l);
  livelinessKind const livelinessKind::MANUAL_BY_TOPIC_LIVELINESS_QOS (livelinessKind::MANUAL_BY_TOPIC_LIVELINESS_QOS_l);

  // presentationAccessScopeKind

  presentationAccessScopeKind::
  presentationAccessScopeKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("INSTANCE_PRESENTATION_QOS")) v_ = INSTANCE_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("TOPIC_PRESENTATION_QOS")) v_ = TOPIC_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("GROUP_PRESENTATION_QOS")) v_ = GROUP_PRESENTATION_QOS_l;
    else
    {
    }
  }

  presentationAccessScopeKind::
  presentationAccessScopeKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("INSTANCE_PRESENTATION_QOS")) v_ = INSTANCE_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("TOPIC_PRESENTATION_QOS")) v_ = TOPIC_PRESENTATION_QOS_l;
    else if (v == ACE_TEXT ("GROUP_PRESENTATION_QOS")) v_ = GROUP_PRESENTATION_QOS_l;
    else
    {
    }
  }

  presentationAccessScopeKind const presentationAccessScopeKind::INSTANCE_PRESENTATION_QOS (presentationAccessScopeKind::INSTANCE_PRESENTATION_QOS_l);
  presentationAccessScopeKind const presentationAccessScopeKind::TOPIC_PRESENTATION_QOS (presentationAccessScopeKind::TOPIC_PRESENTATION_QOS_l);
  presentationAccessScopeKind const presentationAccessScopeKind::GROUP_PRESENTATION_QOS (presentationAccessScopeKind::GROUP_PRESENTATION_QOS_l);

  // reliabilityKind

  reliabilityKind::
  reliabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("BEST_EFFORT_RELIABILITY_QOS")) v_ = BEST_EFFORT_RELIABILITY_QOS_l;
    else if (v == ACE_TEXT ("RELIABLE_RELIABILITY_QOS")) v_ = RELIABLE_RELIABILITY_QOS_l;
    else
    {
    }
  }

  reliabilityKind::
  reliabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("BEST_EFFORT_RELIABILITY_QOS")) v_ = BEST_EFFORT_RELIABILITY_QOS_l;
    else if (v == ACE_TEXT ("RELIABLE_RELIABILITY_QOS")) v_ = RELIABLE_RELIABILITY_QOS_l;
    else
    {
    }
  }

  reliabilityKind const reliabilityKind::BEST_EFFORT_RELIABILITY_QOS (reliabilityKind::BEST_EFFORT_RELIABILITY_QOS_l);
  reliabilityKind const reliabilityKind::RELIABLE_RELIABILITY_QOS (reliabilityKind::RELIABLE_RELIABILITY_QOS_l);

  // ownershipKind

  ownershipKind::
  ownershipKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  : ::XSCRT::Type (e)
  {
    std::basic_string<ACE_TCHAR> v (e.value ());

    if (v == ACE_TEXT ("SHARED_OWNERSHIP_QOS")) v_ = SHARED_OWNERSHIP_QOS_l;
    else if (v == ACE_TEXT ("EXCLUSIVE_OWNERSHIP_QOS")) v_ = EXCLUSIVE_OWNERSHIP_QOS_l;
    else
    {
    }
  }

  ownershipKind::
  ownershipKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
  : ::XSCRT::Type (a)
  {
    std::basic_string<ACE_TCHAR> v (a.value ());

    if (v == ACE_TEXT ("SHARED_OWNERSHIP_QOS")) v_ = SHARED_OWNERSHIP_QOS_l;
    else if (v == ACE_TEXT ("EXCLUSIVE_OWNERSHIP_QOS")) v_ = EXCLUSIVE_OWNERSHIP_QOS_l;
    else
    {
    }
  }

  ownershipKind const ownershipKind::SHARED_OWNERSHIP_QOS (ownershipKind::SHARED_OWNERSHIP_QOS_l);
  ownershipKind const ownershipKind::EXCLUSIVE_OWNERSHIP_QOS (ownershipKind::EXCLUSIVE_OWNERSHIP_QOS_l);

  // duration

  duration::
  duration (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("sec"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        sec (t);
      }

      else if (n == ACE_TEXT("nanosec"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        nanosec (t);
      }

      else
      {
      }
    }
  }

  // stringSeq

  stringSeq::
  stringSeq (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("element"))
      {
        element_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
        add_element (t);
      }

      else
      {
      }
    }
  }

  // deadlineQosPolicy

  deadlineQosPolicy::
  deadlineQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("period"))
      {
        ::dds::duration t (e);
        period (t);
      }

      else
      {
      }
    }
  }

  // destinationOrderQosPolicy

  destinationOrderQosPolicy::
  destinationOrderQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::destinationOrderKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // durabilityQosPolicy

  durabilityQosPolicy::
  durabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::durabilityKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // durabilityServiceQosPolicy

  durabilityServiceQosPolicy::
  durabilityServiceQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("service_cleanup_delay"))
      {
        ::dds::duration t (e);
        service_cleanup_delay (t);
      }

      else if (n == ACE_TEXT("history_kind"))
      {
        ::dds::historyKind t (e);
        history_kind (t);
      }

      else if (n == ACE_TEXT("history_depth"))
      {
        ::XMLSchema::positiveInteger t (e);
        history_depth (t);
      }

      else if (n == ACE_TEXT("max_samples"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples (t);
      }

      else if (n == ACE_TEXT("max_instances"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_instances (t);
      }

      else if (n == ACE_TEXT("max_samples_per_instance"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples_per_instance (t);
      }

      else
      {
      }
    }
  }

  // entityFactoryQosPolicy

  entityFactoryQosPolicy::
  entityFactoryQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autoenable_created_entities"))
      {
        ::XMLSchema::boolean t (e);
        autoenable_created_entities (t);
      }

      else
      {
      }
    }
  }

  // groupDataQosPolicy

  groupDataQosPolicy::
  groupDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // historyQosPolicy

  historyQosPolicy::
  historyQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::historyKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("depth"))
      {
        ::XMLSchema::positiveInteger t (e);
        depth (t);
      }

      else
      {
      }
    }
  }

  // latencyBudgetQosPolicy

  latencyBudgetQosPolicy::
  latencyBudgetQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("duration"))
      {
        ::dds::duration t (e);
        duration (t);
      }

      else
      {
      }
    }
  }

  // lifespanQosPolicy

  lifespanQosPolicy::
  lifespanQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("duration"))
      {
        ::dds::duration t (e);
        duration (t);
      }

      else
      {
      }
    }
  }

  // livelinessQosPolicy

  livelinessQosPolicy::
  livelinessQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::livelinessKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("lease_duration"))
      {
        ::dds::duration t (e);
        lease_duration (t);
      }

      else
      {
      }
    }
  }

  // ownershipQosPolicy

  ownershipQosPolicy::
  ownershipQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::ownershipKind t (e);
        kind (t);
      }

      else
      {
      }
    }
  }

  // ownershipStrengthQosPolicy

  ownershipStrengthQosPolicy::
  ownershipStrengthQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::nonNegativeInteger t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // partitionQosPolicy

  partitionQosPolicy::
  partitionQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("name"))
      {
        ::dds::stringSeq t (e);
        name (t);
      }

      else
      {
      }
    }
  }

  // presentationQosPolicy

  presentationQosPolicy::
  presentationQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("access_scope"))
      {
        ::dds::presentationAccessScopeKind t (e);
        access_scope (t);
      }

      else if (n == ACE_TEXT("coherent_access"))
      {
        ::XMLSchema::boolean t (e);
        coherent_access (t);
      }

      else if (n == ACE_TEXT("ordered_access"))
      {
        ::XMLSchema::boolean t (e);
        ordered_access (t);
      }

      else
      {
      }
    }
  }

  // readerDataLifecycleQosPolicy

  readerDataLifecycleQosPolicy::
  readerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autopurge_nowriter_samples_delay"))
      {
        ::dds::duration t (e);
        autopurge_nowriter_samples_delay (t);
      }

      else if (n == ACE_TEXT("autopurge_disposed_samples_delay"))
      {
        ::dds::duration t (e);
        autopurge_disposed_samples_delay (t);
      }

      else
      {
      }
    }
  }

  // reliabilityQosPolicy

  reliabilityQosPolicy::
  reliabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("kind"))
      {
        ::dds::reliabilityKind t (e);
        kind (t);
      }

      else if (n == ACE_TEXT("max_blocking_time"))
      {
        ::dds::duration t (e);
        max_blocking_time (t);
      }

      else
      {
      }
    }
  }

  // resourceLimitsQosPolicy

  resourceLimitsQosPolicy::
  resourceLimitsQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("max_samples"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples (t);
      }

      else if (n == ACE_TEXT("max_instances"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_instances (t);
      }

      else if (n == ACE_TEXT("max_samples_per_instance"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        max_samples_per_instance (t);
      }

      else if (n == ACE_TEXT("initial_samples"))
      {
        ::XMLSchema::positiveInteger t (e);
        initial_samples (t);
      }

      else if (n == ACE_TEXT("initial_instances"))
      {
        ::XMLSchema::positiveInteger t (e);
        initial_instances (t);
      }

      else
      {
      }
    }
  }

  // timeBasedFilterQosPolicy

  timeBasedFilterQosPolicy::
  timeBasedFilterQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("minimum_separation"))
      {
        ::dds::duration t (e);
        minimum_separation (t);
      }

      else
      {
      }
    }
  }

  // topicDataQosPolicy

  topicDataQosPolicy::
  topicDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // transportPriorityQosPolicy

  transportPriorityQosPolicy::
  transportPriorityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::nonNegativeInteger t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // userDataQosPolicy

  userDataQosPolicy::
  userDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("value"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (e);
        value (t);
      }

      else
      {
      }
    }
  }

  // writerDataLifecycleQosPolicy

  writerDataLifecycleQosPolicy::
  writerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("autodispose_unregistered_instances"))
      {
        ::XMLSchema::boolean t (e);
        autodispose_unregistered_instances (t);
      }

      else
      {
      }
    }
  }

  // domainparticipantQos

  domainparticipantQos::
  domainparticipantQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // publisherQos

  publisherQos::
  publisherQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("presentation"))
      {
        ::dds::presentationQosPolicy t (e);
        presentation (t);
      }

      else if (n == ACE_TEXT("partition"))
      {
        ::dds::partitionQosPolicy t (e);
        partition (t);
      }

      else if (n == ACE_TEXT("group_data"))
      {
        ::dds::groupDataQosPolicy t (e);
        group_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // subscriberQos

  subscriberQos::
  subscriberQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("presentation"))
      {
        ::dds::presentationQosPolicy t (e);
        presentation (t);
      }

      else if (n == ACE_TEXT("partition"))
      {
        ::dds::partitionQosPolicy t (e);
        partition (t);
      }

      else if (n == ACE_TEXT("group_data"))
      {
        ::dds::groupDataQosPolicy t (e);
        group_data (t);
      }

      else if (n == ACE_TEXT("entity_factory"))
      {
        ::dds::entityFactoryQosPolicy t (e);
        entity_factory (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // topicQos

  topicQos::
  topicQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("topic_data"))
      {
        ::dds::topicDataQosPolicy t (e);
        topic_data (t);
      }

      else if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("durability_service"))
      {
        ::dds::durabilityServiceQosPolicy t (e);
        durability_service (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("transport_priority"))
      {
        ::dds::transportPriorityQosPolicy t (e);
        transport_priority (t);
      }

      else if (n == ACE_TEXT("lifespan"))
      {
        ::dds::lifespanQosPolicy t (e);
        lifespan (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // datareaderQos

  datareaderQos::
  datareaderQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else if (n == ACE_TEXT("time_based_filter"))
      {
        ::dds::timeBasedFilterQosPolicy t (e);
        time_based_filter (t);
      }

      else if (n == ACE_TEXT("reader_data_lifecycle"))
      {
        ::dds::readerDataLifecycleQosPolicy t (e);
        reader_data_lifecycle (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // datawriterQos

  datawriterQos::
  datawriterQos (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("durability"))
      {
        ::dds::durabilityQosPolicy t (e);
        durability (t);
      }

      else if (n == ACE_TEXT("durability_service"))
      {
        ::dds::durabilityServiceQosPolicy t (e);
        durability_service (t);
      }

      else if (n == ACE_TEXT("deadline"))
      {
        ::dds::deadlineQosPolicy t (e);
        deadline (t);
      }

      else if (n == ACE_TEXT("latency_budget"))
      {
        ::dds::latencyBudgetQosPolicy t (e);
        latency_budget (t);
      }

      else if (n == ACE_TEXT("liveliness"))
      {
        ::dds::livelinessQosPolicy t (e);
        liveliness (t);
      }

      else if (n == ACE_TEXT("reliability"))
      {
        ::dds::reliabilityQosPolicy t (e);
        reliability (t);
      }

      else if (n == ACE_TEXT("destination_order"))
      {
        ::dds::destinationOrderQosPolicy t (e);
        destination_order (t);
      }

      else if (n == ACE_TEXT("history"))
      {
        ::dds::historyQosPolicy t (e);
        history (t);
      }

      else if (n == ACE_TEXT("resource_limits"))
      {
        ::dds::resourceLimitsQosPolicy t (e);
        resource_limits (t);
      }

      else if (n == ACE_TEXT("transport_priority"))
      {
        ::dds::transportPriorityQosPolicy t (e);
        transport_priority (t);
      }

      else if (n == ACE_TEXT("lifespan"))
      {
        ::dds::lifespanQosPolicy t (e);
        lifespan (t);
      }

      else if (n == ACE_TEXT("user_data"))
      {
        ::dds::userDataQosPolicy t (e);
        user_data (t);
      }

      else if (n == ACE_TEXT("ownership"))
      {
        ::dds::ownershipQosPolicy t (e);
        ownership (t);
      }

      else if (n == ACE_TEXT("ownership_strength"))
      {
        ::dds::ownershipStrengthQosPolicy t (e);
        ownership_strength (t);
      }

      else if (n == ACE_TEXT("writer_data_lifecycle"))
      {
        ::dds::writerDataLifecycleQosPolicy t (e);
        writer_data_lifecycle (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        name (t);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else if (n == ACE_TEXT ("topic_filter"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        topic_filter (t);
      }

      else
      {
      }
    }
  }

  // qosProfile

  qosProfile::
  qosProfile (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("datareader_qos"))
      {
        datareader_qos_value_type t (new ::dds::datareaderQos (e));
        add_datareader_qos (t);
      }

      else if (n == ACE_TEXT("datawriter_qos"))
      {
        datawriter_qos_value_type t (new ::dds::datawriterQos (e));
        add_datawriter_qos (t);
      }

      else if (n == ACE_TEXT("topic_qos"))
      {
        topic_qos_value_type t (new ::dds::topicQos (e));
        add_topic_qos (t);
      }

      else if (n == ACE_TEXT("domainparticipant_qos"))
      {
        domainparticipant_qos_value_type t (new ::dds::domainparticipantQos (e));
        add_domainparticipant_qos (t);
      }

      else if (n == ACE_TEXT("publisher_qos"))
      {
        publisher_qos_value_type t (new ::dds::publisherQos (e));
        add_publisher_qos (t);
      }

      else if (n == ACE_TEXT("subscriber_qos"))
      {
        subscriber_qos_value_type t (new ::dds::subscriberQos (e));
        add_subscriber_qos (t);
      }

      else
      {
      }
    }

    while (p.more_attributes ())
    {
      ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
      if (n == ACE_TEXT ("name"))
      {
        name_ = qosProfile::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (a));
        name_->container (this);
      }

      else if (n == ACE_TEXT ("base_name"))
      {
        ::XMLSchema::string<ACE_TCHAR> t (a);
        base_name (t);
      }

      else
      {
      }
    }
  }

  // qosProfile_seq

  qosProfile_seq::
  qosProfile_seq (::XSCRT::XML::Element<ACE_TCHAR> const& e)
  :Base (e)
  {

    ::XSCRT::Parser<ACE_TCHAR> p (e);

    while (p.more_elements ())
    {
      ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
      std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

      if (n == ACE_TEXT("qos_profile"))
      {
        qos_profile_value_type t (new ::dds::qosProfile (e));
        add_qos_profile (t);
      }

      else
      {
      }
    }
  }
}

namespace dds
{
  namespace reader
  {
    ::dds::qosProfile_seq
    dds (xercesc::DOMDocument const* d)
    {
      // Initiate our Singleton as an ACE_TSS object (ensures thread
      // specific storage
      ID_Map::TSS_ID_Map* TSS_ID_Map (ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance());
      xercesc::DOMElement* dom_element = d->getDocumentElement ();
      if (!dom_element)
      {
        throw 1;
      }

      ::XSCRT::XML::Element<ACE_TCHAR> e (dom_element);
      if (e.name () == ACE_TEXT("dds"))
      {
        ::dds::qosProfile_seq r (e);

        (*TSS_ID_Map)->resolve_idref();

        return r;
      }

      else
      {
        throw 1;
      }
    }
  }
}
