/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#ifndef OPENDDS_DCPS_QOS_XML_HANDLER_DDS_QOS_HPP
#define OPENDDS_DCPS_QOS_XML_HANDLER_DDS_QOS_HPP

#include "OpenDDS_XML_QOS_Handler_Export.h"
// Forward declarations.
namespace dds
{
  class destinationOrderKind;
  class durabilityKind;
  class historyKind;
  class livelinessKind;
  class presentationAccessScopeKind;
  class reliabilityKind;
  class ownershipKind;
  class dataRepresentationIdKind;
  class typeConsistencyKind;
  class duration;
  class stringSeq;
  class dataRepresentationIdSeq;
  class deadlineQosPolicy;
  class destinationOrderQosPolicy;
  class durabilityQosPolicy;
  class durabilityServiceQosPolicy;
  class entityFactoryQosPolicy;
  class groupDataQosPolicy;
  class historyQosPolicy;
  class latencyBudgetQosPolicy;
  class lifespanQosPolicy;
  class livelinessQosPolicy;
  class ownershipQosPolicy;
  class ownershipStrengthQosPolicy;
  class partitionQosPolicy;
  class presentationQosPolicy;
  class readerDataLifecycleQosPolicy;
  class reliabilityQosPolicy;
  class resourceLimitsQosPolicy;
  class timeBasedFilterQosPolicy;
  class topicDataQosPolicy;
  class transportPriorityQosPolicy;
  class userDataQosPolicy;
  class writerDataLifecycleQosPolicy;
  class dataRepresentationQosPolicy;
  class typeConsistencyEnforcementQosPolicy;
  class domainparticipantQos;
  class publisherQos;
  class subscriberQos;
  class topicQos;
  class datareaderQos;
  class datawriterQos;
  class qosProfile;
  class qosProfile_seq;
}

#include <memory>
#include <string>
#include <vector>
#include "ace/XML_Utils/XMLSchema/Types.hpp"
#include "ace/XML_Utils/XMLSchema/id_map.hpp"
#include "ace/ace_wchar.h"

namespace dds
{
  class OpenDDS_XML_QOS_Handler_Export destinationOrderKind : public ::XSCRT::Type
  {
    public:
    explicit destinationOrderKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit destinationOrderKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static destinationOrderKind const BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS;
    static destinationOrderKind const BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS;

    enum Value
    {
      BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS_l, BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (destinationOrderKind const& a, destinationOrderKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (destinationOrderKind const& a, destinationOrderKind const& b);

    private:
    destinationOrderKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (destinationOrderKind const &a, destinationOrderKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (destinationOrderKind const &a, destinationOrderKind const &b);


  class OpenDDS_XML_QOS_Handler_Export durabilityKind : public ::XSCRT::Type
  {
    public:
    explicit durabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit durabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static durabilityKind const VOLATILE_DURABILITY_QOS;
    static durabilityKind const TRANSIENT_LOCAL_DURABILITY_QOS;
    static durabilityKind const TRANSIENT_DURABILITY_QOS;
    static durabilityKind const PERSISTENT_DURABILITY_QOS;

    enum Value
    {
      VOLATILE_DURABILITY_QOS_l, TRANSIENT_LOCAL_DURABILITY_QOS_l, TRANSIENT_DURABILITY_QOS_l, PERSISTENT_DURABILITY_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (durabilityKind const& a, durabilityKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (durabilityKind const& a, durabilityKind const& b);

    private:
    durabilityKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (durabilityKind const &a, durabilityKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (durabilityKind const &a, durabilityKind const &b);


  class OpenDDS_XML_QOS_Handler_Export historyKind : public ::XSCRT::Type
  {
    public:
    explicit historyKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit historyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static historyKind const KEEP_LAST_HISTORY_QOS;
    static historyKind const KEEP_ALL_HISTORY_QOS;

    enum Value
    {
      KEEP_LAST_HISTORY_QOS_l, KEEP_ALL_HISTORY_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (historyKind const& a, historyKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (historyKind const& a, historyKind const& b);

    private:
    historyKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (historyKind const &a, historyKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (historyKind const &a, historyKind const &b);


  class OpenDDS_XML_QOS_Handler_Export livelinessKind : public ::XSCRT::Type
  {
    public:
    explicit livelinessKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit livelinessKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static livelinessKind const AUTOMATIC_LIVELINESS_QOS;
    static livelinessKind const MANUAL_BY_PARTICIPANT_LIVELINESS_QOS;
    static livelinessKind const MANUAL_BY_TOPIC_LIVELINESS_QOS;

    enum Value
    {
      AUTOMATIC_LIVELINESS_QOS_l, MANUAL_BY_PARTICIPANT_LIVELINESS_QOS_l, MANUAL_BY_TOPIC_LIVELINESS_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (livelinessKind const& a, livelinessKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (livelinessKind const& a, livelinessKind const& b);

    private:
    livelinessKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (livelinessKind const &a, livelinessKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (livelinessKind const &a, livelinessKind const &b);


  class OpenDDS_XML_QOS_Handler_Export presentationAccessScopeKind : public ::XSCRT::Type
  {
    public:
    explicit presentationAccessScopeKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit presentationAccessScopeKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static presentationAccessScopeKind const INSTANCE_PRESENTATION_QOS;
    static presentationAccessScopeKind const TOPIC_PRESENTATION_QOS;
    static presentationAccessScopeKind const GROUP_PRESENTATION_QOS;

    enum Value
    {
      INSTANCE_PRESENTATION_QOS_l, TOPIC_PRESENTATION_QOS_l, GROUP_PRESENTATION_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (presentationAccessScopeKind const& a, presentationAccessScopeKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (presentationAccessScopeKind const& a, presentationAccessScopeKind const& b);

    private:
    presentationAccessScopeKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (presentationAccessScopeKind const &a, presentationAccessScopeKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (presentationAccessScopeKind const &a, presentationAccessScopeKind const &b);


  class OpenDDS_XML_QOS_Handler_Export reliabilityKind : public ::XSCRT::Type
  {
    public:
    explicit reliabilityKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit reliabilityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static reliabilityKind const BEST_EFFORT_RELIABILITY_QOS;
    static reliabilityKind const RELIABLE_RELIABILITY_QOS;

    enum Value
    {
      BEST_EFFORT_RELIABILITY_QOS_l, RELIABLE_RELIABILITY_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (reliabilityKind const& a, reliabilityKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (reliabilityKind const& a, reliabilityKind const& b);

    private:
    reliabilityKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (reliabilityKind const &a, reliabilityKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (reliabilityKind const &a, reliabilityKind const &b);


  class OpenDDS_XML_QOS_Handler_Export ownershipKind : public ::XSCRT::Type
  {
    public:
    explicit ownershipKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit ownershipKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static ownershipKind const SHARED_OWNERSHIP_QOS;
    static ownershipKind const EXCLUSIVE_OWNERSHIP_QOS;

    enum Value
    {
      SHARED_OWNERSHIP_QOS_l, EXCLUSIVE_OWNERSHIP_QOS_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (ownershipKind const& a, ownershipKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (ownershipKind const& a, ownershipKind const& b);

    private:
    ownershipKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (ownershipKind const &a, ownershipKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (ownershipKind const &a, ownershipKind const &b);


  class OpenDDS_XML_QOS_Handler_Export dataRepresentationIdKind : public ::XSCRT::Type
  {
    public:
    explicit dataRepresentationIdKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit dataRepresentationIdKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static dataRepresentationIdKind const XCDR_DATA_REPRESENTATION;
    static dataRepresentationIdKind const XML_DATA_REPRESENTATION;
    static dataRepresentationIdKind const XCDR2_DATA_REPRESENTATION;
    static dataRepresentationIdKind const UNALIGNED_CDR_DATA_REPRESENTATION;

    enum Value
    {
      XCDR_DATA_REPRESENTATION_l, XML_DATA_REPRESENTATION_l, XCDR2_DATA_REPRESENTATION_l, UNALIGNED_CDR_DATA_REPRESENTATION_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (dataRepresentationIdKind const& a, dataRepresentationIdKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (dataRepresentationIdKind const& a, dataRepresentationIdKind const& b);

    private:
    dataRepresentationIdKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (dataRepresentationIdKind const &a, dataRepresentationIdKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (dataRepresentationIdKind const &a, dataRepresentationIdKind const &b);


  class OpenDDS_XML_QOS_Handler_Export typeConsistencyKind : public ::XSCRT::Type
  {
    public:
    explicit typeConsistencyKind (::XSCRT::XML::Element<ACE_TCHAR> const&);
    explicit typeConsistencyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const&);

    static typeConsistencyKind const DISALLOW_TYPE_COERCION;
    static typeConsistencyKind const ALLOW_TYPE_COERCION;

    enum Value
    {
      DISALLOW_TYPE_COERCION_l, ALLOW_TYPE_COERCION_l
    };


    Value
    integral () const;

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator== (typeConsistencyKind const& a, typeConsistencyKind const& b);

    friend bool OpenDDS_XML_QOS_Handler_Export
    operator!= (typeConsistencyKind const& a, typeConsistencyKind const& b);

    private:
    typeConsistencyKind (Value v);

    Value v_;
  };

  bool OpenDDS_XML_QOS_Handler_Export operator== (typeConsistencyKind const &a, typeConsistencyKind const &b);

  bool OpenDDS_XML_QOS_Handler_Export operator!= (typeConsistencyKind const &a, typeConsistencyKind const &b);


  class OpenDDS_XML_QOS_Handler_Export duration : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // sec
    public:
    bool sec_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& sec () const;
    void sec (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using sec_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    sec_type sec_;

    // nanosec
    public:
    bool nanosec_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& nanosec () const;
    void nanosec (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using nanosec_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    nanosec_type nanosec_;

    public:
    duration ();

    explicit duration (::XSCRT::XML::Element<ACE_TCHAR> const&);
    duration (duration const& s);
    duration& operator= (duration const& s);

    duration (duration&&) = default;
    duration& operator= (duration&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export stringSeq : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // element
    public:
    using element_container_type = std::vector<::XMLSchema::string<ACE_TCHAR>>;
    using element_const_iterator = element_container_type::const_iterator;
    element_const_iterator begin_element () const;
    element_const_iterator end_element () const;
    size_t count_element () const;

    protected:
    element_container_type element_;

    public:
    stringSeq ();

    explicit stringSeq (::XSCRT::XML::Element<ACE_TCHAR> const&);
    stringSeq (stringSeq const& s);
    stringSeq& operator= (stringSeq const& s);

    stringSeq (stringSeq&&) = default;
    stringSeq& operator= (stringSeq&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export dataRepresentationIdSeq : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // element
    public:
    using element_container_type = std::vector<::dds::dataRepresentationIdKind>;
    using element_const_iterator = element_container_type::const_iterator;
    element_const_iterator begin_element () const;
    element_const_iterator end_element () const;
    size_t count_element () const;

    protected:
    element_container_type element_;

    public:
    dataRepresentationIdSeq ();

    explicit dataRepresentationIdSeq (::XSCRT::XML::Element<ACE_TCHAR> const&);
    dataRepresentationIdSeq (dataRepresentationIdSeq const& s);
    dataRepresentationIdSeq& operator= (dataRepresentationIdSeq const& s);

    dataRepresentationIdSeq (dataRepresentationIdSeq&&) = default;
    dataRepresentationIdSeq& operator= (dataRepresentationIdSeq&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export deadlineQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // period
    public:
    bool period_p () const;
    ::dds::duration const& period () const;
    void period (::dds::duration const&);

    protected:
    using period_type = std::unique_ptr<::dds::duration>;
    period_type period_;

    public:
    deadlineQosPolicy ();

    explicit deadlineQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    deadlineQosPolicy (deadlineQosPolicy const& s);
    deadlineQosPolicy& operator= (deadlineQosPolicy const& s);

    deadlineQosPolicy (deadlineQosPolicy&&) = default;
    deadlineQosPolicy& operator= (deadlineQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export destinationOrderQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::destinationOrderKind const& kind () const;
    void kind (::dds::destinationOrderKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::destinationOrderKind>;
    kind_type kind_;

    public:
    destinationOrderQosPolicy ();

    explicit destinationOrderQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    destinationOrderQosPolicy (destinationOrderQosPolicy const& s);
    destinationOrderQosPolicy& operator= (destinationOrderQosPolicy const& s);

    destinationOrderQosPolicy (destinationOrderQosPolicy&&) = default;
    destinationOrderQosPolicy& operator= (destinationOrderQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export durabilityQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::durabilityKind const& kind () const;
    void kind (::dds::durabilityKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::durabilityKind>;
    kind_type kind_;

    public:
    durabilityQosPolicy ();

    explicit durabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    durabilityQosPolicy (durabilityQosPolicy const& s);
    durabilityQosPolicy& operator= (durabilityQosPolicy const& s);

    durabilityQosPolicy (durabilityQosPolicy&&) = default;
    durabilityQosPolicy& operator= (durabilityQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export durabilityServiceQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // service_cleanup_delay
    public:
    bool service_cleanup_delay_p () const;
    ::dds::duration const& service_cleanup_delay () const;
    void service_cleanup_delay (::dds::duration const&);

    protected:
    using service_cleanup_delay_type = std::unique_ptr<::dds::duration>;
    service_cleanup_delay_type service_cleanup_delay_;

    // history_kind
    public:
    bool history_kind_p () const;
    ::dds::historyKind const& history_kind () const;
    void history_kind (::dds::historyKind const&);

    protected:
    using history_kind_type = std::unique_ptr<::dds::historyKind>;
    history_kind_type history_kind_;

    // history_depth
    public:
    bool history_depth_p () const;
    ::XMLSchema::positiveInteger const& history_depth () const;
    void history_depth (::XMLSchema::positiveInteger const&);

    protected:
    using history_depth_type = std::unique_ptr<::XMLSchema::positiveInteger>;
    history_depth_type history_depth_;

    // max_samples
    public:
    bool max_samples_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_samples () const;
    void max_samples (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_samples_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_samples_type max_samples_;

    // max_instances
    public:
    bool max_instances_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_instances () const;
    void max_instances (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_instances_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_instances_type max_instances_;

    // max_samples_per_instance
    public:
    bool max_samples_per_instance_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_samples_per_instance () const;
    void max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_samples_per_instance_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_samples_per_instance_type max_samples_per_instance_;

    public:
    durabilityServiceQosPolicy ();

    explicit durabilityServiceQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    durabilityServiceQosPolicy (durabilityServiceQosPolicy const& s);
    durabilityServiceQosPolicy& operator= (durabilityServiceQosPolicy const& s);

    durabilityServiceQosPolicy (durabilityServiceQosPolicy&&) = default;
    durabilityServiceQosPolicy& operator= (durabilityServiceQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export entityFactoryQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // autoenable_created_entities
    public:
    bool autoenable_created_entities_p () const;
    ::XMLSchema::boolean const& autoenable_created_entities () const;
    void autoenable_created_entities (::XMLSchema::boolean const&);

    protected:
    using autoenable_created_entities_type = std::unique_ptr<::XMLSchema::boolean>;
    autoenable_created_entities_type autoenable_created_entities_;

    public:
    entityFactoryQosPolicy ();

    explicit entityFactoryQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    entityFactoryQosPolicy (entityFactoryQosPolicy const& s);
    entityFactoryQosPolicy& operator= (entityFactoryQosPolicy const& s);

    entityFactoryQosPolicy (entityFactoryQosPolicy&&) = default;
    entityFactoryQosPolicy& operator= (entityFactoryQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export groupDataQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& value () const;
    void value (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using value_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    value_type value_;

    public:
    groupDataQosPolicy ();

    explicit groupDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    groupDataQosPolicy (groupDataQosPolicy const& s);
    groupDataQosPolicy& operator= (groupDataQosPolicy const& s);

    groupDataQosPolicy (groupDataQosPolicy&&) = default;
    groupDataQosPolicy& operator= (groupDataQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export historyQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::historyKind const& kind () const;
    void kind (::dds::historyKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::historyKind>;
    kind_type kind_;

    // depth
    public:
    bool depth_p () const;
    ::XMLSchema::positiveInteger const& depth () const;
    void depth (::XMLSchema::positiveInteger const&);

    protected:
    using depth_type = std::unique_ptr<::XMLSchema::positiveInteger>;
    depth_type depth_;

    public:
    historyQosPolicy ();

    explicit historyQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    historyQosPolicy (historyQosPolicy const& s);
    historyQosPolicy& operator= (historyQosPolicy const& s);

    historyQosPolicy (historyQosPolicy&&) = default;
    historyQosPolicy& operator= (historyQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export latencyBudgetQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // duration
    public:
    bool duration_p () const;
    ::dds::duration const& duration () const;
    void duration (::dds::duration const&);

    protected:
    using duration_type = std::unique_ptr<::dds::duration>;
    duration_type duration_;

    public:
    latencyBudgetQosPolicy ();

    explicit latencyBudgetQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    latencyBudgetQosPolicy (latencyBudgetQosPolicy const& s);
    latencyBudgetQosPolicy& operator= (latencyBudgetQosPolicy const& s);

    latencyBudgetQosPolicy (latencyBudgetQosPolicy&&) = default;
    latencyBudgetQosPolicy& operator= (latencyBudgetQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export lifespanQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // duration
    public:
    bool duration_p () const;
    ::dds::duration const& duration () const;
    void duration (::dds::duration const&);

    protected:
    using duration_type = std::unique_ptr<::dds::duration>;
    duration_type duration_;

    public:
    lifespanQosPolicy ();

    explicit lifespanQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    lifespanQosPolicy (lifespanQosPolicy const& s);
    lifespanQosPolicy& operator= (lifespanQosPolicy const& s);

    lifespanQosPolicy (lifespanQosPolicy&&) = default;
    lifespanQosPolicy& operator= (lifespanQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export livelinessQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::livelinessKind const& kind () const;
    void kind (::dds::livelinessKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::livelinessKind>;
    kind_type kind_;

    // lease_duration
    public:
    bool lease_duration_p () const;
    ::dds::duration const& lease_duration () const;
    void lease_duration (::dds::duration const&);

    protected:
    using lease_duration_type = std::unique_ptr<::dds::duration>;
    lease_duration_type lease_duration_;

    public:
    livelinessQosPolicy ();

    explicit livelinessQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    livelinessQosPolicy (livelinessQosPolicy const& s);
    livelinessQosPolicy& operator= (livelinessQosPolicy const& s);

    livelinessQosPolicy (livelinessQosPolicy&&) = default;
    livelinessQosPolicy& operator= (livelinessQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export ownershipQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::ownershipKind const& kind () const;
    void kind (::dds::ownershipKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::ownershipKind>;
    kind_type kind_;

    public:
    ownershipQosPolicy ();

    explicit ownershipQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    ownershipQosPolicy (ownershipQosPolicy const& s);
    ownershipQosPolicy& operator= (ownershipQosPolicy const& s);

    ownershipQosPolicy (ownershipQosPolicy&&) = default;
    ownershipQosPolicy& operator= (ownershipQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export ownershipStrengthQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::XMLSchema::nonNegativeInteger const& value () const;
    void value (::XMLSchema::nonNegativeInteger const&);

    protected:
    using value_type = std::unique_ptr<::XMLSchema::nonNegativeInteger>;
    value_type value_;

    public:
    ownershipStrengthQosPolicy ();

    explicit ownershipStrengthQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    ownershipStrengthQosPolicy (ownershipStrengthQosPolicy const& s);
    ownershipStrengthQosPolicy& operator= (ownershipStrengthQosPolicy const& s);

    ownershipStrengthQosPolicy (ownershipStrengthQosPolicy&&) = default;
    ownershipStrengthQosPolicy& operator= (ownershipStrengthQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export partitionQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // name
    public:
    bool name_p () const;
    ::dds::stringSeq const& name () const;
    void name (::dds::stringSeq const&);

    protected:
    using name_type = std::unique_ptr<::dds::stringSeq>;
    name_type name_;

    public:
    partitionQosPolicy ();

    explicit partitionQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    partitionQosPolicy (partitionQosPolicy const& s);
    partitionQosPolicy& operator= (partitionQosPolicy const& s);

    partitionQosPolicy (partitionQosPolicy&&) = default;
    partitionQosPolicy& operator= (partitionQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export presentationQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // access_scope
    public:
    bool access_scope_p () const;
    ::dds::presentationAccessScopeKind const& access_scope () const;
    void access_scope (::dds::presentationAccessScopeKind const&);

    protected:
    using access_scope_type = std::unique_ptr<::dds::presentationAccessScopeKind>;
    access_scope_type access_scope_;

    // coherent_access
    public:
    bool coherent_access_p () const;
    ::XMLSchema::boolean const& coherent_access () const;
    void coherent_access (::XMLSchema::boolean const&);

    protected:
    using coherent_access_type = std::unique_ptr<::XMLSchema::boolean>;
    coherent_access_type coherent_access_;

    // ordered_access
    public:
    bool ordered_access_p () const;
    ::XMLSchema::boolean const& ordered_access () const;
    void ordered_access (::XMLSchema::boolean const&);

    protected:
    using ordered_access_type = std::unique_ptr<::XMLSchema::boolean>;
    ordered_access_type ordered_access_;

    public:
    presentationQosPolicy ();

    explicit presentationQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    presentationQosPolicy (presentationQosPolicy const& s);
    presentationQosPolicy& operator= (presentationQosPolicy const& s);

    presentationQosPolicy (presentationQosPolicy&&) = default;
    presentationQosPolicy& operator= (presentationQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export readerDataLifecycleQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // autopurge_nowriter_samples_delay
    public:
    bool autopurge_nowriter_samples_delay_p () const;
    ::dds::duration const& autopurge_nowriter_samples_delay () const;
    void autopurge_nowriter_samples_delay (::dds::duration const&);

    protected:
    using autopurge_nowriter_samples_delay_type = std::unique_ptr<::dds::duration>;
    autopurge_nowriter_samples_delay_type autopurge_nowriter_samples_delay_;

    // autopurge_disposed_samples_delay
    public:
    bool autopurge_disposed_samples_delay_p () const;
    ::dds::duration const& autopurge_disposed_samples_delay () const;
    void autopurge_disposed_samples_delay (::dds::duration const&);

    protected:
    using autopurge_disposed_samples_delay_type = std::unique_ptr<::dds::duration>;
    autopurge_disposed_samples_delay_type autopurge_disposed_samples_delay_;

    public:
    readerDataLifecycleQosPolicy ();

    explicit readerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    readerDataLifecycleQosPolicy (readerDataLifecycleQosPolicy const& s);
    readerDataLifecycleQosPolicy& operator= (readerDataLifecycleQosPolicy const& s);

    readerDataLifecycleQosPolicy (readerDataLifecycleQosPolicy&&) = default;
    readerDataLifecycleQosPolicy& operator= (readerDataLifecycleQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export reliabilityQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::reliabilityKind const& kind () const;
    void kind (::dds::reliabilityKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::reliabilityKind>;
    kind_type kind_;

    // max_blocking_time
    public:
    bool max_blocking_time_p () const;
    ::dds::duration const& max_blocking_time () const;
    void max_blocking_time (::dds::duration const&);

    protected:
    using max_blocking_time_type = std::unique_ptr<::dds::duration>;
    max_blocking_time_type max_blocking_time_;

    public:
    reliabilityQosPolicy ();

    explicit reliabilityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    reliabilityQosPolicy (reliabilityQosPolicy const& s);
    reliabilityQosPolicy& operator= (reliabilityQosPolicy const& s);

    reliabilityQosPolicy (reliabilityQosPolicy&&) = default;
    reliabilityQosPolicy& operator= (reliabilityQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export resourceLimitsQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // max_samples
    public:
    bool max_samples_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_samples () const;
    void max_samples (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_samples_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_samples_type max_samples_;

    // max_instances
    public:
    bool max_instances_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_instances () const;
    void max_instances (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_instances_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_instances_type max_instances_;

    // max_samples_per_instance
    public:
    bool max_samples_per_instance_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& max_samples_per_instance () const;
    void max_samples_per_instance (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using max_samples_per_instance_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    max_samples_per_instance_type max_samples_per_instance_;

    // initial_samples
    public:
    bool initial_samples_p () const;
    ::XMLSchema::positiveInteger const& initial_samples () const;
    void initial_samples (::XMLSchema::positiveInteger const&);

    protected:
    using initial_samples_type = std::unique_ptr<::XMLSchema::positiveInteger>;
    initial_samples_type initial_samples_;

    // initial_instances
    public:
    bool initial_instances_p () const;
    ::XMLSchema::positiveInteger const& initial_instances () const;
    void initial_instances (::XMLSchema::positiveInteger const&);

    protected:
    using initial_instances_type = std::unique_ptr<::XMLSchema::positiveInteger>;
    initial_instances_type initial_instances_;

    public:
    resourceLimitsQosPolicy ();

    explicit resourceLimitsQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    resourceLimitsQosPolicy (resourceLimitsQosPolicy const& s);
    resourceLimitsQosPolicy& operator= (resourceLimitsQosPolicy const& s);

    resourceLimitsQosPolicy (resourceLimitsQosPolicy&&) = default;
    resourceLimitsQosPolicy& operator= (resourceLimitsQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export timeBasedFilterQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // minimum_separation
    public:
    bool minimum_separation_p () const;
    ::dds::duration const& minimum_separation () const;
    void minimum_separation (::dds::duration const&);

    protected:
    using minimum_separation_type = std::unique_ptr<::dds::duration>;
    minimum_separation_type minimum_separation_;

    public:
    timeBasedFilterQosPolicy ();

    explicit timeBasedFilterQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    timeBasedFilterQosPolicy (timeBasedFilterQosPolicy const& s);
    timeBasedFilterQosPolicy& operator= (timeBasedFilterQosPolicy const& s);

    timeBasedFilterQosPolicy (timeBasedFilterQosPolicy&&) = default;
    timeBasedFilterQosPolicy& operator= (timeBasedFilterQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export topicDataQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& value () const;
    void value (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using value_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    value_type value_;

    public:
    topicDataQosPolicy ();

    explicit topicDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    topicDataQosPolicy (topicDataQosPolicy const& s);
    topicDataQosPolicy& operator= (topicDataQosPolicy const& s);

    topicDataQosPolicy (topicDataQosPolicy&&) = default;
    topicDataQosPolicy& operator= (topicDataQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export transportPriorityQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::XMLSchema::nonNegativeInteger const& value () const;
    void value (::XMLSchema::nonNegativeInteger const&);

    protected:
    using value_type = std::unique_ptr<::XMLSchema::nonNegativeInteger>;
    value_type value_;

    public:
    transportPriorityQosPolicy ();

    explicit transportPriorityQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    transportPriorityQosPolicy (transportPriorityQosPolicy const& s);
    transportPriorityQosPolicy& operator= (transportPriorityQosPolicy const& s);

    transportPriorityQosPolicy (transportPriorityQosPolicy&&) = default;
    transportPriorityQosPolicy& operator= (transportPriorityQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export userDataQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& value () const;
    void value (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using value_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    value_type value_;

    public:
    userDataQosPolicy ();

    explicit userDataQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    userDataQosPolicy (userDataQosPolicy const& s);
    userDataQosPolicy& operator= (userDataQosPolicy const& s);

    userDataQosPolicy (userDataQosPolicy&&) = default;
    userDataQosPolicy& operator= (userDataQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export writerDataLifecycleQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // autodispose_unregistered_instances
    public:
    bool autodispose_unregistered_instances_p () const;
    ::XMLSchema::boolean const& autodispose_unregistered_instances () const;
    void autodispose_unregistered_instances (::XMLSchema::boolean const&);

    protected:
    using autodispose_unregistered_instances_type = std::unique_ptr<::XMLSchema::boolean>;
    autodispose_unregistered_instances_type autodispose_unregistered_instances_;

    public:
    writerDataLifecycleQosPolicy ();

    explicit writerDataLifecycleQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    writerDataLifecycleQosPolicy (writerDataLifecycleQosPolicy const& s);
    writerDataLifecycleQosPolicy& operator= (writerDataLifecycleQosPolicy const& s);

    writerDataLifecycleQosPolicy (writerDataLifecycleQosPolicy&&) = default;
    writerDataLifecycleQosPolicy& operator= (writerDataLifecycleQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export dataRepresentationQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // value
    public:
    bool value_p () const;
    ::dds::dataRepresentationIdSeq const& value () const;
    void value (::dds::dataRepresentationIdSeq const&);

    protected:
    using value_type = std::unique_ptr<::dds::dataRepresentationIdSeq>;
    value_type value_;

    public:
    dataRepresentationQosPolicy ();

    explicit dataRepresentationQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    dataRepresentationQosPolicy (dataRepresentationQosPolicy const& s);
    dataRepresentationQosPolicy& operator= (dataRepresentationQosPolicy const& s);

    dataRepresentationQosPolicy (dataRepresentationQosPolicy&&) = default;
    dataRepresentationQosPolicy& operator= (dataRepresentationQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export typeConsistencyEnforcementQosPolicy : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // kind
    public:
    bool kind_p () const;
    ::dds::typeConsistencyKind const& kind () const;
    void kind (::dds::typeConsistencyKind const&);

    protected:
    using kind_type = std::unique_ptr<::dds::typeConsistencyKind>;
    kind_type kind_;

    // ignore_sequence_bounds
    public:
    bool ignore_sequence_bounds_p () const;
    ::XMLSchema::boolean const& ignore_sequence_bounds () const;
    void ignore_sequence_bounds (::XMLSchema::boolean const&);

    protected:
    using ignore_sequence_bounds_type = std::unique_ptr<::XMLSchema::boolean>;
    ignore_sequence_bounds_type ignore_sequence_bounds_;

    // ignore_string_bounds
    public:
    bool ignore_string_bounds_p () const;
    ::XMLSchema::boolean const& ignore_string_bounds () const;
    void ignore_string_bounds (::XMLSchema::boolean const&);

    protected:
    using ignore_string_bounds_type = std::unique_ptr<::XMLSchema::boolean>;
    ignore_string_bounds_type ignore_string_bounds_;

    // ignore_member_names
    public:
    bool ignore_member_names_p () const;
    ::XMLSchema::boolean const& ignore_member_names () const;
    void ignore_member_names (::XMLSchema::boolean const&);

    protected:
    using ignore_member_names_type = std::unique_ptr<::XMLSchema::boolean>;
    ignore_member_names_type ignore_member_names_;

    // prevent_type_widening
    public:
    bool prevent_type_widening_p () const;
    ::XMLSchema::boolean const& prevent_type_widening () const;
    void prevent_type_widening (::XMLSchema::boolean const&);

    protected:
    using prevent_type_widening_type = std::unique_ptr<::XMLSchema::boolean>;
    prevent_type_widening_type prevent_type_widening_;

    // force_type_validation
    public:
    bool force_type_validation_p () const;
    ::XMLSchema::boolean const& force_type_validation () const;
    void force_type_validation (::XMLSchema::boolean const&);

    protected:
    using force_type_validation_type = std::unique_ptr<::XMLSchema::boolean>;
    force_type_validation_type force_type_validation_;

    public:
    typeConsistencyEnforcementQosPolicy ();

    explicit typeConsistencyEnforcementQosPolicy (::XSCRT::XML::Element<ACE_TCHAR> const&);
    typeConsistencyEnforcementQosPolicy (typeConsistencyEnforcementQosPolicy const& s);
    typeConsistencyEnforcementQosPolicy& operator= (typeConsistencyEnforcementQosPolicy const& s);

    typeConsistencyEnforcementQosPolicy (typeConsistencyEnforcementQosPolicy&&) = default;
    typeConsistencyEnforcementQosPolicy& operator= (typeConsistencyEnforcementQosPolicy&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export domainparticipantQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // user_data
    public:
    bool user_data_p () const;
    ::dds::userDataQosPolicy const& user_data () const;
    void user_data (::dds::userDataQosPolicy const&);

    protected:
    using user_data_type = std::unique_ptr<::dds::userDataQosPolicy>;
    user_data_type user_data_;

    // entity_factory
    public:
    bool entity_factory_p () const;
    ::dds::entityFactoryQosPolicy const& entity_factory () const;
    void entity_factory (::dds::entityFactoryQosPolicy const&);

    protected:
    using entity_factory_type = std::unique_ptr<::dds::entityFactoryQosPolicy>;
    entity_factory_type entity_factory_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    public:
    domainparticipantQos ();

    explicit domainparticipantQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    domainparticipantQos (domainparticipantQos const& s);
    domainparticipantQos& operator= (domainparticipantQos const& s);

    domainparticipantQos (domainparticipantQos&&) = default;
    domainparticipantQos& operator= (domainparticipantQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export publisherQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // presentation
    public:
    bool presentation_p () const;
    ::dds::presentationQosPolicy const& presentation () const;
    void presentation (::dds::presentationQosPolicy const&);

    protected:
    using presentation_type = std::unique_ptr<::dds::presentationQosPolicy>;
    presentation_type presentation_;

    // partition
    public:
    bool partition_p () const;
    ::dds::partitionQosPolicy const& partition () const;
    void partition (::dds::partitionQosPolicy const&);

    protected:
    using partition_type = std::unique_ptr<::dds::partitionQosPolicy>;
    partition_type partition_;

    // group_data
    public:
    bool group_data_p () const;
    ::dds::groupDataQosPolicy const& group_data () const;
    void group_data (::dds::groupDataQosPolicy const&);

    protected:
    using group_data_type = std::unique_ptr<::dds::groupDataQosPolicy>;
    group_data_type group_data_;

    // entity_factory
    public:
    bool entity_factory_p () const;
    ::dds::entityFactoryQosPolicy const& entity_factory () const;
    void entity_factory (::dds::entityFactoryQosPolicy const&);

    protected:
    using entity_factory_type = std::unique_ptr<::dds::entityFactoryQosPolicy>;
    entity_factory_type entity_factory_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    public:
    publisherQos ();

    explicit publisherQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    publisherQos (publisherQos const& s);
    publisherQos& operator= (publisherQos const& s);

    publisherQos (publisherQos&&) = default;
    publisherQos& operator= (publisherQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export subscriberQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // presentation
    public:
    bool presentation_p () const;
    ::dds::presentationQosPolicy const& presentation () const;
    void presentation (::dds::presentationQosPolicy const&);

    protected:
    using presentation_type = std::unique_ptr<::dds::presentationQosPolicy>;
    presentation_type presentation_;

    // partition
    public:
    bool partition_p () const;
    ::dds::partitionQosPolicy const& partition () const;
    void partition (::dds::partitionQosPolicy const&);

    protected:
    using partition_type = std::unique_ptr<::dds::partitionQosPolicy>;
    partition_type partition_;

    // group_data
    public:
    bool group_data_p () const;
    ::dds::groupDataQosPolicy const& group_data () const;
    void group_data (::dds::groupDataQosPolicy const&);

    protected:
    using group_data_type = std::unique_ptr<::dds::groupDataQosPolicy>;
    group_data_type group_data_;

    // entity_factory
    public:
    bool entity_factory_p () const;
    ::dds::entityFactoryQosPolicy const& entity_factory () const;
    void entity_factory (::dds::entityFactoryQosPolicy const&);

    protected:
    using entity_factory_type = std::unique_ptr<::dds::entityFactoryQosPolicy>;
    entity_factory_type entity_factory_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    public:
    subscriberQos ();

    explicit subscriberQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    subscriberQos (subscriberQos const& s);
    subscriberQos& operator= (subscriberQos const& s);

    subscriberQos (subscriberQos&&) = default;
    subscriberQos& operator= (subscriberQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export topicQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // topic_data
    public:
    bool topic_data_p () const;
    ::dds::topicDataQosPolicy const& topic_data () const;
    void topic_data (::dds::topicDataQosPolicy const&);

    protected:
    using topic_data_type = std::unique_ptr<::dds::topicDataQosPolicy>;
    topic_data_type topic_data_;

    // durability
    public:
    bool durability_p () const;
    ::dds::durabilityQosPolicy const& durability () const;
    void durability (::dds::durabilityQosPolicy const&);

    protected:
    using durability_type = std::unique_ptr<::dds::durabilityQosPolicy>;
    durability_type durability_;

    // durability_service
    public:
    bool durability_service_p () const;
    ::dds::durabilityServiceQosPolicy const& durability_service () const;
    void durability_service (::dds::durabilityServiceQosPolicy const&);

    protected:
    using durability_service_type = std::unique_ptr<::dds::durabilityServiceQosPolicy>;
    durability_service_type durability_service_;

    // deadline
    public:
    bool deadline_p () const;
    ::dds::deadlineQosPolicy const& deadline () const;
    void deadline (::dds::deadlineQosPolicy const&);

    protected:
    using deadline_type = std::unique_ptr<::dds::deadlineQosPolicy>;
    deadline_type deadline_;

    // latency_budget
    public:
    bool latency_budget_p () const;
    ::dds::latencyBudgetQosPolicy const& latency_budget () const;
    void latency_budget (::dds::latencyBudgetQosPolicy const&);

    protected:
    using latency_budget_type = std::unique_ptr<::dds::latencyBudgetQosPolicy>;
    latency_budget_type latency_budget_;

    // liveliness
    public:
    bool liveliness_p () const;
    ::dds::livelinessQosPolicy const& liveliness () const;
    void liveliness (::dds::livelinessQosPolicy const&);

    protected:
    using liveliness_type = std::unique_ptr<::dds::livelinessQosPolicy>;
    liveliness_type liveliness_;

    // reliability
    public:
    bool reliability_p () const;
    ::dds::reliabilityQosPolicy const& reliability () const;
    void reliability (::dds::reliabilityQosPolicy const&);

    protected:
    using reliability_type = std::unique_ptr<::dds::reliabilityQosPolicy>;
    reliability_type reliability_;

    // destination_order
    public:
    bool destination_order_p () const;
    ::dds::destinationOrderQosPolicy const& destination_order () const;
    void destination_order (::dds::destinationOrderQosPolicy const&);

    protected:
    using destination_order_type = std::unique_ptr<::dds::destinationOrderQosPolicy>;
    destination_order_type destination_order_;

    // history
    public:
    bool history_p () const;
    ::dds::historyQosPolicy const& history () const;
    void history (::dds::historyQosPolicy const&);

    protected:
    using history_type = std::unique_ptr<::dds::historyQosPolicy>;
    history_type history_;

    // resource_limits
    public:
    bool resource_limits_p () const;
    ::dds::resourceLimitsQosPolicy const& resource_limits () const;
    void resource_limits (::dds::resourceLimitsQosPolicy const&);

    protected:
    using resource_limits_type = std::unique_ptr<::dds::resourceLimitsQosPolicy>;
    resource_limits_type resource_limits_;

    // transport_priority
    public:
    bool transport_priority_p () const;
    ::dds::transportPriorityQosPolicy const& transport_priority () const;
    void transport_priority (::dds::transportPriorityQosPolicy const&);

    protected:
    using transport_priority_type = std::unique_ptr<::dds::transportPriorityQosPolicy>;
    transport_priority_type transport_priority_;

    // lifespan
    public:
    bool lifespan_p () const;
    ::dds::lifespanQosPolicy const& lifespan () const;
    void lifespan (::dds::lifespanQosPolicy const&);

    protected:
    using lifespan_type = std::unique_ptr<::dds::lifespanQosPolicy>;
    lifespan_type lifespan_;

    // ownership
    public:
    bool ownership_p () const;
    ::dds::ownershipQosPolicy const& ownership () const;
    void ownership (::dds::ownershipQosPolicy const&);

    protected:
    using ownership_type = std::unique_ptr<::dds::ownershipQosPolicy>;
    ownership_type ownership_;

    // representation
    public:
    bool representation_p () const;
    ::dds::dataRepresentationQosPolicy const& representation () const;
    void representation (::dds::dataRepresentationQosPolicy const&);

    protected:
    using representation_type = std::unique_ptr<::dds::dataRepresentationQosPolicy>;
    representation_type representation_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    // topic_filter
    public:
    bool topic_filter_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& topic_filter () const;
    ::XMLSchema::string<ACE_TCHAR>& topic_filter ();
    void topic_filter (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using topic_filter_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    topic_filter_type topic_filter_;

    public:
    topicQos ();

    explicit topicQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    topicQos (topicQos const& s);
    topicQos& operator= (topicQos const& s);

    topicQos (topicQos&&) = default;
    topicQos& operator= (topicQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export datareaderQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // durability
    public:
    bool durability_p () const;
    ::dds::durabilityQosPolicy const& durability () const;
    void durability (::dds::durabilityQosPolicy const&);

    protected:
    using durability_type = std::unique_ptr<::dds::durabilityQosPolicy>;
    durability_type durability_;

    // deadline
    public:
    bool deadline_p () const;
    ::dds::deadlineQosPolicy const& deadline () const;
    void deadline (::dds::deadlineQosPolicy const&);

    protected:
    using deadline_type = std::unique_ptr<::dds::deadlineQosPolicy>;
    deadline_type deadline_;

    // latency_budget
    public:
    bool latency_budget_p () const;
    ::dds::latencyBudgetQosPolicy const& latency_budget () const;
    void latency_budget (::dds::latencyBudgetQosPolicy const&);

    protected:
    using latency_budget_type = std::unique_ptr<::dds::latencyBudgetQosPolicy>;
    latency_budget_type latency_budget_;

    // liveliness
    public:
    bool liveliness_p () const;
    ::dds::livelinessQosPolicy const& liveliness () const;
    void liveliness (::dds::livelinessQosPolicy const&);

    protected:
    using liveliness_type = std::unique_ptr<::dds::livelinessQosPolicy>;
    liveliness_type liveliness_;

    // reliability
    public:
    bool reliability_p () const;
    ::dds::reliabilityQosPolicy const& reliability () const;
    void reliability (::dds::reliabilityQosPolicy const&);

    protected:
    using reliability_type = std::unique_ptr<::dds::reliabilityQosPolicy>;
    reliability_type reliability_;

    // destination_order
    public:
    bool destination_order_p () const;
    ::dds::destinationOrderQosPolicy const& destination_order () const;
    void destination_order (::dds::destinationOrderQosPolicy const&);

    protected:
    using destination_order_type = std::unique_ptr<::dds::destinationOrderQosPolicy>;
    destination_order_type destination_order_;

    // history
    public:
    bool history_p () const;
    ::dds::historyQosPolicy const& history () const;
    void history (::dds::historyQosPolicy const&);

    protected:
    using history_type = std::unique_ptr<::dds::historyQosPolicy>;
    history_type history_;

    // resource_limits
    public:
    bool resource_limits_p () const;
    ::dds::resourceLimitsQosPolicy const& resource_limits () const;
    void resource_limits (::dds::resourceLimitsQosPolicy const&);

    protected:
    using resource_limits_type = std::unique_ptr<::dds::resourceLimitsQosPolicy>;
    resource_limits_type resource_limits_;

    // user_data
    public:
    bool user_data_p () const;
    ::dds::userDataQosPolicy const& user_data () const;
    void user_data (::dds::userDataQosPolicy const&);

    protected:
    using user_data_type = std::unique_ptr<::dds::userDataQosPolicy>;
    user_data_type user_data_;

    // ownership
    public:
    bool ownership_p () const;
    ::dds::ownershipQosPolicy const& ownership () const;
    void ownership (::dds::ownershipQosPolicy const&);

    protected:
    using ownership_type = std::unique_ptr<::dds::ownershipQosPolicy>;
    ownership_type ownership_;

    // time_based_filter
    public:
    bool time_based_filter_p () const;
    ::dds::timeBasedFilterQosPolicy const& time_based_filter () const;
    void time_based_filter (::dds::timeBasedFilterQosPolicy const&);

    protected:
    using time_based_filter_type = std::unique_ptr<::dds::timeBasedFilterQosPolicy>;
    time_based_filter_type time_based_filter_;

    // reader_data_lifecycle
    public:
    bool reader_data_lifecycle_p () const;
    ::dds::readerDataLifecycleQosPolicy const& reader_data_lifecycle () const;
    void reader_data_lifecycle (::dds::readerDataLifecycleQosPolicy const&);

    protected:
    using reader_data_lifecycle_type = std::unique_ptr<::dds::readerDataLifecycleQosPolicy>;
    reader_data_lifecycle_type reader_data_lifecycle_;

    // representation
    public:
    bool representation_p () const;
    ::dds::dataRepresentationQosPolicy const& representation () const;
    void representation (::dds::dataRepresentationQosPolicy const&);

    protected:
    using representation_type = std::unique_ptr<::dds::dataRepresentationQosPolicy>;
    representation_type representation_;

    // type_consistency
    public:
    bool type_consistency_p () const;
    ::dds::typeConsistencyEnforcementQosPolicy const& type_consistency () const;
    void type_consistency (::dds::typeConsistencyEnforcementQosPolicy const&);

    protected:
    using type_consistency_type = std::unique_ptr<::dds::typeConsistencyEnforcementQosPolicy>;
    type_consistency_type type_consistency_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    // topic_filter
    public:
    bool topic_filter_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& topic_filter () const;
    ::XMLSchema::string<ACE_TCHAR>& topic_filter ();
    void topic_filter (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using topic_filter_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    topic_filter_type topic_filter_;

    public:
    datareaderQos ();

    explicit datareaderQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    datareaderQos (datareaderQos const& s);
    datareaderQos& operator= (datareaderQos const& s);

    datareaderQos (datareaderQos&&) = default;
    datareaderQos& operator= (datareaderQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export datawriterQos : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // durability
    public:
    bool durability_p () const;
    ::dds::durabilityQosPolicy const& durability () const;
    void durability (::dds::durabilityQosPolicy const&);

    protected:
    using durability_type = std::unique_ptr<::dds::durabilityQosPolicy>;
    durability_type durability_;

    // durability_service
    public:
    bool durability_service_p () const;
    ::dds::durabilityServiceQosPolicy const& durability_service () const;
    void durability_service (::dds::durabilityServiceQosPolicy const&);

    protected:
    using durability_service_type = std::unique_ptr<::dds::durabilityServiceQosPolicy>;
    durability_service_type durability_service_;

    // deadline
    public:
    bool deadline_p () const;
    ::dds::deadlineQosPolicy const& deadline () const;
    void deadline (::dds::deadlineQosPolicy const&);

    protected:
    using deadline_type = std::unique_ptr<::dds::deadlineQosPolicy>;
    deadline_type deadline_;

    // latency_budget
    public:
    bool latency_budget_p () const;
    ::dds::latencyBudgetQosPolicy const& latency_budget () const;
    void latency_budget (::dds::latencyBudgetQosPolicy const&);

    protected:
    using latency_budget_type = std::unique_ptr<::dds::latencyBudgetQosPolicy>;
    latency_budget_type latency_budget_;

    // liveliness
    public:
    bool liveliness_p () const;
    ::dds::livelinessQosPolicy const& liveliness () const;
    void liveliness (::dds::livelinessQosPolicy const&);

    protected:
    using liveliness_type = std::unique_ptr<::dds::livelinessQosPolicy>;
    liveliness_type liveliness_;

    // reliability
    public:
    bool reliability_p () const;
    ::dds::reliabilityQosPolicy const& reliability () const;
    void reliability (::dds::reliabilityQosPolicy const&);

    protected:
    using reliability_type = std::unique_ptr<::dds::reliabilityQosPolicy>;
    reliability_type reliability_;

    // destination_order
    public:
    bool destination_order_p () const;
    ::dds::destinationOrderQosPolicy const& destination_order () const;
    void destination_order (::dds::destinationOrderQosPolicy const&);

    protected:
    using destination_order_type = std::unique_ptr<::dds::destinationOrderQosPolicy>;
    destination_order_type destination_order_;

    // history
    public:
    bool history_p () const;
    ::dds::historyQosPolicy const& history () const;
    void history (::dds::historyQosPolicy const&);

    protected:
    using history_type = std::unique_ptr<::dds::historyQosPolicy>;
    history_type history_;

    // resource_limits
    public:
    bool resource_limits_p () const;
    ::dds::resourceLimitsQosPolicy const& resource_limits () const;
    void resource_limits (::dds::resourceLimitsQosPolicy const&);

    protected:
    using resource_limits_type = std::unique_ptr<::dds::resourceLimitsQosPolicy>;
    resource_limits_type resource_limits_;

    // transport_priority
    public:
    bool transport_priority_p () const;
    ::dds::transportPriorityQosPolicy const& transport_priority () const;
    void transport_priority (::dds::transportPriorityQosPolicy const&);

    protected:
    using transport_priority_type = std::unique_ptr<::dds::transportPriorityQosPolicy>;
    transport_priority_type transport_priority_;

    // lifespan
    public:
    bool lifespan_p () const;
    ::dds::lifespanQosPolicy const& lifespan () const;
    void lifespan (::dds::lifespanQosPolicy const&);

    protected:
    using lifespan_type = std::unique_ptr<::dds::lifespanQosPolicy>;
    lifespan_type lifespan_;

    // user_data
    public:
    bool user_data_p () const;
    ::dds::userDataQosPolicy const& user_data () const;
    void user_data (::dds::userDataQosPolicy const&);

    protected:
    using user_data_type = std::unique_ptr<::dds::userDataQosPolicy>;
    user_data_type user_data_;

    // ownership
    public:
    bool ownership_p () const;
    ::dds::ownershipQosPolicy const& ownership () const;
    void ownership (::dds::ownershipQosPolicy const&);

    protected:
    using ownership_type = std::unique_ptr<::dds::ownershipQosPolicy>;
    ownership_type ownership_;

    // ownership_strength
    public:
    bool ownership_strength_p () const;
    ::dds::ownershipStrengthQosPolicy const& ownership_strength () const;
    void ownership_strength (::dds::ownershipStrengthQosPolicy const&);

    protected:
    using ownership_strength_type = std::unique_ptr<::dds::ownershipStrengthQosPolicy>;
    ownership_strength_type ownership_strength_;

    // writer_data_lifecycle
    public:
    bool writer_data_lifecycle_p () const;
    ::dds::writerDataLifecycleQosPolicy const& writer_data_lifecycle () const;
    void writer_data_lifecycle (::dds::writerDataLifecycleQosPolicy const&);

    protected:
    using writer_data_lifecycle_type = std::unique_ptr<::dds::writerDataLifecycleQosPolicy>;
    writer_data_lifecycle_type writer_data_lifecycle_;

    // representation
    public:
    bool representation_p () const;
    ::dds::dataRepresentationQosPolicy const& representation () const;
    void representation (::dds::dataRepresentationQosPolicy const&);

    protected:
    using representation_type = std::unique_ptr<::dds::dataRepresentationQosPolicy>;
    representation_type representation_;

    // name
    public:
    bool name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    // topic_filter
    public:
    bool topic_filter_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& topic_filter () const;
    ::XMLSchema::string<ACE_TCHAR>& topic_filter ();
    void topic_filter (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using topic_filter_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    topic_filter_type topic_filter_;

    public:
    datawriterQos ();

    explicit datawriterQos (::XSCRT::XML::Element<ACE_TCHAR> const&);
    datawriterQos (datawriterQos const& s);
    datawriterQos& operator= (datawriterQos const& s);

    datawriterQos (datawriterQos&&) = default;
    datawriterQos& operator= (datawriterQos&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export qosProfile : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // datareader_qos
    public:
    using datareader_qos_container_type = std::vector<::dds::datareaderQos>;
    using datareader_qos_const_iterator = datareader_qos_container_type::const_iterator;
    datareader_qos_const_iterator begin_datareader_qos () const;
    datareader_qos_const_iterator end_datareader_qos () const;
    size_t count_datareader_qos () const;

    protected:
    datareader_qos_container_type datareader_qos_;

    // datawriter_qos
    public:
    using datawriter_qos_container_type = std::vector<::dds::datawriterQos>;
    using datawriter_qos_const_iterator = datawriter_qos_container_type::const_iterator;
    datawriter_qos_const_iterator begin_datawriter_qos () const;
    datawriter_qos_const_iterator end_datawriter_qos () const;
    size_t count_datawriter_qos () const;

    protected:
    datawriter_qos_container_type datawriter_qos_;

    // topic_qos
    public:
    using topic_qos_container_type = std::vector<::dds::topicQos>;
    using topic_qos_const_iterator = topic_qos_container_type::const_iterator;
    topic_qos_const_iterator begin_topic_qos () const;
    topic_qos_const_iterator end_topic_qos () const;
    size_t count_topic_qos () const;

    protected:
    topic_qos_container_type topic_qos_;

    // domainparticipant_qos
    public:
    using domainparticipant_qos_container_type = std::vector<::dds::domainparticipantQos>;
    using domainparticipant_qos_const_iterator = domainparticipant_qos_container_type::const_iterator;
    domainparticipant_qos_const_iterator begin_domainparticipant_qos () const;
    domainparticipant_qos_const_iterator end_domainparticipant_qos () const;
    size_t count_domainparticipant_qos () const;

    protected:
    domainparticipant_qos_container_type domainparticipant_qos_;

    // publisher_qos
    public:
    using publisher_qos_container_type = std::vector<::dds::publisherQos>;
    using publisher_qos_const_iterator = publisher_qos_container_type::const_iterator;
    publisher_qos_const_iterator begin_publisher_qos () const;
    publisher_qos_const_iterator end_publisher_qos () const;
    size_t count_publisher_qos () const;

    protected:
    publisher_qos_container_type publisher_qos_;

    // subscriber_qos
    public:
    using subscriber_qos_container_type = std::vector<::dds::subscriberQos>;
    using subscriber_qos_const_iterator = subscriber_qos_container_type::const_iterator;
    subscriber_qos_const_iterator begin_subscriber_qos () const;
    subscriber_qos_const_iterator end_subscriber_qos () const;
    size_t count_subscriber_qos () const;

    protected:
    subscriber_qos_container_type subscriber_qos_;

    // name
    public:
    ::XMLSchema::string<ACE_TCHAR> const& name () const;
    ::XMLSchema::string<ACE_TCHAR>& name ();
    void name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    name_type name_;

    // base_name
    public:
    bool base_name_p () const;
    ::XMLSchema::string<ACE_TCHAR> const& base_name () const;
    ::XMLSchema::string<ACE_TCHAR>& base_name ();
    void base_name (::XMLSchema::string<ACE_TCHAR> const&);

    protected:
    using base_name_type = std::unique_ptr<::XMLSchema::string<ACE_TCHAR>>;
    base_name_type base_name_;

    public:
    qosProfile (::XMLSchema::string<ACE_TCHAR> const& name__);

    explicit qosProfile (::XSCRT::XML::Element<ACE_TCHAR> const&);
    qosProfile (qosProfile const& s);
    qosProfile& operator= (qosProfile const& s);

    qosProfile (qosProfile&&) = default;
    qosProfile& operator= (qosProfile&&) = default;
  };


  class OpenDDS_XML_QOS_Handler_Export qosProfile_seq : public ::XSCRT::Type
  {
    using Base = ::XSCRT::Type;

    // qos_profile
    public:
    using qos_profile_container_type = std::vector<::dds::qosProfile>;
    using qos_profile_const_iterator = qos_profile_container_type::const_iterator;
    qos_profile_const_iterator begin_qos_profile () const;
    qos_profile_const_iterator end_qos_profile () const;
    size_t count_qos_profile () const;

    protected:
    qos_profile_container_type qos_profile_;

    public:
    qosProfile_seq ();

    explicit qosProfile_seq (::XSCRT::XML::Element<ACE_TCHAR> const&);
    qosProfile_seq (qosProfile_seq const& s);
    qosProfile_seq& operator= (qosProfile_seq const& s);

    qosProfile_seq (qosProfile_seq&&) = default;
    qosProfile_seq& operator= (qosProfile_seq&&) = default;
  };
}

namespace dds
{
  namespace reader
  {
    OpenDDS_XML_QOS_Handler_Export
    ::dds::qosProfile_seq
    dds (xercesc::DOMDocument const*);
  }
}

#endif // OPENDDS_DCPS_QOS_XML_HANDLER_DDS_QOS_HPP
